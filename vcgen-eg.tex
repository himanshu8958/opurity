\paragraph{Example}

We transform the given procedure into the following representation
in-order to encode it in logic. For example procedure factorial
in Listing~\ref{lst:factorialTransformed}, is the transformed version
of procedure factorial in Listing~\ref{lst:factorialSimple}.

\begin{lstlisting}[language=c, caption= {Procedure factorial from
      Listing~\ref{lst:factorialSimple} converted to the form our
      approach expects. We refer to this procedure as `transformed
      factorial'.}, label=lst:factorialTransformed]
int g = -1;
int transformedFactorial( int n) { // redo
  if(n <= 1) {
    retVar = 1;
    gout = g;
  } else if(g == -1 && n == 19) {
    gbef1 = g;
    temp1 = F(18);  // temp1 = factorial(18)
    havoc(g1);
    gaft1 = g1;
    g2 = 19 * temp1;
    retVar = g2;
    gout = g2;
  } else if (g != -1 && n == 19) {
    retVar = g;
    gout = g;
  } else {
    gbef2 = g;
    temp2 = F( n - 1 );  //temp2 = factorial(n-1)
    havoc(g2);
    gaft2 = g3;
    retVar = n * temp2;
    gout = g3;
  }
}
\end{lstlisting}

Now we compare `transformed factorial' and procedure factorial from
Listings~\ref{lst:factorialTransformed} and \ref{lst:factorialSimple}
respectively. The return statement (line 4) in procedure factorial
is replaced by assignment to variable `\retVar' (line 4). Also, we
have a added an assignment statement (line 5) in `transformed
factorial', that defines variable `gout' in-order to store the value
of variable `g' at the procedure boundary. Similarly, variable `gbef1'
(line 7) is added in `transformed factorial' to capture the value of
the global variable before the procedure call and assignment to
variable `gaft1' is inserted at line 10 to capture the value of `g'
after the procedure call. Also, havoc statements at lines 9 and 20
over-approximate any side effects to the global variables. And in
lines 8 and 19, the procedure call statements are substituted for
function symbols.

\begin{figure}
  \begin{align*}
    \pathCondition :=
    &(n \leq 1 \wedge retVar = 1 \wedge gout = g) \vee \\
    &(n > 1 \wedge g = -1 = gbef \wedge n = 19 \wedge temp1 = \F(18) \\
    \;&\wedge gaft1 = g1 \wedge g2 = 19 * temp1
    \wedge retVar = g2) \vee\\
    &(n > 1 \wedge \neg( g = -1 \wedge n = 19) \wedge g \neq -1
    \wedge n = 19 \wedge retVar = g = gout) \vee\\
    &(n > 1 \wedge n \neq 19 \wedge gbef2 = g \wedge temp2 = \F( n
    - 1) \wedge gaft2 = g1\\
    &\wedge retVar = n * temp2 \wedge gout = g1)\\
  \end{align*}
  \caption{Formula representing procedure `transformed factorial' in
    Listing~\ref{lst:factorialTransformed} (assuming that function
    $\F$ is equivalent to procedure factorial).}
  \label{fig:pathCondition}
\end{figure}

For example, the procedure `transformed factorial' in
Listing~\ref{lst:factorialTransformed} is expressed in logic as shown
in Figure~\ref{fig:pathCondition}. Each disjunct in
Figure~\ref{fig:pathCondition} represents a straight-line execution of
procedure factorial (from beginning, until end) . For instance, $(n <=
1 \wedge retVar = 1 \wedge gout = g)$ represents the case where $`n
\leq 1'$.