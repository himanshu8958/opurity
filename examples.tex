\section{Examples}

\subsection{Factorial}
\begin{verbatim}
invariant : (or (= nineteen (- 0 1)) (= nineteen (* (Fact 18) 19)))
\end{verbatim}
\begin{lstlisting}[language=c, caption= {Procedure `factorial' :
      returns factorial of `n' and memoizes result for argument value
      `19'.}, label=lst:fact19]
var nineteen: int;
procedure {:entrypoint} Fact(a: int) returns (r: int) modifies nineteen;{
  if( a <= 1) { r := 1;}
  else {
    if( a == 19) {
      if( nineteen == -1) {
        call nineteen := Fact(18);
        nineteen := nineteen * 19;
        r := nineteen;
      } else {
        r := nineteen;
      }
    } else {
      call r := Fact( a - 1);
      r := a * r;
    }
  }
}
\end{lstlisting}

\subsection{Factorial Array}
\begin{verbatim}
invariant : (forall ((k Int) ) (or (= (select g k) 0) (= (*
k (FactArray (- k 1))) (select g k))))
\end{verbatim}
\begin{lstlisting}[language=c, caption= {Procedure `FactArray' cache result for each argument value greater than 1}, label=lst:factArrayImpl]
var g: [int] int;
procedure {:entrypoint} FactArray(n: int) returns (r: int) modifies g;{
  var k :int;
  if( n <= 1) { r := 1;}
  else {
    if( g[n] == 0) {
      call k := FactArray(n - 1);
      g[n] := k * n;
    } 
    r  := g[n];
  }
}
\end{lstlisting}

\subsection{Factorial Recent}
\begin{verbatim}
Invariant : (or (= lastAns (- 0 1)) (= lastAns (* (recent_fact (+ (- 0 1) lastN)) lastN)))
\end{verbatim}
%% \lstinputlisting{examples/fact-recent/factRecent.bpl}
\begin{lstlisting}[language=c, caption= {Procedure `recent\_fact' :
      returns factorial of `n' and memoizes result for the last argument value.}, label=lst:factorialRecent]
var lastN: int;
var lastAns: int;
//invariant : lastAns = -1 || g = lastN * factorial(lastN -1) && lastN >1 
procedure {:entrypoint} recent_fact(a: int) returns (r: int) modifies lastN, lastAns;{
  if( a <= 1) { r := 1;}
  else {
     if( a == lastN && lastAns != -1) {
        r := lastAns;
      } else {
      call r := recent_fact( a - 1);    
      r := a * r;
      lastN := a;
      lastAns := r;
    }
  }
}
\end{lstlisting}

\subsection{Fibonacci}
%% \lstinputlisting{examples/fib/fib.bpl}
\begin{verbatim}
Invariant : (or (= (select cache k) 0) (= (+ (fib (- k 1)) (fib (- k 2))) (select cache k)))
\end{verbatim}
\begin{lstlisting}[language=c, caption= {Procedure `fib' :
      returns the n'th fibonacci number}, label=lst:factorialSimple]
//invariant : forall k. cache[k] = 0 OR cache[k] = fib(k -1) + fib( k -2)
var cache:[int] int;
procedure {:entrypoint} fib(n: int) returns (r: int) modifies cache;{
  var a, b : int;
  if( n <= 2) {
    r := 1;
  } else {
    if(cache[n] != 0) {
      r := cache[n];
    } else {
      call a := fib(n -1);
      call b := fib(n -2);
      r := a + b;
      cache[n] := r;
    }
  }
}
\end{lstlisting}

\subsection{Matrix Chain Multipication}
\begin{verbatim}
(or (= (select m i j) (- 0 1)) (= (chooseSplit i j i (- 0 1)) (select m i
 j)))
\end{verbatim}

\begin{lstlisting}[language=c, caption= {Procedure `matrix chain multipication' :
      returns the minimum number of multipications needed to multiply a sequence of matrices.}, label=lst:factorialRecent]
var p: [int] int;
var m: [int, int] int;
//invariant : \forall {i, j}. m[i, j] = -1 OR m[i, j] = foo(i, j, i, infinity)
procedure {:entrypoint} mcm(i: int, j: int) returns (r: int) modifies m;{
        var k, q : int;
        var a, b :int;
        if(i == j) {
                m[i, j] := 0;
                r := 0;
        } else {
                if( m[i, j] > 0) {
                        r := m[i, j];
                } else {
                        k := i;
                        call r := chooseSplit(i, j, k, m[i, j]);
                        m[i, j] := r;
                }
        }
}

procedure chooseSplit(i: int, j: int, k:int, min :int) returns (r: int) modifies m;{
        var a, b, q : int;
        var min1 :int;
        if(k >= j) {
                r:= min;
        } else {        
                call a := mcm(i, k);
                call b := mcm(k+1, j);
                q := a + b + p[i-1] * p[k] * p[j];
                if( q < min) {
                  min1 := q;
                } else {
                  min1 := min;
                }
                call r := chooseSplit(i, j, k + 1, min1);
        }       
}
\end{lstlisting}
