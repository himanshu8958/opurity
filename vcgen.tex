\newcommand{\existformula}{\psi^e}
\newcommand{\EA}{\textsc{ea}}
\newcommand{\IW}{\textsc{iw}}

\newcommand{\initformula}{\logicalformula{init}}

\section{Checking Purity Using a Theorem Prover}

In this section, we show how, given a procedure $\proc$ and a candidate invariant $\inv$, we can use a theorem prover
to check whether a procedure $\proc$ is observationally pure with a consistent invariant $\inv$.



\subsection{Verification Condition Generation}

We describe an adaptation of standard verification-condition generation techniques that we use as our first step.
Given a procedure $\procP$, a candidate invariant $\inv$, our goal is to compute a
% the function $\mainvc{\procP}{\inv}$ returns a
pair $(\post,\vc)$ where $\post$ is a postcondition describing the state that exists after an execution of
$\procP$ starting from a state that satisfies $\inv$, and $\vc$ is a verification-condition that must hold true
for the execution to satisfy its invariants and assertions.

We first transform the procedure body as below to create an internal representation that is input to the
postcondition and verification condition generator. In the internal representation, we allow the following
extra forms of statements (with their usual meaning): \code{havoc(x)}, \code{assume e}, and  \code{assert e}.
\begin{enumerate}
\item For any assignment statement ``\code{x := e}'' where \code{e} contains \code{x}, we introduce a new temporary
variable \code{t} and replace the assignment statement with ``\code{t := e; x := t}''.
\item For every procedure invocation ``\code{x := p(y)}'', we first ensure that \code{y} is a local variable (by introducing
a temporary if needed). We then replace the statement by the code fragment
``\code{assert $\inv$; havoc(g1); ... havoc(gN); assume $\inv \wedge$ x = p(y)}'',
where \code{g1} to \code{gN} are the global variables.
\item We replace the ``\code{return x}'' statement by ``\code{assert $\inv$}''.
\end{enumerate}
Let $\tbody(\proc)$ denote the transformed body of procedure $\proc$ obtained as above.

%We use an auxiliary function $\auxvcfn$ which is similar to $\mainvcfn$, but accepts a statement $\stmtS$ as
%parameter instead of a procedure, and it has an extra parameter $\pre$ that is a precondition describing
%the state before the execution of the statement.
% Fig.~\ref{fig:vcgen} contains a definition of $\mainvc{\procP}{\inv}$  and  $\auxvc{\stmtS}{\inv}{\pre}$.
% contains a definition of the functions to compute the postcondition and verification condition.

\begin{figure}
\[
\begin{array}{ll}
\postfn(\pre, \code{x := e}) &= (\exists \code{x}. \pre) \wedge (\code{x = e}) (\text{if } \code{x} \not\in \text{vars}(\code{e})) \\
\postfn(\pre, \code{havoc(x)}) &= \exists \code{x}. \pre \\
\postfn(\pre, \code{assume e}) &= \pre \wedge \code{e} \\
\postfn(\pre, \code{assert e}) &= \pre \\
\postfn(\pre, \stmtSA ; \stmtSB) &= \postfn( \postfn(\pre, \stmtSA), \stmtSB) \\
\multicolumn{2}{l}{\postfn(\pre, \code{if \expr{} then \stmtSA{} else \stmtSB{}}) = \postfn(\pre \wedge \expr, \stmtSA) \vee \postfn(\pre \wedge \neg \expr, \stmtSB)} \\
\\
\vcfn(\pre, \code{assert e}) &= (\pre \Rightarrow e) \\
\vcfn(\pre, \stmtSA ; \stmtSB) &= \vcfn(\pre, \stmtSA) \wedge \vcfn( \postfn(\pre, \stmtSA), \stmtSB) \\
\multicolumn{2}{l}{
\vcfn(\pre, \code{if \expr{} then \stmtSA{} else \stmtSB{}}) = \vcfn(\pre \wedge \expr, \stmtSA) \wedge \vcfn(\pre \wedge \neg \expr, \stmtSB)
} \\
\vcfn(\pre, \stmt) &= \text{true} (\text{for all other \stmt}) \\
\\
\mainvc{\procP}{\inv} &= (\postfn(\inv, \tbody(\proc)), \vcfn(\inv, \tbody(\proc)) \wedge (\initstatefn(\proc) \Rightarrow \inv))
\end{array}
\]
\caption{Generation of verification-condition and postcondition.}
\label{fig:vcgen}
\end{figure}

We then compute postconditions as formally described in Fig.~\ref{fig:vcgen}.
This lets us compute for each program point $\ell$ in the procedure,
a condition $\varphi_{\ell}$ that describes what we expect to hold true when execution reaches $\ell$ if we start
executing the procedure in a state satisfying $\inv$ and if every recursive invocation of the procedure also
terminates in a state satisfying $\inv$. We compute this using the standard rules for the postcondition of a statement.
%A recursive call \code{x = p(y)}  is modelled by the \emph{assumed} specification for the procedure, namely that
%the global variables may be modified in any way, but the state at the return site will satisfy $\inv$
%and the returned value will equal $p(y)$. (Note that in a logical formula the symbol $p$ is used to represent the
%mathematical function realized by procedure $p$, assuming $p$ to be pure.)
%
For an assignment statement ``\code{x := e}'', we use existential quantification over \code{x} to represent the value
of \code{x} prior to the execution of the statement. If we rename these existentially quantified variables with unique new
names, we can lift all the existential quantifiers to the outermost level. When transformed thus, the condition $\varphi_{\ell}$
takes the form $\exists x_1 \cdots x_n. \varphi$, where $\varphi$ is quantifier-free and $x_1, \cdots, x_n$ denote
intermediate values of variables along the execution path from procedure-entry to program point $\ell$.

We compute a verification condition $\vc$ that represents the conditions we must check to ensure that
an execution through the procedure satisfies its obligations: namely, that the invariant holds true at every call-site
and at procedure-exit. Let $\ell$ denote a call-site or the procedure-exit. We need to check that $\varphi_{\ell} \Rightarrow \inv$
holds. Thus, the generation verification condition essentially consists of the conjunction of this check over all call-sites
and procedure-exit.

Finally, the function $\mainvcfn$ computes the postcondition and verification condition for the entire procedure as shown
in Fig.~\ref{fig:vcgen}. Note that this adds the check that the initial state too must satisfy $\inv$ as the basis condition for
induction. The initial state is encoded as a logical formula consisting of a conjunct ``\code{g=c}'' for every global \code{c}
initialized to a value \code{c}.
% (\initformula \Rightarrow \inv 

\input{vcgen-eg}

\subsection{Existential Approach}

Let $\proc$ be a procedure with input parameter $n$ and return variable $r$.
Let $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\existformula$ denote the formula $\vc \wedge (\post \Rightarrow (r = p(n)))$.
Let $\overline{x}$ denote the sequence of all free variables in $\existformula$ except for $p$.
We define $\EA(\proc,\inv)$ to be the formula $ \forall \overline{x}. \existformula$.

In this approach, we use a theorem prover to check whether $\EA(\proc,\inv)$ is satisfiable.
As shown by the following theorem, satisfiability of $\EA(\proc,\inv)$ establishes that $\proc$
satisfies $\pureinv$.

\begin{theorem}
\label{theorem:EA}
A procedure $\proc$ satisfies $\pureinv$ if
$\exists p. \EA(\proc,\inv)$ is a tautology
(which holds iff $\EA(\proc,\inv)$ is satisfiable).
\end{theorem}

\begin{proof}
Note that $p$ is the only free variable in $\EA(\proc,\inv)$. Assume that $[p \mapsto f]$ is a
satisfying assignment for $\EA(\proc,\inv)$.
We prove that for every trace $\pi$ the following hold:
(a) $\outputval{\pi} = f(\inputval{\pi})$ and
(b) If $(\initial{\pi},f)$ satisfies $\inv$, then $(\final{\pi},f)$ also satisfies $\inv$.

The proof is by contradiction. Let $\pi$ be the shortest trace that does not satisfy at least
one of the two conditions (a) and (b).

Let us first consider a trace $\pi$ without any sub-traces (\ie, without a procedure call).
Consider any transition $\sigma_i \sssemP \sigma_{i+1}$ in $\pi$
caused by an assignment statement $\stmt$. Our verification-condition generation produces
a precondition $\pre_{\stmt}$ and a postcondition $\post_{\stmt}$ for $\stmt$. Further, this generation
guarantees that if $(\sigma_i,f)$ satisfies $\pre_{\stmt}$, then $(\sigma_{i+1},f)$ satisfies $\post_{\stmt}$.
This lets us prove (via induction over $i$), that if $(\initial{\pi},f)$ satisfies $\inv$,
then $(\sigma_{i+1},f)$ satisfies $\post_{\stmt}$.

We now consider a trace $\pi$ that contains a sub-trace $\pi' = \sigma_i \cdots \sigma_j$ corresponding to a procedure call
statement $\stmt$. Our verification-condition generation produces a precondition $\pre_{\stmt}$,
a postcondition $\post_{\stmt}$  and a conjunct $\pre_{\stmt} \Rightarrow \inv$ in $\vc$ for $\stmt$.
We extend the induction over $i$ to handle recursive calls as below.
Our inductive hypothesis guarantees that $(\sigma_i,f)$ satisfies $\pre_{\stmt}$.
Further, we know that $[p \mapsto f]$ is a satisfying assignment for $\EA(\proc,\inv)$,
which includes the conjunct $\pre_{\stmt} \Rightarrow \inv$. Hence, it follows that  $(\sigma_i,f)$ satisfies $\inv$.
Since $\pi'$ is a shorter trace than $\pi$, we can assume that it satisfies conditions (a)
and (b). This is sufficient to guarantee that $(\sigma_j,f)$ satisfies $\post_{\stmt}$.

Thus, we can establish $(\final{\pi},f)$ satisfies $\post$ and $\inv$. Further, since 
$\EA(\proc,\inv)$ includes the conjunct $\post \Rightarrow (r = p(n))$, it follows that
$\outputval{\pi} = f(\inputval{\pi})$.
\end{proof}

\subsection{Impurity Witness Approach}

The existential approach presented in the previous section has a drawback. Checking satisfiability of $\EA(\proc,\inv)$
is hard because it contains universal quantifiers and existing theorem provers do not work well enough for this
approach. We now present an approximation of the existential approach that is easier to use with existing theorem
provers. This new approach, which we will refer to as the impurity witness approach, reduces the problem to
that of checking whether a quantifier-free formula is unsatisfiable, which is better suited to the capabilities of
state-of-the-art theorem provers. This approach focuses on finding a counterexample to show that the
procedure is impure or it violates the candidate invariant.

Let $\proc$ be a procedure with input parameter $n$ and return variable $r$.
Let $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\post_\alpha$ denote the formula obtained by replacing every free variable $x$ other than $p$ in $\post$
by a new free variable $x_\alpha$. Define $\post_\beta$ similarly.
Define $\IW(\proc, \inv)$ to be the formula $(\neg \vc) \vee (\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.

The impurity witness approach checks whether $\IW(\proc, \inv)$ is satisfiable. This can be done by separately checking
whether $\neg \vc$ is satisfiable and whether $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$
is satisfiable. As formally defined, $\vc$ and $\post$ contain embedded existential quantifications. As explained earlier,
these existential quantifiers can be moved to the outside after variable renaming and can be omitted for a satisfiability check.
(A formula of the form $\forall \overline{x}. \psi$ is satisfiable iff $\psi$ is satisfiable.)
As usual, these existential quantifiers refer to intermediate values of variables along an execution path.
Finding a satisfying assignment to these variables essentially identifies a possible execution path (that
satisfies some other property).

\begin{theorem}
A procedure $\proc$ satisfies  $\pureinv$ if $\IW(\proc, \inv)$ is unsatisfiable.
\end{theorem}

\begin{proof}
We prove the contrapositive.

We say that a pair of feasible executions $(\pi_1, \pi_2)$ is an impurity witness if there is a trace
$\pi_a$ in $\pi_1$ and a trace $\pi_b$ in $\pi_2$ such that $\pi_a$ and $\pi_b$ have the same input
value but different return values. Otherwise, we say that $(\pi_1, \pi_2)$ is pure. We extend
this notion and say that a single execution $\pi$ is pure if $(\pi,\pi)$ is pure.

We say that a function $f$ is \emph{compatible} with a set of executions $\Pi$ if for every trace
$\pi \in \Pi$, $\outputval{\pi} = f(\inputval{\pi})$.

We say that a pure feasible execution $\pi$ is a $\inv$-violation witness if there is some function $f$
that is compatible with $\{\pi\}$ such that $(\pi,f) \nvDash \inv$. Otherwise, we say that $\pi$ satisfies
the invariant. Note that this definition introduces a conservative approximation as we explain later.
% Otherwise, we say that $\pi$ is an invariant violation witness.

We will consider \emph{minimal} witnesses of the following form.
We say that an impurity witness $(\pi_1, \pi_2)$ is minimal if for every proper prefix $\pi_1'$ of
$\pi_1$ and every proper prefix $\pi_2'$ of $\pi_2$, the following hold:
(a) $(\pi_1',\pi_2)$ is pure,
(b) $(\pi_1,\pi_2')$ is pure,
(c) $\pi_1'$ satisfies the invariant, and
(d) $\pi_2'$ satisfies the invariant.

We say that an $\inv$-violation witness $\pi$ is minimal if no proper prefix $\pi'$ of
$\pi$ is a $\inv$-violation witness.

If $\proc$ does not satisfy $\pureinv$, then there exists a minimal impurity witness
or a minimal $\inv$-violation witness. Note that our definition of $\inv$-violation witness is
a conservative approximation and the converse of the preceding claim does not hold.
A  $\inv$-violation witness does not mean that $\proc$ does not satisfy $\pureinv$.

In the first case, $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$
must be satisfiable (as we show below). In the second case, $\neg \vc$ must be satisfiable (as we show below).
Thus,  $\IW(\proc, \inv)$  is satisfiable in either case. The theorem follows.

We establish the above result as below.
% using the following lemmas.
If we have a trace that satisfies the invariant and the set of its sub-traces are pure,
then the valuations assigned to variables by the trace satisfies $\post$.
Thus, if $(\pi_1,\pi_2)$ are a minimal impurity witness, let $\pi_a$ and $\pi_b$
be the two traces in $\pi_1$ and $\pi_2$ that are incompatible.
We can assign values to variables in $\post_\alpha$ from $\pi_a$, and
assign values to variables in $\post_\beta$ from $\pi_b$ to get a satisfying
assignment for $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.

If $\pi$ is a minimal $\inv$-violation witness, let $\pi'$ be the trace that contains the invariant violation.
Assigning values to variables as in $\pi'$ produces a satisfying assignment for
% $\neg (\post \Rightarrow \inv)$ and, hence, for
$\neg \vc$.
\end{proof}