\section{Checking Purity Using a Theorem Prover}

\subsection{Verification Condition Generation}

We describe an adaptation of standard verification-condition generation techniques that we use as our first step.
Given a procedure $\procP$, a candidate invariant $\inv$, the function $\mainvc{\procP}{\inv}$ returns a
pair $(\post,\vc)$ where $\post$ is a postcondition describing the state that exists after an execution of
$\procP$ starting from a state that satisfies $\inv$, and $\vc$ is a verification-condition that must hold true
for the execution to satisfy its invariants and assertions.

We use an auxiliary function $\auxvcfn$ which is similar to $\mainvcfn$, but accepts a statement $\stmtS$ as
parameter instead of a procedure, and it has an extra parameter $\pre$ that is a precondition describing
the state before the execution of the statement.
Fig.~\ref{fig:vcgen} contains a definition of $\mainvc{\procP}{\inv}$  and  $\auxvc{\stmtS}{\inv}{\pre}$.

\begin{figure}
\begin{mathpar}

\inferrule{
\stmt = \text{body}(\proc), \auxvc{\stmt}{\inv}{\inv} = (\post, \vc)
}{
\mainvc{\proc}{\inv} = (\post, \vc \wedge (\post \Rightarrow \inv))
}

\inferrule{
\auxvc{\stmtSA}{\inv}{\pre} = (\postA, \vcA) \\
\auxvc{\stmtSB}{\inv}{\postA} = (\postB, \vcB) 
}{
\auxvc{ \stmtSA ; \stmtSB }{\inv}{\pre} = (\postB, \vcA \wedge \vcB)
}

\inferrule{
\auxvc{\stmtSA}{\inv}{\pre \wedge \expr} = (\postA, \vcA) \\
\auxvc{\stmtSB}{\inv}{\pre \wedge \neg \expr} = (\postB, \vcB) 
}{
\auxvc{ \code{if } \; \expr \; \code{ then } \;  \stmtSA \;  \code{ else } \; \stmtSB }{\inv}{\pre} = (\postA \vee \postB, \vcA \wedge \vcB)
}

\inferrule{
\var \not\in vars(\expr)
}{
\auxvc{\var = \expr}{\inv}{\pre} = ((\exists \var. \pre) \wedge (\var = \expr), \code{true})
}

\inferrule{
\varY \neq \var \\ \varY \neq g
}{
\auxvc{\var = \proc(\varY)}{\inv}{\pre} = ((\exists g. \exists \var.\pre) \wedge \inv \wedge (\var = F(\varY)), \pre \Rightarrow \inv)
}

\end{mathpar}
\caption{Generation of verification-condition and postcondition.}
\label{fig:vcgen}
\end{figure}

\subsection{Our intermediate representation}
\label{sec:intermediate}
We transform the given procedure into the following representation
in-order to encode it in logic. For example procedure factorial
in Listing~\ref{lst:factorialTransformed}, is the transformed version
of procedure factorial in Listing~\ref{lst:factorialSimple}.

Our analysis expects the following :
\begin{enumerate}
\item Expressions do not have procedure call statements as
  sub-expressions.(omit? too much detail)
\item Procedure calls are approximated using function symbols. The
  statement `x = foo(y)' is replaced with `x = $\F$(y)'. Since
  procedure calls may modify global variables, we add the statement
  `havoc g' for each global variable `g' accessible from the
  procedure.
\item The input procedure has `m' procedure calls.
\item Next, the procedure must have extra variables to store the value
  of global variables at procedure boundaries. Before the
  $\mathit{i^{th}}$ procedure call, we add the statement `gbef$_i$ =
  g' and after it we add `gaft$_i$ = g'. Similarly, we add the
  statement `gout = g' after the assignment to the variable `\retVar'.
\item The procedure should be in static single assignment (SSA)
  form. The procedure should be converted to SSA after the above
  mentioned points have been satisfied.
\end{enumerate}

\begin{lstlisting}[language=c, caption= {Procedure factorial from
      Listing~\ref{lst:factorialSimple} converted to the form our
      approach expects. We refer to this procedure as `transformed
      factorial'.}, label=lst:factorialTransformed]
int g = -1;
int transformedFactorial( int n) { // redo
  if(n <= 1) {
    retVar = 1;
    gout = g;
  } else if(g == -1 && n == 19) {
    gbef1 = g;
    temp1 = F(18);  // temp1 = factorial(18)
    havoc(g1);
    gaft1 = g1;
    g2 = 19 * temp1;
    retVar = g2;
    gout = g2;
  } else if (g != -1 && n == 19) {
    retVar = g;
    gout = g;
  } else {
    gbef2 = g;
    temp2 = F( n - 1 );  //temp2 = factorial(n-1)
    havoc(g2);
    gaft2 = g3;
    retVar = n * temp2;
    gout = g3;
  }
}
\end{lstlisting}

%% In procedure `transformedFactorial'
%% Listing~\ref{lst:factorialTransformed}, in comparison to procedure
%% factorial in Listing~\ref{lst:factorialSimple}, the return statement
%% (line 4) is replaced by an assignment to variable `\retVar' (line
%% 4). After line 5 of `transformed factorial', an extra variable `gout'
%% is assigned the value of global variable `g' (value of `g' at end of
%% program).  Similarly, variable `gbef1' (line 7, `transformed
%% factorial') is added to capture the value of the global variable
%% before the procedure call (a program boundary), and variable `gaft1'
%% is inserted at line 11 to capture the value of `g' after the procedure
%% call. Also, havoc statements at line 8, 20 and 9, 21 over-approximate
%% the return from the procedure call statement and updates to the global
%% variable respectively. The procedure call statement is substituted
%% with function symbols in line 10 and 22, accounting the given
%% procedure as a function.

Now we compare `transformed factorial' and procedure factorial from
Listings~\ref{lst:factorialTransformed} and \ref{lst:factorialSimple}
respectively. The return statement (line 4) in procedure factorial
is replaced by assignment to variable `\retVar' (line 4). Also, we
have a added an assignment statement (line 5) in `transformed
factorial', that defines variable `gout' in-order to store the value
of variable `g' at the procedure boundary. Similarly, variable `gbef1'
(line 7) is added in `transformed factorial' to capture the value of
the global variable before the procedure call and assignment to
variable `gaft1' is inserted at line 10 to capture the value of `g'
after the procedure call. Also, havoc statements at lines 9 and 20
over-approximate any side effects to the global variables. And in
lines 8 and 19, the procedure call statements are substituted for
function symbols.


\subsection{Existential Approach}

Let $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\mu_e$ denote the formula $\vc \wedge (\post \Rightarrow (\retVar = \F(\n)))$.
Let $\overline{X}$ denote the sequence of all free variables in $\mu_e$ except for $\F$.
The procedure $\proc$ is observationally pure and satisfies invariant $\inv$ if
$\exists \F. \forall \overline{X}. \mu_e$ is a tautology (which holds iff
$\forall \overline{X}. \mu_e$ is satisfiable).

\subsection{Impurity Witness Approach}

Let $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\post_\alpha$ denote the formula obtained by replacing every free variable $x$ in $\post$
by a new free variable $x_\alpha$. Define $\post_\beta$ similarly.
Let $\mu_{iw}$ denote the formula $(\neg \vc) \vee (\post_\alpha \wedge \post_\beta \wedge (\n_\alpha = \n_\beta) \wedge (\retVar_\alpha \neq \retVar_\beta))$.
If $\mu_{iw}$ is UNSAT, then the given procedure is observationally pure and satisfies invariant $\inv$.