\newcommand{\existformula}{\psi^e}
\newcommand{\EA}{\textsc{ea}}
\newcommand{\IW}{\textsc{iw}}

\newcommand{\initformula}{\logicalformula{init}}

\section{Checking Purity Using a Theorem Prover}
\label{sec:vcgen}

In this section we provide two different approaches that, given a procedure
$\proc$ and a candidate invariant $\inv$, use a theorem prover to check
conservatively whether procedure $\proc$ satisfies $\pureinv$.



\subsection{Verification Condition Generation}

We first describe an adaptation of standard verification-condition generation
techniques that we use as a common first step in both our approaches.
Given a procedure $\procP$, a candidate invariant $\inv$, our goal is to compute a
% the function $\mainvc{\procP}{\inv}$ returns a
pair $(\post,\vc)$ where $\post$ is a postcondition describing the state that exists after an execution of
$\text{body}(\procP)$ starting from a state that satisfies $\inv$, and $\vc$ is a verification-condition that must hold true
for the execution to satisfy its invariants and assertions.

We first transform the procedure body as below to create an internal representation that is input to the
postcondition and verification condition generator. In the internal representation, we allow the following
extra forms of statements (with their usual meaning): \code{havoc(x)}, \code{assume e}, and  \code{assert e}.
\begin{enumerate}
\item For any assignment statement ``\code{x := e}'' where \code{e} contains \code{x}, we introduce a new temporary
variable \code{t} and replace the assignment statement with ``\code{t := e; x := t}''.
\item For every procedure invocation ``\code{x := $\procname$(y)}'', we first ensure that \code{y} is a local variable (by introducing
a temporary if needed). We then replace the statement by the code fragment
``\code{assert $\inv$; havoc(g1); ... havoc(gN); assume $\inv \wedge$ x = $\procname$(y)}'',
where \code{g1} to \code{gN} are the global variables.

Note that the
function call has been eliminated, and replaced with an ``assume''
expression that refers to the function symbol $\procname$. In other words,
there are no function calls in the transformed procedure.
\item We replace the ``\code{return x}'' statement by ``\code{assert $\inv$}''.
Note that we intentionally do \emph{not} assert that the return value equals $\procname(n)$.
\end{enumerate}
Let $\tbody(\proc, \inv)$ denote the transformed body of procedure $\proc$ obtained as above.

%We use an auxiliary function $\auxvcfn$ which is similar to $\mainvcfn$, but accepts a statement $\stmtS$ as
%parameter instead of a procedure, and it has an extra parameter $\pre$ that is a precondition describing
%the state before the execution of the statement.
% Fig.~\ref{fig:vcgen} contains a definition of $\mainvc{\procP}{\inv}$  and  $\auxvc{\stmtS}{\inv}{\pre}$.
% contains a definition of the functions to compute the postcondition and verification condition.

\begin{figure}
\[
\begin{array}{ll}
\postfn(\pre, \code{x := e}) &= (\exists \code{x}. \pre) \wedge (\code{x =
  e}) \ (\text{if } \code{x} \not\in \text{vars}(\code{e})) \\
\postfn(\pre, \code{havoc(x)}) &= \exists \code{x}. \pre \\
\postfn(\pre, \code{assume e}) &= \pre \wedge \code{e} \\
\postfn(\pre, \code{assert e}) &= \pre \\
\postfn(\pre, \stmtSA ; \stmtSB) &= \postfn( \postfn(\pre, \stmtSA), \stmtSB) \\
\multicolumn{2}{l}{\postfn(\pre, \code{if \expr{} then \stmtSA{} else \stmtSB{}}) = \postfn(\pre \wedge \expr, \stmtSA) \vee \postfn(\pre \wedge \neg \expr, \stmtSB)} \\
\\
\vcfn(\pre, \code{assert e}) &= (\pre \Rightarrow e) \\
\vcfn(\pre, \stmtSA ; \stmtSB) &= \vcfn(\pre, \stmtSA) \wedge \vcfn( \postfn(\pre, \stmtSA), \stmtSB) \\
\multicolumn{2}{l}{
\vcfn(\pre, \code{if \expr{} then \stmtSA{} else \stmtSB{}}) = \vcfn(\pre \wedge \expr, \stmtSA) \wedge \vcfn(\pre \wedge \neg \expr, \stmtSB)
} \\
\vcfn(\pre, \stmt) &= \text{true} (\text{for all other \stmt}) \\
\\
\mainvc{\procP}{\inv} = (\postfn(&\inv, \tbody(\proc,\inv)), \vcfn(\inv,
\tbody(\proc,\inv)) \wedge (\initstatefn(\proc) \Rightarrow \inv))
\end{array}
\]
\caption{Generation of verification-condition and postcondition.}
\label{fig:vcgen}
\end{figure}

We then compute postconditions as formally described in Fig.~\ref{fig:vcgen}.
This lets us compute for each program point $\ell$ in the procedure,
a condition $\varphi_{\ell}$ that describes what we expect to hold true when execution reaches $\ell$ if we start
executing the procedure in a state satisfying $\inv$ and if every recursive invocation of the procedure also
terminates in a state satisfying $\inv$. We compute this using the standard rules for the postcondition of a statement.
%A recursive call \code{x = p(y)}  is modelled by the \emph{assumed} specification for the procedure, namely that
%the global variables may be modified in any way, but the state at the return site will satisfy $\inv$
%and the returned value will equal $p(y)$. (Note that in a logical formula the symbol $p$ is used to represent the
%mathematical function realized by procedure $p$, assuming $p$ to be pure.)
%
For an assignment statement ``\code{x := e}'', we use existential quantification over \code{x} to represent the value
of \code{x} prior to the execution of the statement. If we rename these existentially quantified variables with unique new
names, we can lift all the existential quantifiers to the outermost level. When transformed thus, the condition $\varphi_{\ell}$
takes the form $\exists x_1 \cdots x_n. \varphi$, where $\varphi$ is quantifier-free and $x_1, \cdots, x_n$ denote
intermediate values of variables along the execution path from procedure-entry to program point $\ell$.

We compute a verification condition $\vc$ that represents the conditions we must check to ensure that
an execution through the procedure satisfies its obligations: namely, that the invariant holds true at every call-site
and at procedure-exit. Let $\ell$ denote a call-site or the procedure-exit. We need to check that $\varphi_{\ell} \Rightarrow \inv$
holds. Thus, the generated verification condition essentially consists of the conjunction of this check over all call-sites
and procedure-exit.

Finally, the function $\mainvcfn$ computes the postcondition and verification condition for the entire procedure as shown
in Fig.~\ref{fig:vcgen}. Note that this adds the check that the initial state too must satisfy $\inv$ as the basis condition for
induction. $\initstatefn(\proc)$ is basically the formula  ``\code{g1 = c1}
$\wedge \ldots$ \code{gN = cN}'' (see Section~\ref{sec:background}).
% (\initformula \Rightarrow \inv 

\input{vcgen-eg}

\subsection{Approach 1: Existential Approach}

Let $\proc$ be a procedure with input parameter $n$ and return variable $r$.
Let\\ $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\existformula$ denote the formula $\vc \wedge (\post \Rightarrow (r = p(n)))$.
Let $\overline{x}$ denote the sequence of all free variables in $\existformula$ except for $p$.
We define $\EA(\proc,\inv)$ to be the formula $ \forall \overline{x}. \existformula$.

In this approach, we use a theorem prover to check whether $\EA(\proc,\inv)$ is satisfiable.
As shown by the following theorem, satisfiability of $\EA(\proc,\inv)$ establishes that $\proc$
satisfies $\pureinv$.

\begin{theorem}
\label{theorem:EA}
A procedure $\proc$ satisfies $\pureinv$ if
$\exists p. \EA(\proc,\inv)$ is a tautology
(which holds iff $\EA(\proc,\inv)$ is satisfiable).
\end{theorem}

\begin{proof}

Note that $p$ is the only free variable in $\EA(\proc,\inv)$. Assume that $[p \mapsto f]$ is a
satisfying assignment
% for $\EA(\proc,\inv)$.
for  $ \forall \overline{x}. \existformula$.
We show that for every feasible execution $\pi$: (P1) $(\pi, f)
\satisfies \inv$, and (P2) for every trace $\pi_a$ inside $\pi$,
$\outputval{\pi_a} = f(\inputval{\pi_a})$. This implies that
$\proc$ satisfies $\pureinv$.

Assume for contradiction that there exists a feasible execution $\pi$ that does
not satisfy P1 or P2 above. One of the following two cases, namely, Case 1
or Case 2, must hold. 

Case 1: Some entry or exit state $\sigma_x$ in $\pi$ is such that: (a)
$(\sigma_x, f)$ does not satisfy $\inv$,  (b) every complete trace
$\pi_a$ within $\pi$ that ends before $\sigma_x$ agrees with $f$ (i.e.,
$\outputval{\pi_a} = f(\inputval{\pi_a})$, and (c) every entry/exit state
$\sigma_u$ in $\pi$ that comes before $\sigma_x$ is such that $(\sigma_u,
f) \models \inv$.

There are two further sub-cases to consider within Case 1.

Case 1(a): If $\sigma_x$ is an exit-state, then let $\pi'$ be the trace for
which $\sigma_x$ is the exit state. It can be shown that the sequence of
states visited by this trace, when substituted for $\overline{x}$, are a
witness that $[p \mapsto f]$ is not a satisfying assignment for  $\forall
\overline{x}. \existformula$. This is a contradiction of our original
assumption. 

Case 1(b): $\sigma_x$ is an entry-state. If $\sigma_x$ is the first
state of the execution $\pi$ (i.e., $\sigma_x$ is $\initstate$), then $[p
  \mapsto f]$ cannot satisfy the conjunct $(\initstatefn(\proc) \Rightarrow
\inv)$ that is present inside the formula $\forall
\overline{x}. \existformula$. This is a contradiction of our original
assumption. If $\sigma_x$ is not the entry-state of the whole execution
$\pi$, then it cannot be the entry-state of any outermost trace, because
then the immediately preceding exit-state, which would be identical to
$\sigma_x$, would have triggered Case 1(a) above. Therefore, $\sigma_x$
must be the entry-state of some inner trace $\pi''$. Let $|pi'$ be the trace that
contains $\pi''$. It be can be shown that the states of $\pi'$ from its entry-state
upto $\sigma_x$ are a witness that $[p \mapsto f]$ is not a satisfying
assignment for the conjunct $\vc$ within $\forall
\overline{x}. \existformula$. This is a contradiction of our original
assumption.

Case 2: If Case 1 does not hold,
then there must exist a trace $\pi'$ within $\pi$ such that
(a) $\pi'$ disagrees with $f$, (b) all entry and exit states $\sigma_y$ of
$\pi$ that come before $\pi'$ are such that $(\sigma_y, f) \models \inv$, (c)
if $\pi'$ has an inner trace then this inner trace agrees with $f$, and 
the entry state $\sigma_u$ and exit state
$\sigma_v$ of the inner trace are such that
$(\sigma_u, f) \models \inv$ and
 $(\sigma_v, f) \models \inv$. It
can be argued that the sequence of states within $\pi'$ are a witness that $[p
  \mapsto f]$ is not a satisfying assignment for the formula
$\forall \overline{x}. \existformula$, and this is a contradiction of our
original assumption.

(Please see~\cite{CheckingOP:arxiv} for a more complete proof.)

\end{proof}

\subsection{Approach 2: Impurity Witness Approach}

The existential approach presented in the previous section has a drawback. Checking satisfiability of $\EA(\proc,\inv)$
is hard because it contains universal quantifiers and existing theorem provers do not work well enough for this
approach. We now present an approximation of the existential approach that is easier to use with existing theorem
provers. This new approach, which we will refer to as the impurity witness approach, reduces the problem to
that of checking whether a quantifier-free formula is unsatisfiable, which is better suited to the capabilities of
state-of-the-art theorem provers. This approach focuses on finding a counterexample to show that the
procedure is impure or it violates the candidate invariant.

Let $\proc$ be a procedure with input parameter $n$ and return variable $r$.
Let $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\post_\alpha$ denote the formula obtained by replacing every free variable $x$ other than $p$ in $\post$
by a new free variable $x_\alpha$. Define $\post_\beta$ similarly.
Define $\IW(\proc, \inv)$ to be the formula $(\neg \vc) \vee (\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.

The impurity witness approach checks whether $\IW(\proc, \inv)$ is satisfiable. This can be done by separately checking
whether $\neg \vc$ is satisfiable and whether $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$
is satisfiable. As formally defined, $\vc$ and $\post$ contain embedded existential quantifications. As explained earlier,
these existential quantifiers can be moved to the outside after variable renaming and can be omitted for a satisfiability check.
(A formula of the form $\exists \overline{x}. \psi$ is satisfiable iff $\psi$ is satisfiable.)
As usual, these existential quantifiers refer to intermediate values of variables along an execution path.
Finding a satisfying assignment to these variables essentially identifies a possible execution path (that
satisfies some other property).

\begin{theorem}
A procedure $\proc$ satisfies  $\pureinv$ if $\IW(\proc, \inv)$ is unsatisfiable.
\end{theorem}

\begin{proof}
(Please see~\cite{CheckingOP:arxiv} for a more complete proof.)
% We prove the contrapositive.

We say that two traces disagree if they receive the same argument value but return different values.
We say that a pair of feasible executions $(\pi_1, \pi_2)$ is an \emph{impurity witness} if there is a trace
$\pi_a$ in $\pi_1$ and a trace $\pi_b$ in $\pi_2$ such that $\pi_a$ and $\pi_b$ disagree.
% Otherwise, we say that $(\pi_1, \pi_2)$ is pure.
% We extend this notion and say that a single execution $\pi$ is pure if $(\pi,\pi)$ is pure.

A trace is said to be compatible with a function $f$ (and vice versa) if the trace's input-output behavior matches that of the function.
An execution is said to be compatible with a function (and vice versa) if every trace in the execution is compatible with the function.
We say that a feasible execution $\pi$ \emph{strongly satisfies} $\inv$ if for every function $f$ that is compatible with $\pi$, $(\pi,f) \models \inv$.

We prove the theorem using the following lemmas:
if $\IW(\proc, \inv)$ is unsatisfiable, then lemmas~\ref{lemma:iw-strong-invariant} and~\ref{lemma:iw-impurity} imply
that the preconditions of lemma~\ref{lemma:iw-two-cases} hold and, hence, $\proc$ satisfies $\pureinv$.
\begin{enumerate}
\item \label{lemma:iw-two-cases}
If there exists no impurity witness, and every feasible execution strongly satisfies $\inv$, then $\proc$ satisfies $\pureinv$.

\item \label{lemma:iw-strong-invariant}
If a feasible execution $\pi$ that does not strongly satisfy $\inv$ exists, $\IW(\proc, \inv)$ is satisfiable.

\item \label{lemma:iw-impurity}
If an impurity witness exists, then $\IW(\proc, \inv)$ is satisfiable.
\end{enumerate}

% We say that a function $f$ is \emph{compatible} with a set of executions $\Pi$ if for every trace
% $\pi \in \Pi$, $\outputval{\pi} = f(\inputval{\pi})$.

% We say that a pure feasible execution $\pi$ is a $\inv$-violation witness if there is some function $f$
% that is compatible with $\{\pi\}$ such that $(\pi,f) \nvDash \inv$. Otherwise, we say that $\pi$ satisfies
% the invariant. Note that this definition introduces a cons ervative approximation as we explain later.

%If $\proc$ does not satisfy $\pureinv$, then there exists a minimal impurity witness
%or a minimal $\inv$-violation witness. Note that our definition of $\inv$-violation witness is
%a conservative approximation and the converse of the preceding claim does not hold.
%A  $\inv$-violation witness does not mean that $\proc$ does not satisfy $\pureinv$.

\ref{lemma:iw-two-cases} is straightforward.

For~\ref{lemma:iw-strong-invariant}, we use a ``minimal'' feasible execution $\pi$ that does not strongly satisfy $\inv$
to construct a satisfying assignment to $\neg \vc$.

For~\ref{lemma:iw-impurity}, we use a ``minimal'' impurity witness to construct a satisfying assignment to
$(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.

%
%We establish the above result as below.
%% using the following lemmas.
%If we have a trace that satisfies the invariant and the set of its sub-traces are pure,
%then the valuations assigned to variables by the trace satisfies $\post$.
%Thus, if $(\pi_1,\pi_2)$ are a minimal impurity witness, let $\pi_a$ and $\pi_b$
%be the two traces in $\pi_1$ and $\pi_2$ that are incompatible.
%We can assign values to variables in $\post_\alpha$ from $\pi_a$, and
%assign values to variables in $\post_\beta$ from $\pi_b$ to get a satisfying
%assignment for $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.
%
%If $\pi$ is a minimal $\inv$-violation witness, let $\pi'$ be the trace that contains the invariant violation.
%Assigning values to variables as in $\pi'$ produces a satisfying assignment for
%% $\neg (\post \Rightarrow \inv)$ and, hence, for
%$\neg \vc$.
\end{proof}
