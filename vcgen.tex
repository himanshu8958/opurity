\newcommand{\existformula}{\psi^e}
\newcommand{\EA}{\textsc{ea}}
\newcommand{\IW}{\textsc{iw}}

\newcommand{\initformula}{\logicalformula{init}}

\section{Checking Purity Using a Theorem Prover}

In this section, we show how, given a procedure $\proc$ and a candidate invariant $\inv$, we can use a theorem prover
to check whether a procedure $\proc$ is observationally pure with a consistent invariant $\inv$.



\subsection{Verification Condition Generation}

We describe an adaptation of standard verification-condition generation techniques that we use as our first step.
Given a procedure $\procP$, a candidate invariant $\inv$, our goal is to compute a
% the function $\mainvc{\procP}{\inv}$ returns a
pair $(\post,\vc)$ where $\post$ is a postcondition describing the state that exists after an execution of
$\procP$ starting from a state that satisfies $\inv$, and $\vc$ is a verification-condition that must hold true
for the execution to satisfy its invariants and assertions.

We first transform the procedure body as below:
\begin{enumerate}
\item For any assignment statement ``\code{x = e}'' where \code{e} contains \code{x}, we introduce a new temporary
variable \code{t} and replace the assignment statement with ``\code{t = e; x = t}''.
\item For every procedure invocation ``\code{x = p(y)}'', we first ensure that \code{y} is a local variable (by introducing
a temporary if needed). We then replace the statement by the code fragment
``\code{assert $\inv$; havoc(g1); ... havoc(gN); assume $\inv \wedge$ x = p(y)}'',
where \code{g1} to \code{gN} are the global variables.
\item We replace the ``\code{return x}'' statement by ``\code{assert $\inv$}''.
\end{enumerate}
Let $\tbody(\proc)$ denote the transformed body of procedure $\proc$ obtained as above.

%We use an auxiliary function $\auxvcfn$ which is similar to $\mainvcfn$, but accepts a statement $\stmtS$ as
%parameter instead of a procedure, and it has an extra parameter $\pre$ that is a precondition describing
%the state before the execution of the statement.
% Fig.~\ref{fig:vcgen} contains a definition of $\mainvc{\procP}{\inv}$  and  $\auxvc{\stmtS}{\inv}{\pre}$.
% contains a definition of the functions to compute the postcondition and verification condition.

\begin{figure}
\[
\begin{array}{lll}
\postfn(\pre, \code{x = e}) &= (\exists \code{x}. \pre) \wedge (\code{x = e}) & \text{if } \code{x} \not\in \text{vars}(\code{e}) \\
\postfn(\pre, \code{havoc(x)}) &= \exists \code{x}. \pre \\
\postfn(\pre, \code{assume e}) &= \pre \wedge \code{e} \\
\postfn(\pre, \code{assert e}) &= \pre \\
\postfn(\pre, \stmtSA ; \stmtSB) &= \postfn( \postfn(\pre, \stmtSA), \stmtSB) \\
\multicolumn{3}{l}{\postfn(\pre, \code{if \expr{} then \stmtSA{} else \stmtSB{}}) = \postfn(\pre \wedge \expr, \stmtSA) \vee \postfn(\pre \wedge \neg \expr, \stmtSB)} \\
\\
\vcfn(\pre, \code{assert e}) &= (\pre \Rightarrow e) \\
\vcfn(\pre, \stmtSA ; \stmtSB) &= \vcfn(\pre, \stmtSA) \wedge \vcfn( \postfn(\pre, \stmtSA), \stmtSB) \\
\multicolumn{3}{l}{
\vcfn(\pre, \code{if \expr{} then \stmtSA{} else \stmtSB{}}) = \vcfn(\pre \wedge \expr, \stmtSA) \wedge \vcfn(\pre \wedge \neg \expr, \stmtSB)
} \\
\vcfn(\pre, \stmt) &= \text{true} & \text{for all other \stmt} \\
\\
\mainvc{\procP}{\inv} &= (\postfn(\tbody(\proc)), \vcfn(\tbody(\proc)) \wedge (\initstatefn(\proc) \Rightarrow \inv))
\end{array}
\]
\caption{Generation of verification-condition and postcondition.}
\label{fig:vcgen}
\end{figure}

We then compute postconditions as formally described in Fig.~\ref{fig:vcgen}.
This lets us compute for each program point $\ell$ in the procedure,
a condition $\varphi_{\ell}$ that describes what we expect to hold true when execution reaches $\ell$ if we start
executing the procedure in a state satisfying $\inv$ and if every recursive invocation of the procedure also
terminates in a state satisfying $\inv$. We compute this using the standard rules for the postcondition of a statement.
%A recursive call \code{x = p(y)}  is modelled by the \emph{assumed} specification for the procedure, namely that
%the global variables may be modified in any way, but the state at the return site will satisfy $\inv$
%and the returned value will equal $p(y)$. (Note that in a logical formula the symbol $p$ is used to represent the
%mathematical function realized by procedure $p$, assuming $p$ to be pure.)
%
For an assignment statement ``\code{x = e}'', we use existential quantification over \code{x} to represent the value
of \code{x} prior to the execution of the statement. If we rename these existentially quantified variables with unique new
names, we can lift all the existential quantifiers to the outermost level. When transformed thus, the condition $\varphi_{\ell}$
takes the form $\exists x_1 \cdots x_n. \varphi$, where $\varphi$ is quantifier-free and $x_1, \cdots, x_n$ denote
intermediate values of variables along the execution path from procedure-entry to program point $\ell$.

We compute a verification condition $\vc$ that represents the conditions we must check to ensure that
an execution through the procedure satisfies its obligations: namely, that the invariant holds true at every call-site
and at procedure-exit. Let $\ell$ denote a call-site or the procedure-exit. We need to check that $\varphi_{\ell} \Rightarrow \inv$
holds. Thus, the generation verification condition essentially consists of the conjunction of this check over all call-sites
and procedure-exit.

Finally, the function $\mainvcfn$ computes the postcondition and verification condition for the entire procedure as shown
in Fig.~\ref{fig:vcgen}. Note that this adds the check that the initial state too must satisfy $\inv$ as the basis condition for
induction. The initial state is encoded as a logical formula consisting of a conjunct ``\code{g=c}'' for every global \code{c}
initialized to a value \code{c}.
% (\initformula \Rightarrow \inv 

\input{vcgen-eg}

\subsection{Existential Approach}

Let $\proc$ be a procedure with input parameter $n$ and return variable $r$.
Let $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\existformula$ denote the formula $\vc \wedge (\post \Rightarrow (r = p(n)))$.
Let $\overline{x}$ denote the sequence of all free variables in $\existformula$ except for $p$.
We define $\EA(\proc,\inv)$ to be the formula $ \forall \overline{x}. \existformula$.

In this approach, we use a theorem prover to check whether $\EA(\proc,\inv)$ is satisfiable.
As shown by the following theorem, satisfiability of $\EA(\proc,\inv)$ establishes that $\proc$
satisfies $\pureinv$.

\begin{theorem}
\label{theorem:EA}
A procedure $\proc$ satisfies $\pureinv$ if
$\exists p. \EA(\proc,\inv)$ is a tautology
(which holds iff $\EA(\proc,\inv)$ is satisfiable).
\end{theorem}

\begin{proof}
Note that $p$ is the only free variable in $\EA(\proc,\inv)$. Assume that $[p \mapsto f]$ is a
satisfying assignment for $\EA(\proc,\inv)$.
We prove that for every trace $\pi$ the following hold:
(a) $\outputval{\pi} = f(\inputval{\pi})$ and
(b) If $(\initial{\pi},f)$ satisfies $\inv$, then $(\final{\pi},f)$ also satisfies $\inv$.

The proof is by contradiction. Let $\pi$ be the shortest trace that does not satisfy at least
one of the two conditions (a) and (b).

Let us first consider a trace $\pi$ without any sub-traces (\ie, without a procedure call).
Consider any transition $\sigma_i \sssemP \sigma_{i+1}$ in $\pi$
caused by an assignment statement $\stmt$. Our verification-condition generation produces
a precondition $\pre_{\stmt}$ and a postcondition $\post_{\stmt}$ for $\stmt$. Further, this generation
guarantees that if $(\sigma_i,f)$ satisfies $\pre_{\stmt}$, then $(\sigma_{i+1},f)$ satisfies $\post_{\stmt}$.
This lets us prove (via induction over $i$), that if $(\initial{\pi},f)$ satisfies $\inv$,
then $(\sigma_{i+1},f)$ satisfies $\post_{\stmt}$.

We now consider a trace $\pi$ that contains a sub-trace $\pi' = \sigma_i \cdots \sigma_j$ corresponding to a procedure call
statement $\stmt$. Our verification-condition generation produces a precondition $\pre_{\stmt}$,
a postcondition $\post_{\stmt}$  and a conjunct $\pre_{\stmt} \Rightarrow \inv$ in $\vc$ for $\stmt$.
We extend the induction over $i$ to handle recursive calls as below.
Our inductive hypothesis guarantees that $(\sigma_i,f)$ satisfies $\pre_{\stmt}$.
Further, we know that $[p \mapsto f]$ is a satisfying assignment for $\EA(\proc,\inv)$,
which includes the conjunct $\pre_{\stmt} \Rightarrow \inv$. Hence, it follows that  $(\sigma_i,f)$ satisfies $\inv$.
Since $\pi'$ is a shorter trace than $\pi$, we can assume that it satisfies conditions (a)
and (b). This is sufficient to guarantee that $(\sigma_j,f)$ satisfies $\post_{\stmt}$.

Thus, we can establish $(\final{\pi},f)$ satisfies $\post$ and $\inv$. Further, since 
$\EA(\proc,\inv)$ includes the conjunct $\post \Rightarrow (r = p(n))$, it follows that
$\outputval{\pi} = f(\inputval{\pi})$.
\end{proof}

\subsection{Impurity Witness Approach}

The existential approach presented in the previous section has a drawback. Checking satisfiability of $\EA(\proc,\inv)$
is hard because it contains universal quantifiers and existing theorem provers do not work well enough for this
approach. We now present an approximation of the existential approach that is easier to use with existing theorem
provers. This new approach, which we will refer to as the impurity witness approach, reduces the problem to
that of checking whether a quantifier-free formula is unsatisfiable, which is better suited to the capabilities of
state-of-the-art theorem provers. This approach focuses on finding a counterexample to show that the
procedure is impure or it violates the candidate invariant.

Let $\proc$ be a procedure with input parameter $n$ and return variable $r$.
Let $\mainvc{\proc}{\inv}$ = $(\post,\vc)$.
Let $\post_\alpha$ denote the formula obtained by replacing every free variable $x$ other than $p$ in $\post$
by a new free variable $x_\alpha$. Define $\post_\beta$ similarly.
Define $\IW(\proc, \inv)$ to be the formula $(\neg \vc) \vee (\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.

\begin{theorem}
A procedure $\proc$ satisfies  $\pureinv$ if $\IW(\proc, \inv)$ is unsatisfiable.
\end{theorem}

\begin{proof}
We prove the contrapositive.

We say that a pair of feasible executions $(\pi_1, \pi_2)$ is an impurity witness if there is a trace
$\pi_a$ in $\pi_1$ and a trace $\pi_b$ in $\pi_2$ such that $\pi_a$ and $\pi_b$ have the same input
value but different return values. Otherwise, we say that $(\pi_1, \pi_2)$ is pure. We extend
this notion and say that a single execution $\pi$ is pure if $(\pi,\pi)$ is pure.

We say that a feasible execution $\pi$ satisfies the invariant if there exists a function $f$ such that
$(\pi,f) \models \inv$. Otherwise, we say that $\pi$ is an invariant violation witness.

We will consider \emph{minimal} witnesses of the following form.
We say that an impurity witness $(\pi_1, \pi_2)$ is minimal if for every proper prefix $\pi_1'$ of
$\pi_1$ and every proper prefix $\pi_2'$ of $\pi_2$, the following hold:
(a) $(\pi_1',\pi_2)$ is pure,
(b) $(\pi_1,\pi_2')$ is pure,
(c) $\pi_1'$ satisfies the invariant, and
(d) $\pi_2'$ satisfies the invariant.

We say that an invariant violation witness $\pi$ is minimal if every proper prefix $\pi'$ of
$\pi$ is both pure and satisfies the invariant.

If $\proc$ is not pure or fails to satisfy invariant $\inv$, then there exists a minimal impurity witness
or a minimal invariant violation witness. In the first case, $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$
must be satisfiable (as we show below). In the second case, $\neg \vc$ must be satisfiable (as we show below).
Thus,  $\IW(\proc, \inv)$  is satisfiable in either case. The theorem follows.

We establish the above result using the following lemmas.
If we have a trace that satisfies the invariant and the set of its sub-traces are pure,
then the valuations assigned to variables by the trace satisfies $\post$.
Thus, if $(\pi_1,\pi_2)$ are a minimal impurity witness, let $\pi_a$ and $\pi_b$
be the two traces in $\pi_1$ and $\pi_2$ that are incompatible.
We can assign values to variables in $\post_\alpha$ from $\pi_a$, and
assign values to variables in $\post_\beta$ from $\pi_b$ to get a satisfying
assignment for $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.

If $\pi$ is a minimal invariant violation witness, let $\pi'$ be the trace that contains the invariant violation.
Assigning values to variables as in $\pi'$ produces a satisfying assignment for$\neg (\post \Rightarrow \inv)$
and, hence, for $\neg \vc$.

%We say that two traces are incompatible if they have the same input values but different return values.
%We say that two executions are incompatible if they contain two incompatible traces.
%Let $\pi_1$ and $\pi_2$ be two incompatible histories.
%
%Further, assume that every proper prefix of
%$\pi_1$ is compatible with $\pi_2$ and, similarly, every proper prefix of $\pi_2$ is compatible with $\pi_1$.
%
%We can find a function $f$ that is consistent with every other trace in $\pi_1$ and $\pi_2$.
%Further, we assume that 


%Let  $\vartheta$ denote the formula  $\exists p \forall \overline{x} (\vc \wedge (\post \Rightarrow (r = p(n))$
%used in the existential approach.
%Consider the formula $\vartheta'$ = $(\forall p \forall \overline{x} \vc) \wedge (\exists p \forall \overline{x} (\post \Rightarrow (r = p(n))))$.
%It can be verified that $\vartheta'$ is a stronger condition than $\vartheta$.
%Thus, if $\vartheta'$ can be verified to be a tautology, then it follows that $\vartheta$ is also a tautology,
%and it follows from Theorem~\ref{theorem:EA} that $\proc$ is observationally pure and satisfies invariant $\inv$.
%
%The impurity witness approach essentially checks the stronger formula $\vartheta'$. Since it is a conjunction,
%we can check each conjunct separately.
%
%We can check if $(\forall p \forall \overline{x} \vc)$ holds by checking
%if $\neg \vc$ is not satisfiable.
%
%Now consider the second condition $\exists p \forall \overline{x} \post \Rightarrow (r = p(n))$.
%We now show that if $(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$
%is unsatisfiable, then the second condition must hold true. 
%Assume that $\exists p \forall \overline{x} \post \Rightarrow (r = p(n))$ does not hold. Consider any function $p$.
%Since $\forall \overline{x} \post \Rightarrow (r = p(n))$ does not hold (for this $p$), consider the set $C$ of all
%valuations to $\overline{x}$ such that $\post$ holds. Note that every every element of $C$ assigns a value to every
%free variable, including $r$ and $n$. Suppose we have two elements $\alpha'$ and $\beta'$ in $C$ that agree on the
%value of $n$ but have different values for $r$, then these give us a satisfying assignment to
%$(\post_\alpha \wedge \post_\beta \wedge (n_\alpha = n_\beta) \wedge (r_\alpha \neq r_\beta))$.
%If not two such elements exist, ...
\end{proof}