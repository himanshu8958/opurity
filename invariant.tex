\section{Generating the invariant}
\label{sec:invariant}

We now describe a simple but reasonably effective semi-algorithm for
generating a candidate invariant automatically from the given
procedure. Our approach of Section~\ref{sec:vcgen} can be used with a manually
provided invariant or the candidate invariant generated by this
semi-algorithm (whenever it terminates).

The invariant-generation approach is iterative and computes a sequence of progressively weaker
candidate invariants $I_0, I_1, \cdots$ and terminates if and when $I_m \equiv I_{m+1}$, at
which point $I_m$ is returned as the candidate invariant.
%
The initial candidate invariant $I_0$ captures the initial values of the global variable.
In  iteration $k$, we apply a procedure similar to the one described in Section~\ref{sec:vcgen} and
compute the strongest conditions that hold true at every program point if the execution of the
procedure starts in a state satisfying $I_{k-1}$ and if every recursive invocation terminates in a
state satisfying $I_{k-1}$. We then take the disjunction of the conditions computed at the points before the
recursive call-sites and at the end of the procedure, and existentially quantify all local variables.
We refer to the resulting formula as $\nextfn(I_{k-1}, \tbody(\proc,I_{k-1}))$.
We take the disjunction of this formula with $I_{k-1}$ and simplify it to get $I_k$.

%$\postfn(I_{k-1}, \proc)$ is first computed. Then, the
%pre-conditions that are computed by $\postfn$ at the points before the
%recursive call-sites and at the end of the procedure are disjuncted with
%$I_{k-1}$ to yield $I_k$; also, outermost level universal quantifiers are
%introduced in $I_k$ for all variables other than the global variables and
%the procedure symbol $\procname$. 
%
%This is continued until two consecutive
%iterations $m$ and $m+1$ are encountered such that $I_m \equiv I_{m+1}$, at
%which point $I_m$ is returned as the candidate invariant.

In the following formalization of this semi-algorithm, we exploit the fact that the \code{assert}
statements are added precisely at every recursive callsite and end of procedure and
these are the places where we take the conditions to be disjuncted.
\begin{figure}
\[
\begin{array}{ll}
\multicolumn{2}{l}{I_0 = \initstatefn(\proc)} \\
\multicolumn{2}{l}{I_{k} = \simplifyfn(I_{k-1} \vee \nextfn(I_{k-1}, \tbody(\proc,I_{k-1})))} \\
\\
\nextfn(\pre, \code{assert e}) &= \exists \ell_1 \cdots \ell_m \pre (\text{where $\ell_1, \cdots, \ell_m$ are local variables in $\pre$})\\
\nextfn(\pre, \stmtSA ; \stmtSB) &= \nextfn(\pre, \stmtSA) \vee \nextfn( \postfn(\pre, \stmtSA), \stmtSB) \\
\multicolumn{2}{l}{
\nextfn(\pre, \code{if \expr{} then \stmtSA{} else \stmtSB{}}) = \nextfn(\pre \wedge \expr, \stmtSA) \vee \nextfn(\pre \wedge \neg \expr, \stmtSB)
} \\
\nextfn(\pre, \stmt) &= \text{false} (\text{for all other \stmt})
\end{array}
\]
\caption{Iterative computation of invariant.}
\label{fig:invgen}
\end{figure}

In our running example, $I_0$  is`g = -1 $\wedge$ lastN = 0'.
Applying $\nextfn$ to $I_0$
% $\postfn(I_0, \mathrm{factCache})$
yields $I_0$ itself as the pre-condition at the
point just before the recursive call-site, and `(g = -1 $\wedge$ lastN = 0) $\vee$ g = lastN *
$\procname$(lastN-1)' (after certain simplifications) as the pre-condition
at the end of the
procedure. Therefore, $I_1$ is `(g = -1 $\wedge$ lastN = 0) $\vee$ g = lastN *
$\procname$(lastN-1)'. When we apply $\nextfn$ to $I_1$,
% $\postfn(I_1, \proc)$,
the computed pre-conditions are $I_1$ itself at both the program points
mentioned above. Therefore, the approach terminates with $I_1$ as the
candidate invariant.

% Note, this approach can go into non-termination in
% some cases, e.g., in the presence of statements such as `g = g + 1', where
% g is the private global variable of the procedure.
