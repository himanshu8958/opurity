\section{Generating the invariant}
\label{sec:invariant}

We now describe a simple but reasonably effective semi-algorithm for
generating a candidate invariant automatically from the given
procedure. Our approach of Section~\ref{sec:vcgen} can work with a manually
provided invariant, or from the candidate invariant generated by this
semi-algorithm whenever it terminates. The invariant-generation
approach is iterative, and
grows the candidate invariant in each iteration. The initial candidate
invariant $I_0$ just captures the initial values of the global variable. In
each iteration $k$, $\postfn(I_{k-1}, \proc)$ is first computed. Then, the
pre-conditions that are computed by $\postfn$ at the points before the
recursive call-sites and at the end of the procedure are disjuncted with
$I_{k-1}$ to yield $I_k$; also, outermost level universal quantifiers are
introduced in $I_k$ for all variables other than the global variables and
the procedure symbol $\procname$.  This is continued until two consecutive
iterations $m$ and $m+1$ are encountered such that $I_m \equiv I_{m+1}$, at
which point $I_m$ is returned as the candidate invariant.

In our running example, $I_0$ would be `g = -1'. $\postfn(I_0,
\mathrm{factCache})$ would compute $I_0$ itself as the pre-condition at the
point just before the recursive call-site, and `g = -1 $\vee$ g = lastN *
$\procname$(lastN-1)' (after certain simplifications) as the pre-condition
at the end of the
procedure. Therefore, $I_1$ would be `g = -1 $\vee$ g = lastN *
$\procname$(lastN-1)'. When we compute $\postfn(I_1, \proc)$, the
pre-conditions happen to be $I_1$ itself at both the program points
mentioned above. Therefore, the approach terminates with $I_1$ as the
candidate invariant.

% Note, this approach can go into non-termination in
% some cases, e.g., in the presence of statements such as `g = g + 1', where
% g is the private global variable of the procedure.
