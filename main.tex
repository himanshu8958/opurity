% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
%% himanshu
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{listings}
\newcommand{\foo}{\textit{foo}}
\newcommand{\trace}{\pi}
\newcommand{\inv}{\mathit{inv}}
\newcommand{\history}{\Pi}
\newcommand{\pathCondition}{\mathit{T_{\foo}}}
\newcommand{\OPCheckE}{\mathit{OPCheck \mhyphen existential}}
\newcommand{\OPCheckA}{\mathit{OPCheck \mhyphen pairwise}}
\mathchardef \mhyphen="2D
\newcommand{\mi}[1]{\mathit{#1}}
\newcommand{\retVar}{\textit{retVar}}
\newcommand{\F}{\mathit{F}}
\newcommand{\n}{\textit{n}}
\newcommand{\gstate}{\gamma}
\newcommand{\g}{\mathit{g}}
\newcommand{\gout}{\mathit{gout}}
\newcommand{\gbef}{\mathit{gbef}}
\newcommand{\gaft}{\mathit{gaft}}
\newcommand{\satisfies}{\vdash}


\lstdefinestyle{mystyle}{
  %% basicstyle=\footnotesize, 
  %% breakatwhitespace=false,         
  %% breaklines=true,                 
  %% captionpos=b,                    
  %% keepspaces=true,         
  %% numbers=left,                    
  %% numbersep=5pt,                  
  %% showspaces=false,                
  %% showstringspaces=false,
  %% showtabs=false,
  morekeywords={if, for, else,
  procedure,modifies, var, returns, int, call, assume},
  %% tabsize=2
}
\lstset{
  %% basicstyle=\itshape,
  style = mystyle,
  xleftmargin=3em,
  %% literate={\alt}{;}{1}
  %% basicstyle=\footnotesize,
  numberstyle=\tiny,
  breaklines=true,
  escapeinside={\%*}{*)}
}

%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
%% \chapter*{Preface}
%% %
%% This textbook is intended for use by students of physics, physical
%% chemistry, and theoretical chemistry. The reader is presumed to have a
%% basic knowledge of atomic and quantum physics at the level provided, for
%% example, by the first few chapters in our book {\it The Physics of Atoms
%% and Quanta}. The student of physics will find here material which should
%% be included in the basic education of every physicist. This book should
%% furthermore allow students to acquire an appreciation of the breadth and
%% variety within the field of molecular physics and its future as a
%% fascinating area of research.

%% For the student of chemistry, the concepts introduced in this book will
%% provide a theoretical framework for that entire field of study. With the
%% help of these concepts, it is at least in principle possible to reduce
%% the enormous body of empirical chemical knowledge to a few basic
%% principles: those of quantum mechanics. In addition, modern physical
%% methods whose fundamentals are introduced here are becoming increasingly
%% important in chemistry and now represent indispensable tools for the
%% chemist. As examples, we might mention the structural analysis of
%% complex organic compounds, spectroscopic investigation of very rapid
%% reaction processes or, as a practical application, the remote detection
%% of pollutants in the air.

%% \vspace{1cm}
%% \begin{flushright}\noindent
%% April 1995\hfill Walter Olthoff\\
%% Program Chair\\
%% ECOOP'95
%% \end{flushright}
%% %
%% \chapter*{Organization}
%% ECOOP'95 is organized by the department of Computer Science, Univeristy
%% of \AA rhus and AITO (association Internationa pour les Technologie
%% Object) in cooperation with ACM/SIGPLAN.
%% %
%% \section*{Executive Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \section*{Program Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \begin{multicols}{3}[\section*{Referees}]
%% V.~Andreev\\
%% B\"arwolff\\
%% E.~Barrelet\\
%% H.P.~Beck\\
%% G.~Bernardi\\
%% E.~Binder\\
%% P.C.~Bosetti\\
%% Braunschweig\\
%% F.W.~B\"usser\\
%% T.~Carli\\
%% A.B.~Clegg\\
%% G.~Cozzika\\
%% S.~Dagoret\\
%% Del~Buono\\
%% P.~Dingus\\
%% H.~Duhm\\
%% J.~Ebert\\
%% S.~Eichenberger\\
%% R.J.~Ellison\\
%% Feltesse\\
%% W.~Flauger\\
%% A.~Fomenko\\
%% G.~Franke\\
%% J.~Garvey\\
%% M.~Gennis\\
%% L.~Goerlich\\
%% P.~Goritchev\\
%% H.~Greif\\
%% E.M.~Hanlon\\
%% R.~Haydar\\
%% R.C.W.~Henderso\\
%% P.~Hill\\
%% H.~Hufnagel\\
%% A.~Jacholkowska\\
%% Johannsen\\
%% S.~Kasarian\\
%% I.R.~Kenyon\\
%% C.~Kleinwort\\
%% T.~K\"ohler\\
%% S.D.~Kolya\\
%% P.~Kostka\\
%% U.~Kr\"uger\\
%% J.~Kurzh\"ofer\\
%% M.P.J.~Landon\\
%% A.~Lebedev\\
%% Ch.~Ley\\
%% F.~Linsel\\
%% H.~Lohmand\\
%% Martin\\
%% S.~Masson\\
%% K.~Meier\\
%% C.A.~Meyer\\
%% S.~Mikocki\\
%% J.V.~Morris\\
%% B.~Naroska\\
%% Nguyen\\
%% U.~Obrock\\
%% G.D.~Patel\\
%% Ch.~Pichler\\
%% S.~Prell\\
%% F.~Raupach\\
%% V.~Riech\\
%% P.~Robmann\\
%% N.~Sahlmann\\
%% P.~Schleper\\
%% Sch\"oning\\
%% B.~Schwab\\
%% A.~Semenov\\
%% G.~Siegmon\\
%% J.R.~Smith\\
%% M.~Steenbock\\
%% U.~Straumann\\
%% C.~Thiebaux\\
%% P.~Van~Esch\\
%% from Yerevan Ph\\
%% L.R.~West\\
%% G.-G.~Winter\\
%% T.P.~Yiou\\
%% M.~Zimmer\end{multicols}
%% %
%% \section*{Sponsoring Institutions}
%% %
%% Bernauer-Budiman Inc., Reading, Mass.\\
%% The Hofmann-International Company, San Louis Obispo, Cal.\\
%% Kramer Industries, Heidelberg, Germany
%% %
%% \tableofcontents
%% %
\mainmatter              % start of the contributions
%
\title{Checking Observational Purity}
%
\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
%% \author{Ivar Ekeland\inst{1}\orcidID{0000-1111-2222-3333} \and
%% Roger~Temam\inst{2}\orcidID{1111-2222-3333-4444} \and
%% Jeffrey~Dean\orcidID{2222-3333-4444-5555} \and
%% David~Grove\orcidID{3333-4444-5555-6666} \and
%% Craig~Chambers\orcidID{4444-5555-6666-7777} \and
%% Kim~B.~Bruce\orcidID{5555-6666-7777-8888} \and
%% Elsa~Bertino\orcidID{6666-7777-8888-9999}}
%% %
%% \authorrunning{Ivar Ekeland et al.} % abbreviated author list (for running head)
%% %
%% %%%% list of authors for the TOC (use if author list has to be modified)
%% \tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%% Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%% %
%% \institute{Princeton University, Princeton NJ 08544, USA,\\
%% \email{I.Ekeland@princeton.edu},\\ WWW home page:
%% \texttt{http://users/\homedir iekeland/web/welcome.html}
%% \and
%% Universit\'{e} de Paris-Sud,
%% Laboratoire d'Analyse Num\'{e}rique, B\^{a}timent 425,\\
%% F-91405 Orsay Cedex, France}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The abstract should summarize the contents of the paper
using at least 70 and at most 150 words. It will be set in 9-point
font size and be inset 1.0 cm from the right and left margins.
There will be two blank lines before and after the Abstract. \dots
\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}

\section{Introduction}
Defining the correctness for a procedure is a time consuming task that
requires deep understanding of the expected functionality of the
procedure. In this paper, we talk about a general property that is the
necessary condition for the correctness of many procedures. If the
return value from a procedure is dependent only on the formal
arguments, the given procedure is \textit{Observationally
  pure(OP)}. Thus, OP procedures return independent of the value of
the global variables. For instance, dynamic programming algorithms
fall into this category. Checking whether a given procedure is OP, is
in general undecidable. In this paper, we propose a pair of static
analysis techniques that are sound but not complete.

Since all the operators (logical and arithmetic) are mathematical
functions, their composition is also a mathematical function
(function). Hence, in the absence of global variables, all procedure
are a function of their formal arguments. This paper focuses on
checking if a procedure that access global variables is OP. Procedure
`factorial' in Listing~\ref{lst:factorialSimple} is OP for a certain
set of global states.  In order to prove the result form a procedure
is independent of the global values, we prove that for all reachable
global states, for each argument value there is a single result. This
invariant over the global variables, can optimistically assume that
the given procedure is observationally pure, this is a trick we
use. This trick allows us a way to generate the invariant and also be
certain that the invariant has saturated. 

%% For procedure `factorial'
%% in Listing~\ref{lst:factorialSimple}, the invariant on the global
%% state can be This is make it feasible to generate an invariant for the
%% given procedure.

%% Observationally purity seems to be closely related to termination of
%% the given procedure. It is certainly feasible that the given procedure
%% terminates for a given global state but not for another.

Since observational purity is a property on the return values from a
procedure, this property is intertwined with termination. In
Section~\ref{sec:background}, we define OPness in a way such that
non-termination does not cause non-OPness. OP is violated only if for
a given invariant on the reachable global states, for a given argument
value there is a non-unique return value. Thus, there must exist a
pair of traces such that both the traces begin a global state that is
satisfied by the invariant, and both traces begin with the same
argument value but return different results.


\begin{lstlisting}[language=c, caption= {Procedure `factorial' :
      returns factorial of `n' and memoizes result for argument value
      `19'.}, label=lst:factorialSimple]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    return 1;
  } else if(g == -1 && n == 19) {
    g = 19 * factorial( 18 );
    return g;
  } else if(g != -1 && n == 19) {
    return g;
  } else {
    return n * factorial( n - 1 );
  }
}
\end{lstlisting}

%% Programmers on rely many library procedures to be mathematical
%% function. For instance, procedures like `sine' and `cos'.

Dynamic programming algorithms (such as procedure `factorial' in
Listing~\ref{lst:factorialSimple}) use memoization to store
pre-computed solutions to the sub-problem so that it can look-up the
solution when needed, thus trading compute time for storage. Our
technique can check if it is safe the memoize the results produced by
a procedure. By safety we mean assurance that the procedure will
produce the same result it returned earlier. We propose two static
analysis techniques to check this problem. The property we check is
whether the given procedure's behaviour is equivalent to some
mathematical function.  One interesting thing about our approach is
that the user need not mention a (the) mathematical function that the
procedure is supposed to mimic.


\section{Background} \label{sec:background}
This section first gives the definition of Observational purity. Next,
we present some formalisms that we use define our approaches.

\subsection{Programming Language}
We make the following restrictions on the structure of the prgram for
the sake of simplicity of the analysis.

\begin{itemize}
\item The given procedure (`\foo') has a single argument i.e `\n'. And
  `\n' is never written inside `\foo'.
\item Procedure `\foo' has a single global variable name `\g'.
\item We are only analyzing procedure `\foo' and the other procedures
  in the program do not write to global variables that `\foo' refers
  to.
\item No variable is used before it is defined, except global
  variables.
\item All loops in procedure `\foo' have been replaced with separate
  recursive procedures.
\item The return value from the recursive procedure calls is assigned
  only to local variables.
\end{itemize}

Note : all of the above mentioned restrictions can be omitted.
\subsection{SSA}
This section shows how a program transformation allows a program to be
represented in logic.

\subsection{Path Condition}
  %% The path condition $\pathCondition$ for a given procedure $\foo$ is
  %% a formula that relates the incoming values of global variables and
  %% arguments to the outgoing values of the global variables and the
  %% return value, while assuming the recursive procedure call (if there
  %% is one) to be to an OP procedure. The recursive procedure call is
  %% represented as function symbol instead of inlining it.

  The path condition $\pathCondition$ for procedure `\foo' is a
  formula that represents the procedure `\foo' in logic.
  $\pathCondition$ has the following set of free variables \{$\g,
  \gout,\n,\\ \retVar, \gbef_1, \cdots \gbef_m, \gaft_1, \cdots
  \gaft_m$\}. Variable $\g$ represents the value of the global
  variable `\g' at the beginning of procedure `\foo' whereas $\gout$
  represents value of `\g' at the end of `\foo'. Variable $\n$
  represents the value of the argument, $\retVar$ the return
  value. And $\gbef_i$ and $\gaft_i$ represent the value of `\g' before
  and after the $i^{th}$ procedure call statement and there are $m$
  procedure calls in `\foo'.

\begin{definition}[trace]
  A trace $\trace$ is a complete execution of the procedure starting
  from a given global state and a tuple of formal arguments. A trace
  upon completion gives an end state and a return value. Traces may
  have sub-traces, which by definition are traces (recursive calls).
\end{definition}

\begin{definition}[history]
  A history $\history$ is a sequence of consecutive traces, with the
  first trace starting from a given global state, and each subsequent
  trace begins in the state in which the previous trace ends.
\end{definition}

\section{Invariant}

\begin{definition}[invariant]
  An invariant is a formula with function symbol $\F$ and the global
  variables of the given procedure as free variables. The invariant
  represents the set of global states that may arise before and after
  each procedure call of the given procedure in a history or set of
  histories. Some variables here may be defined in terms of a function
  symbol $\F$, which in turn refers to the mathematical function that
  is equivalent to the given procedure.
  
  Let $\gstate$ be a global state, and $\F'$ be a function, and $\inv$
  be a invariant. If we substitute $\gstate$ for $g$ and $\F'$ for
  $\F$ in $\inv$, if $\inv[\gstate/g, \F'/\F]$ is true then, we say
  $(\gstate, \F') \satisfies \inv$. For instance let $\inv := g = -1
  \vee g = \F(18) * 19$ then $(0, \lambda n. n!) \satisfies \inv$.
\end{definition}

Note : Representing recursive calls using function symbols allows us
to comeup with an automated invariant generation algorithm.

\begin{definition}[observational purity(invariant $\inv$)]
  A given set of procedures are observationally pure if in each
  history starting from a state in invariant $\inv$, all traces of
  each procedure with the same argument value return the same result.
\end{definition}

\subsection{Existential approach}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckE & \mi{(\inv :
        invariant, \pathCondition : path \; condition)} \equiv \\
      &\inv \wedge \pathCondition \wedge \retVar = \F(\n)\\
      & 
    \end{align*}
    \caption{Existential check : produces a formula whose
      satisfiability implies the given procedure is observationally
      pure} 
    \label{algo:someOPcheckCombined}
  \end{algorithm}  
\end{figure}

\section{Impurity witness approach}
\section{is invariant inductive}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      is-Inductive & \mi{(\inv :
        invariant, \pathCondition : path \; condition)} \equiv \\
      &\inv \wedge \pathCondition \implies \inv[\g'/\g]
    \end{align*}
    \caption{Is Inductive: is true iff the given invariant is inductive} 
    \label{algo:someOPcheckCombined}
  \end{algorithm}  
\end{figure}

\subsection{Comparing the two approaches}
\section{Comparison of Impurity witness approach with other approaches}
The goal of this section is to 

\section{Conclusions}
%

%
% ---- Bibliography ----
%
\begin{thebibliography}{5}
%
\bibitem {clar:eke}
Clarke, F., Ekeland, I.:
Nonlinear oscillations and
boundary-value problems for Hamiltonian systems.
Arch. Rat. Mech. Anal. 78, 315--333 (1982)


\end{thebibliography}

\end{document}
