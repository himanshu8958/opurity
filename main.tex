% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
%% himanshu
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{syntax}
\newcommand{\foo}{\textit{foo}}
\newcommand{\trace}{\pi}
\newcommand{\inv}{\mathit{inv}}
\newcommand{\history}{\Pi}
\newcommand{\pathCondition}{\mathit{T_{\foo}}}
\newcommand{\OPCheckE}{\mathit{OPCheck \mhyphen existential}}
\newcommand{\OPCheckA}{\mathit{OPCheck \mhyphen pairwise}}
\mathchardef \mhyphen="2D
\newcommand{\mi}[1]{\mathit{#1}}
\newcommand{\retVar}{\textit{retVar}}
\newcommand{\F}{\mathit{F}}
\newcommand{\n}{\textit{n}}
\newcommand{\gstate}{\gamma}
\newcommand{\g}{\textit{g}}
\newcommand{\gout}{\textit{gout}}
\newcommand{\gbef}{\textit{gbef}}
\newcommand{\gaft}{\textit{gaft}}
\newcommand{\satisfies}{\vdash}
\newcommand{\fact}{\mathit{fact}}


\lstdefinestyle{mystyle}{
  basicstyle=\footnotesize, 
  %% breakatwhitespace=false,         
  %% breaklines=true,                 
  captionpos=b,
  %% keepspaces=true,         
  numbers=left,
  numbersep=6pt,                  
  %% showspaces=false,                
  %% showstringspaces=false,
  %% showtabs=false,
  morekeywords={if, for, else,
  procedure,modifies, var, returns, int, call, assume},
  %% tabsize=2
}
\lstset{
  %% basicstyle=\itshape,
  style = mystyle,
  xleftmargin=3em,
  %% literate={\alt}{;}{1}
  %% basicstyle=\footnotesize,
  numberstyle=\tiny,
  breaklines=true,
  escapeinside={\%*}{*)}
}

%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
%% \chapter*{Preface}
%% %
%% This textbook is intended for use by students of physics, physical
%% chemistry, and theoretical chemistry. The reader is presumed to have a
%% basic knowledge of atomic and quantum physics at the level provided, for
%% example, by the first few chapters in our book {\it The Physics of Atoms
%% and Quanta}. The student of physics will find here material which should
%% be included in the basic education of every physicist. This book should
%% furthermore allow students to acquire an appreciation of the breadth and
%% variety within the field of molecular physics and its future as a
%% fascinating area of research.

%% For the student of chemistry, the concepts introduced in this book will
%% provide a theoretical framework for that entire field of study. With the
%% help of these concepts, it is at least in principle possible to reduce
%% the enormous body of empirical chemical knowledge to a few basic
%% principles: those of quantum mechanics. In addition, modern physical
%% methods whose fundamentals are introduced here are becoming increasingly
%% important in chemistry and now represent indispensable tools for the
%% chemist. As examples, we might mention the structural analysis of
%% complex organic compounds, spectroscopic investigation of very rapid
%% reaction processes or, as a practical application, the remote detection
%% of pollutants in the air.

%% \vspace{1cm}
%% \begin{flushright}\noindent
%% April 1995\hfill Walter Olthoff\\
%% Program Chair\\
%% ECOOP'95
%% \end{flushright}
%% %
%% \chapter*{Organization}
%% ECOOP'95 is organized by the department of Computer Science, Univeristy
%% of \AA rhus and AITO (association Internationa pour les Technologie
%% Object) in cooperation with ACM/SIGPLAN.
%% %
%% \section*{Executive Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \section*{Program Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \begin{multicols}{3}[\section*{Referees}]
%% V.~Andreev\\
%% B\"arwolff\\
%% E.~Barrelet\\
%% H.P.~Beck\\
%% G.~Bernardi\\
%% E.~Binder\\
%% P.C.~Bosetti\\
%% Braunschweig\\
%% F.W.~B\"usser\\
%% T.~Carli\\
%% A.B.~Clegg\\
%% G.~Cozzika\\
%% S.~Dagoret\\
%% Del~Buono\\
%% P.~Dingus\\
%% H.~Duhm\\
%% J.~Ebert\\
%% S.~Eichenberger\\
%% R.J.~Ellison\\
%% Feltesse\\
%% W.~Flauger\\
%% A.~Fomenko\\
%% G.~Franke\\
%% J.~Garvey\\
%% M.~Gennis\\
%% L.~Goerlich\\
%% P.~Goritchev\\
%% H.~Greif\\
%% E.M.~Hanlon\\
%% R.~Haydar\\
%% R.C.W.~Henderso\\
%% P.~Hill\\
%% H.~Hufnagel\\
%% A.~Jacholkowska\\
%% Johannsen\\
%% S.~Kasarian\\
%% I.R.~Kenyon\\
%% C.~Kleinwort\\
%% T.~K\"ohler\\
%% S.D.~Kolya\\
%% P.~Kostka\\
%% U.~Kr\"uger\\
%% J.~Kurzh\"ofer\\
%% M.P.J.~Landon\\
%% A.~Lebedev\\
%% Ch.~Ley\\
%% F.~Linsel\\
%% H.~Lohmand\\
%% Martin\\
%% S.~Masson\\
%% K.~Meier\\
%% C.A.~Meyer\\
%% S.~Mikocki\\
%% J.V.~Morris\\
%% B.~Naroska\\
%% Nguyen\\
%% U.~Obrock\\
%% G.D.~Patel\\
%% Ch.~Pichler\\
%% S.~Prell\\
%% F.~Raupach\\
%% V.~Riech\\
%% P.~Robmann\\
%% N.~Sahlmann\\
%% P.~Schleper\\
%% Sch\"oning\\
%% B.~Schwab\\
%% A.~Semenov\\
%% G.~Siegmon\\
%% J.R.~Smith\\
%% M.~Steenbock\\
%% U.~Straumann\\
%% C.~Thiebaux\\
%% P.~Van~Esch\\
%% from Yerevan Ph\\
%% L.R.~West\\
%% G.-G.~Winter\\
%% T.P.~Yiou\\
%% M.~Zimmer\end{multicols}
%% %
%% \section*{Sponsoring Institutions}
%% %
%% Bernauer-Budiman Inc., Reading, Mass.\\
%% The Hofmann-International Company, San Louis Obispo, Cal.\\
%% Kramer Industries, Heidelberg, Germany
%% %
%% \tableofcontents
%% %
\mainmatter              % start of the contributions
%
\title{Checking Observational Purity}
%
\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
%% \author{Ivar Ekeland\inst{1}\orcidID{0000-1111-2222-3333} \and
%% Roger~Temam\inst{2}\orcidID{1111-2222-3333-4444} \and
%% Jeffrey~Dean\orcidID{2222-3333-4444-5555} \and
%% David~Grove\orcidID{3333-4444-5555-6666} \and
%% Craig~Chambers\orcidID{4444-5555-6666-7777} \and
%% Kim~B.~Bruce\orcidID{5555-6666-7777-8888} \and
%% Elsa~Bertino\orcidID{6666-7777-8888-9999}}
%% %
%% \authorrunning{Ivar Ekeland et al.} % abbreviated author list (for running head)
%% %
%% %%%% list of authors for the TOC (use if author list has to be modified)
%% \tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%% Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%% %
%% \institute{Princeton University, Princeton NJ 08544, USA,\\
%% \email{I.Ekeland@princeton.edu},\\ WWW home page:
%% \texttt{http://users/\homedir iekeland/web/welcome.html}
%% \and
%% Universit\'{e} de Paris-Sud,
%% Laboratoire d'Analyse Num\'{e}rique, B\^{a}timent 425,\\
%% F-91405 Orsay Cedex, France}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The abstract should summarize the contents of the paper
using at least 70 and at most 150 words. It will be set in 9-point
font size and be inset 1.0 cm from the right and left margins.
There will be two blank lines before and after the Abstract. \dots
\keywords{static analysis, Program analysis }
\end{abstract}

\section{Introduction}
Verifying function properties of procedures is a hard task. 
Formalizing the functional properties of a procedure entails
deep understanding of the procedure's (expected) functionality.
%% Defining the correctness for a procedure is a time consuming task that
%% requires deep understanding of the expected functionality of a
%% procedure.
In this paper, we talk about a general property that is the necessary
condition for the correctness of many procedures. If the return value
from a procedure is dependent only on the formal arguments, the given
procedure is \textit{Observationally pure(OP)}.
%% Thus, OP procedures return equivalent to a mathematical
%% function of the argument values; independent of the value of the
%% global variables.
%% Essentially, we ensure
Ensuring, existence of a mathematical function that mimics the given
procedure and shares it's signature. Implying, input-output behaviour
of the given procedure is independent of any global state. This is a
general property that has many applications.  For instance,
implementations of dynamic programming problems without the
memoization would mimic the input-output behaviour as of the optimal
implementations. Checking whether a given procedure is OP, is
undecidable. In this paper, we propose a pair of static analysis
techniques to check OPness that are sound but incomplete.

All logical and arithmetic operators are mathematical functions
(function), and this property of being a function is closed under
composition.
%% their composition is also a mathematical function
%% (function) .
Hence, in the absence of global variables, all procedures
are a function of their formal arguments. This paper focuses on
checking if a procedure that access global variables is OP.

OPness is a property of the given procedure and the respective
reachable global states.  Procedure `factorial' in
Listing~\ref{lst:factorialSimple} is OP if the global state is
restricted to the set $\{g = -1, g = 3!\}$, and it mimics $\lambda
n.n!$. But for the global states $\{g = 1, g = 3!\}$, procedure
`factorial' is not a mathematical function. For argument value `$n =
3$' it may return 1 or 3!.  We assume that this set of global states
can be represented in the underlying logic and we refer to it as
\textit{invariant}. The global states reachable at all the boundaries
of the given procedure in all executions must satisfy the invariant.
%% Also
%% for all procedure calls, the global state at the beginning of, as well
%% as at the end of the procedure call must satisfy the invariant.

To prove a given procedure to be OP, we ensure that for all
reachable global states, for each argument value, there is a single
result. Now, this can be modelled using standard pre and post
conditions. The pre condition holds at the beginning of the procedure
and the post condition holds at its end. Both the pre condition and
the post condition can be substituted by the invariant. This does
not constrain the return value of the procedure. But, the return value
from a recursive call might flow into a global variable. Thus,
the return from the procedure must be modelled in the post condition;
to re-establish $\inv$.
For procedure `factorial' in Listing~\ref{lst:factorialSimple} we can
use the invariant `$\inv : g = -1 \vee g = 6$' and the function
`factorial' can be modelled as `$ f := k \leq 1 \implies \fact[k] == 1
\wedge k >1 \implies \fact[k] == \fact[k-1]*k$'. Thus, the
pre-condition is `$\inv$' and the post-condition is `$\inv \wedge f
\wedge \retVar = fact[n]$'.

The above mentioned idea is valid (modulo usability). Its issues are
(a) theorem provers often fail to prove such assertions (as is the
case for the above mentioned example) (b) describing the procedure in
logic takes considerable effort.  Instead of formalizing the function
for the given procedure, why not equate the result from the procedure
to that of an uninterpreted function symbol?  And then, ask the
question whether an assignment for the function symbol exists? If yes,
then the procedure is OP o/w given procedure is not OP.
This is our existential approach.
%% Now, this kind of a query is also hard for theorem provers. Later, we
%% show another technique that borrows from this idea, and is able to
%% prove procedures such as `factorial' in
%% Listing~\ref{lst:factorialSimple} to be OP.

Abstracting using function symbols goes a long way. It helps in
representing the post-condition is an easy manner, also it aids in
describing the invariant. 
%% also in describing the invariant on the global states.
%% The result from a recursive procedure call may flow to a global
%% variable. In such a case, the return from the recursive procedure call
%% needs to be evaluated to establish the post-condition. We propose, use
%% the same function symbol (as mentioned above) to represent the result
%% from a recursive procedure call (the same function symbol that was
%% equated to the result of the procedure).
For procedure `factorial', we can use the invariant $\inv_{\F}:=g = -1
\vee g = \F(2) * 3$. The symbol $\F(2)$ in the invariant represents
the return value for argument $n = 2$ from the procedure `factorial'
assuming it is a mathematical function. Note that invariant used here
is valid if the given procedure is OP, otherwise it is not well
defined.

%% should I talk about why F(2) *3 instead of F(3) ?

OPness can also be ensured by comparing a procedure to itself. We
represent two instances of a procedure in some underlying logic, and
then ask the question that do the two instances of the given procedure
mimic each other, for all argument values, and all states satisfying
the invariant? If yes, then we show that the given procedure is
OP. Otherwise, we construct a witness to the impurity of the given
procedure. We construct a pair of traces, such that both begin in a
global state in the invariant, the same argument value but return
different results. We call this the `impurity witness approach'.
%% Then, ask the question that does a
%% pair of traces exist such that both start with the same parameter but
%% return different results. We call this the impurity witness
%% approach
This approach also makes use of  invariant with uninterpreted function
symbols same as the previous approach.

%% This invariant over the global variables, can optimistically
%% assume that the given procedure is observationally pure, this is a
%% trick we use. This trick allows us a way to generate the invariant and
%% also be certain that the invariant has saturated.

%% In static analysis, recursion is handled by either repeated inlining
%% or using pre and post conditions. The pre and post conditions are
%% constructed in a what that if the precondition holds before the
%% procedure call then the post condition holds after the procedure call,
%% for all procedure call. Only in-case of a recursive procedure call the
%% precondition is expected to hold at the beginning of the procedure and
%% the post condition is expected to hold at the end of the procedure. 
%% Capturing the meaning of the program in this mechanism requires that
%% the return of the procedure is also modelled in the same logic as used
%% to represent the pre and post conditions. Also, this return value is
%% generally a part of the post condition. We instead propose to
%% model the return value from the procedure as an uninterpreted
%% function; some mathematical function which we don't care to define. 

%% The semantics of the invariant we use is that (a) it is defined iff
%% the given procedure is a mathematical function (b) It represents all
%% the reachable global states before and after each procedure call. We
%% use this invariant to represent the pre-condition and the
%% post-condition. 

%% the invariant, which will substituted or the pre and the
%% post condition can be generated automatically. We Will present an
%% approach for constructing the invariant in Section~\ref{sec:invGen}.
  
%% Observationally purity seems to be closely related to termination of
%% the given procedure. It is certainly feasible that the given procedure
%% terminates for a given global state but not for another.

Since observational purity is a property on the return values from a
procedure, this problem is closely related with the termination of the
given procedure. In Section~\ref{sec:background}, we define OPness in
a way such that non-termination does not cause non-OPness. OP is
violated if for a given invariant on the reachable global states, for
a given argument value there is a non-unique return value. And in-case
of non-termination there isn't a return value.

\begin{lstlisting}[language=c, caption= {Procedure `factorial' :
      returns factorial of `n' and memoizes result for argument value
      `3'.}, label=lst:factorialSimple]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    return 1;
  } else if(g == -1 && n == 3) {
    g = 3 * factorial( 2 );
    return g;
  } else if(g != -1 && n == 3) {
    return g;
  } else {
    return n * factorial( n - 1 );
  }
}
\end{lstlisting}

%% Programmers on rely many library procedures to be mathematical
%% function. For instance, procedures like `sine' and `cos'.

Dynamic programming algorithms (such as procedure `factorial' in
Listing~\ref{lst:factorialSimple}) use memoization to store
pre-computed solutions to the sub-problem so that it can look-up the
solution when needed, thus trading compute time for storage. Our
technique can check if it is safe to memoize the results produced by a
procedure. By safety, we refer to preserving the input-output
behaviour. We propose two static analysis approaches to check this
problem. One interesting thing about our approach is that the user
need not mention a (the) mathematical function that the procedure is
supposed to mimic. Also, using a function symbol allows generating the
invariant automatically.

%% Now in our recipe for checking observational purity (a) we bypass
%% representing the meaning of the given procedure using a function
%% symbol (b) invariant, we give an approach to generate it automatically.

\section{Background} \label{sec:background}
This section first gives the definition of Observational purity. Next,
we present some formalisms that we use to define the approaches.

\subsection{Programming Language}
We make the following restrictions on the structure of the program for
the sake of simplicity of the analysis.

\begin{itemize}
\item The given procedure (`\foo') has a single argument i.e `\n'. And
  `\n' is never written inside `\foo'.
\item Procedure `\foo' has a single global variable name `\g'.
\item A special variable `\retVar' which is assigned the return value.
\item We are only analyzing procedure `\foo' and the other procedures
  in the program do not write to global variables that `\foo' refers
  to.
\item No variable is used before it is defined, except global
  variables.
\item All loops in procedure `\foo' are replaced with separate recursive procedures.
\item The return value from the recursive procedure calls is assigned
  only to local variables.
\end{itemize}
Note : all of the above mentioned restrictions can be omitted.

In Figure~\ref{fig:grammar} we show the grammar for the programming
language for which we have designed the static analysis approaches.
Most of the statements are standard statements in imperative
languages, the rest we explain. The statement `havoc x' assigns any
value to x from it's domain. And the statement `assume x' allows the
execution of the program to proceed iff the predicate `x' holds at the
given program point otherwise, it halts the execution.

\begin{figure}[hb!]
  %% \includegraphics[trim={0 5cm  3cm 0}, width=6cm]{grammar.eps}
  \begin{grammar}
    <statement> ::= <ident> = <constant>
    \alt <ident> = <logical-expr>
    \alt <ident> = <arithmetic-expr>
    \alt <statement>; <statement>
    %% \alt if<logical-expr> then <statement> else <statement>
    %% \alt while<logical-expr> do <statement>
    \alt <ident> = foo(<params-list>)
    \alt assume(<logical-expr>)
    \alt <ident> = \foo(<ident>)
    \alt havoc(<ident>)
    %% \alt <ident>[<ident>] = <ident>
    %% \alt <ident> = <ident>[<ident>]

    %% <params-list> ::= <params-list> , <ident>
    %% \alt <ident>

    <arithmetic-expr> ::= <ident> "+" <ident>
    \alt <ident> "-" <ident>
    \alt <ident> "/" <ident>
    \alt <ident> "*" <ident>
    \alt <ident> "\%" <ident>
 
    <logical-expr> ::= <ident> "<" <ident>
    \alt <ident> ">" <ident>
    \alt <ident> "==" <ident>
    \alt <ident> $\leq$ <ident>
    \alt <ident> $\geq$ <ident>
    \alt <logical-expr> $\wedge$ <logical-expr>
    \alt <logical-expr> $\vee$ <logical-expr>
    \alt $\neg$<logical-expr>
    \alt true
    \alt false

    <ident> ::= <local-ident>
    \alt <global-ident>
    
    <procedure> ::= procedure \foo ($\n$) {<statement>;}
  \end{grammar}
  \caption{Grammar for our programming language}
  \label{fig:grammar}
\end{figure}

\subsection{Our intermediate representation}\label{sec:intermediate}
We transform the given procedure into the following representation to be able
to represent it in logic. An instance of the transformed program wrt
procedure `factorial' in Listing~\ref{lst:factorialSimple} is in
Listing~\ref{lst:factorialTransformed}.

Our analysis expects the following :
\begin{enumerate}
\item A procedure call statement is not a part of an expression. If
  it is, partiton it into multiple statements.
\item Continuation of above, recursive calls may affect global
  variables and the variable assigned the return value. Procedure
  calls must be over-approximated using `havoc' statements.
\item In the previous steps `x = \foo(y)' is replaced with
  `havoc(x)' followed by `assume x = F(y)'.
\item After all this, the program should be converted to SSA form.
\end{enumerate}

\begin{lstlisting}[language=c, caption= {Procedure `factorial' from
      Listing~\ref{lst:factorialSimple} converted to the form our
      approach expects}, label=lst:factorialTransformed]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    retVar = 1;
    gout = g;
  } else if(g == -1 && n == 19) {
    gbef1 = g;
    havoc(temp1); 
    havoc(g1);
    assume(temp1 = F(18));  // temp1 = factorial(18)
    gaft1 = g1;
    g2 = 19 * temp1;
    retVar = g2;
    gout = g2;
  } else if(g != -1 && n == 19) {
    retVar = g;
    gout = g;
  } else {
    gbef2 = g;
    havoc(temp2);
    havoc(g1);
    assume(temp2 = F( n - 1 ));  //temp2 = factorial(n-1)
    gaft2 = g1;
    retVar = n * temp2;
    gout = g1;
  }
}
\end{lstlisting}

In Listing~\ref{lst:factorialTransformed}, in comparison to procedure
`factorial' in Listing~\ref{lst:factorialSimple}, the return statement
(line\# 4) is replaced by an assignment to \retVar (line\# 4). And in
line\# 5 of the transformed code, an extra variable `gout' is added
that captures the value of the global variable at the end of the
program. Similarly, variable `gbef1' (at line\# 7, transformed code)
is added to capture the value of the global variable before the
procedure call, and variable `gaft1' is inserted at line\# 11 to
capture the value of `g' after the procedure call. Also, havoc
statements at line\# 8, 20 and 9, 21 over-approximate the return from
the procedure call statement and updates to the global variable
respectively. The procedure call statement is substituted with
function symbols in line\# 10 and 22, accounting the given procedure
as a function.

\subsection{Path Condition}
  %% The path condition $\pathCondition$ for a given procedure $\foo$
  %% is
  %% a formula that relates the incoming values of global variables and
  %% arguments to the outgoing values of the global variables and the
  %% return value, while assuming the recursive procedure call (if there
  %% is one) to be to an OP procedure. The recursive procedure call is
  %% represented as function symbol instead of inlining it.

We need a representation of the given procedure in logic such that it
captures the value of the argument, the return value and the values of
the global variables at the boundries. We track the values of the
global variables using extra variables as explained in
Section~\ref{sec:intermediate}.

\begin{figure}
  \begin{align*}
    \pathCondition :=
    &(n \leq 1 \wedge retVar = 1 \wedge gout = g) \vee \\
    &(n > 1 \wedge g = -1 = gbef \wedge n = 19 \wedge temp1 = \F(18) \\
    &\wedge gaft1 = g1 \wedge g2 = 19 * temp1
    \wedge retVar = g2) \vee\\
    &(n > 1 \wedge \neg( g = -1 \wedge n = 19) \wedge g \neq -1
    \wedge n = 19 \wedge retVar = g = gout) \vee\\
    &(n > 1 \wedge n \neq 19 \wedge gbef2 = g \wedge temp2 = \F( n
    - 1) \wedge gaft2 = g1\\
    &\wedge retVar = n * temp2 \wedge gout = g1)\\
  \end{align*}
  \caption{Formula representing procedure `factorial' in
    Listing~\ref{lst:factorialTransformed} (assuming that function
    $\F$ is equivalent to procedure `factorial').}
  \label{fig:pathCondition}
\end{figure}

In Figure~\ref{fig:pathCondition} each disjunct represents a
straightline path in procedure `factorial'. For instace, $(n <= 1
\wedge retVar = 1 \wedge gout = g)$ represents the case where $n \leq
1$. Hereonwards, we will only use this formula, $\pathCondition$ to
describe our analysis.

  %% The path condition $\pathCondition$ for procedure `\foo' is a
  %% formula that represents the procedure `\foo' in logic.
  %% $\pathCondition$ has the following set of free variables \{$\g,
  %% \gout,\n,\\ \retVar, \gbef_1, \cdots \gbef_m, \gaft_1, \cdots
  %% \gaft_m$\}. Variable $\g$ represents the value of the global
  %% variable `\g' at the beginning of procedure `\foo' whereas $\gout$
  %% represents value of `\g' at the end of `\foo'. Variable $\n$
  %% represents the value of the argument, $\retVar$ the return
  %% value. And $\gbef_i$ and $\gaft_i$ represent the value of `\g' before
  %% and after the $i^{th}$ procedure call statement and there are $m$
  %% procedure calls in `\foo'.


\section{Invariant}

To introduce the definition of an invariant we first define trace and
history.

\begin{definition}[trace]
  A trace $\trace$ is a complete execution of the procedure starting
  from a given global state and a tuple of formal arguments. A trace
  upon completion gives an end state and a return value. Traces may
  have sub-traces, which by definition are traces (recursive calls).
\end{definition}

\begin{definition}[history]
  A history $\history$ is a sequence of consecutive traces, with the
  first trace starting from a given global state, and each subsequent
  trace begins in the state in which the previous trace ends.
\end{definition}

\begin{definition}[invariant]
  An invariant $\inv$ is a formula with function symbol $\F$ and the
  global variables of the given procedure as free variables. The
  invariant represents the set of global states that may arise before
  and after each procedure call of the given procedure in a set of
  histories. Thus, if a procedure begins in a global state that
  satisfies invariant $\inv$ then it also ends in a global state that
  satisfies $\inv$. Some variables may be defined in terms of a
  function symbol $\F$, which in turn refers to the mathematical
  function that is equivalent to the given procedure.
  
  Let $\gstate$ be a global state, and $\F'$ be a function, and $\inv$
  be a invariant. If we substitute $\gstate$ for $g$ and $\F'$ for
  $\F$ in $\inv$, if $\inv[\gstate/g, \F'/\F]$ is true then, we say
  $(\gstate, \F') \satisfies \inv$. For instance let $\inv := g = -1
  \vee g = \F(18) * 19$ then $(19!, \lambda n. n!) \satisfies \inv$.
\end{definition}

Note : Representing recursive calls using function symbols allows us
to come-up with an automated invariant generation algorithm.

The invariant has a free variable, which represents the function
equivalent to the given procedure. Thus, such an invariant assumes
that the given procedure is a mathematical function. This invariant is
not well defined if the given procedure is not a mathematical
function. 

As expressed in the introduction, a procedure is OP only for a given
set of reachable global states. So, if procedure \foo is OP for
invariant $\inv$ it will also be OP for $\inv'$ where $\inv' \implies
\inv$ but $\inv'$ be not be inductive. But the procedure may not be OP
for $\inv''$ where $\inv'' \implies \inv$.

\section{Observational purity}
\begin{definition}[observational purity(invariant $\inv$)]
  A given set of procedures are observationally pure if in each
  history starting from a state in invariant $\inv$, all traces of
  each procedure return the same result if the argument value is the
  same. 
  %% with the same argument value return the same result.
\end{definition}

\begin{lstlisting}[caption={Procedure `remember' : always returns the
      argument from its first call}, label=lst:remember]
int g = 0;
int init = 0;
int remember( int n) {
  if(init = 0){
    init = 1;
    g = n;
  }
  return g;
}
\end{lstlisting}


Note: if in a history all traces return the same result for an
argument value, then we can find a function $\F$ that respects the
given procedure. Now as it turns out, if the invariant is set of
concrete states then there is a unique function that is equivalent to
the given procedure. The invariant we use allows multiple functions to
be equivalent to the given procedure. For instance, procedure
`remember' in Listing~\ref{lst:remember} mimics a constant function
for $\inv := g=0 \wedge init=0 \vee g= \F() \wedge init=1$. Whereas,
for the invariant $\inv := g=0 \wedge init=0 \vee g=2 \wedge init=1$;
we have $\F = \lambda n.2$.


\section{Existential approach}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckE
       & \mi{(\inv :
        invariant, \pathCondition : path \; condition)} \equiv \\
      &\inv \wedge \pathCondition \wedge \retVar = \F(\n)\\
    \end{align*}
    \caption{Existential check : produces a formula whose
      satisfiability implies the given procedure is observationally
      pure} 
    \label{algo:someOPcheckCombined}
  \end{algorithm}  
\end{figure}

%% \begin{figure}[htp]
%%   \begin{algorithm}[H]
%%     \begin{align*}
%%       \OPCheckE & \mi{(\inv :
%%         invariant, \pathCondition : path \; condition)} \equiv \\
%%        (\forall & \g) (\forall \n) (\forall \retVar) (\forall \gout) &(1)\\
%%        (\forall & \gbef_1) (\forall \gbef_2) \cdots(\forall \gbef_m) &(2)\\
%%        (\forall & \gaft_1) (\forall \gaft_2) \cdots(\forall \gaft_m)
%%       \{& (3)\\
%%       & \inv \wedge \pathCondition \wedge & (4)\\
%%       & \inv[\gaft_1/\g] \wedge \inv[\gaft_2/\g] \cdots \wedge
%%       \inv[\gaft_m/\g] & (5)\\
%%       & \implies (\retVar = \F(\n) \wedge \inv[\gout/\g] \wedge & (6) \\
%%       & \inv[\gbef_1/\g] \wedge \inv[\gbef_2/\g] \cdots \wedge
%%       \inv[\gbef_m/\g]) & (7) \\
%%        \}&\\
%%     \end{align*}
%%     \caption{Existential check : produces a formula whose
%%       satisfiability implies the given procedure is observationally
%%       pure} 
%%     \label{algo:someOPcheckCombined}
%%   \end{algorithm}  
%% \end{figure}

\section{Impurity witness approach}
\section{is invariant inductive}

%% \begin{figure}[htp]
%%   \begin{algorithm}[H]
%%     \begin{align*}
%%       is-Inductive & \mi{(\inv :
%%         invariant, \pathCondition : path \; condition)} \equiv \\
%%       &\inv \wedge \pathCondition \implies \inv[\g'/\g]
%%     \end{align*}
%%     \caption{Is Inductive: is true iff the given invariant is inductive} 
%%     \label{algo:someOPcheckCombined}
%%   \end{algorithm}  
%% \end{figure}

\subsection{Comparing the two approaches}
\section{Comparison of Impurity witness approach with other approaches}
The goal of this section is to 

\section{Conclusions}
%

%
% ---- Bibliography ----
%
\begin{thebibliography}{5}
%
\bibitem {clar:eke}
Clarke, F., a, I.:
Nonlinear oscillations and
boundary-value problems for Hamiltonian systems.
Arch. Rat. a. Anal. 78, 315--333 (1982)


\end{thebibliography}

\end{document}
