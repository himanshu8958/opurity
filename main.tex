% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
%% himanshu
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{syntax}
\usepackage{amssymb}
\newcommand{\foo}{\textit{foo}}
\newcommand{\trace}{\pi}
\newcommand{\inv}{\mathit{inv}}
\newcommand{\history}{\Pi}
\newcommand{\pathCondition}{\mathit{T_{\foo}}}
\newcommand{\OPCheckE}{\mathit{OPCheck \mhyphen existential}}
\newcommand{\OPCheckA}{\mathit{OPCheck \mhyphen pairwise}}
\mathchardef \mhyphen="2D
\newcommand{\mi}[1]{\mathit{#1}}
\newcommand{\retVar}{\textit{retVar}}
\newcommand{\F}{\mathit{F}}
\newcommand{\n}{\textit{n}}
\newcommand{\gstate}{\gamma}
\newcommand{\g}{\textit{g}}
\newcommand{\gout}{\textit{gout}}
\newcommand{\gbef}{\textit{gbef}}
\newcommand{\gaft}{\textit{gaft}}
\newcommand{\satisfies}{\vdash}
\newcommand{\fact}{\mathit{fact}}
\newcommand{\formula}{\mu}
\newcommand{\integer}{\mathbb{N}}

\lstdefinestyle{mystyle}{
  basicstyle=\footnotesize, 
  %% breakatwhitespace=false,         
  %% breaklines=true,                 
  captionpos=b,
  %% keepspaces=true,         
  numbers=left,
  numbersep=6pt,                  
  %% showspaces=false,                
  %% showstringspaces=false,
  %% showtabs=false,
  morekeywords={if, for, else,
  procedure,modifies, var, returns, int, call, assume},
  %% tabsize=2
}
\lstset{
  %% basicstyle=\itshape,
  style = mystyle,
  xleftmargin=3em,
  %% literate={\alt}{;}{1}
  %% basicstyle=\footnotesize,
  numberstyle=\tiny,
  breaklines=true,
  escapeinside={\%*}{*)}
}

%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
%% \chapter*{Preface}
%% %
%% This textbook is intended for use by students of physics, physical
%% chemistry, and theoretical chemistry. The reader is presumed to have a
%% basic knowledge of atomic and quantum physics at the level provided, for
%% example, by the first few chapters in our book {\it The Physics of Atoms
%% and Quanta}. The student of physics will find here material which should
%% be included in the basic education of every physicist. This book should
%% furthermore allow students to acquire an appreciation of the breadth and
%% variety within the field of molecular physics and its future as a
%% fascinating area of research.

%% For the student of chemistry, the concepts introduced in this book will
%% provide a theoretical framework for that entire field of study. With the
%% help of these concepts, it is at least in principle possible to reduce
%% the enormous body of empirical chemical knowledge to a few basic
%% principles: those of quantum mechanics. In addition, modern physical
%% methods whose fundamentals are introduced here are becoming increasingly
%% important in chemistry and now represent indispensable tools for the
%% chemist. As examples, we might mention the structural analysis of
%% complex organic compounds, spectroscopic investigation of very rapid
%% reaction processes or, as a practical application, the remote detection
%% of pollutants in the air.

%% \vspace{1cm}
%% \begin{flushright}\noindent
%% April 1995\hfill Walter Olthoff\\
%% Program Chair\\
%% ECOOP'95
%% \end{flushright}
%% %
%% \chapter*{Organization}
%% ECOOP'95 is organized by the department of Computer Science, Univeristy
%% of \AA rhus and AITO (association Internationa pour les Technologie
%% Object) in cooperation with ACM/SIGPLAN.
%% %
%% \section*{Executive Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \section*{Program Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \begin{multicols}{3}[\section*{Referees}]
%% V.~Andreev\\
%% B\"arwolff\\
%% E.~Barrelet\\
%% H.P.~Beck\\
%% G.~Bernardi\\
%% E.~Binder\\
%% P.C.~Bosetti\\
%% Braunschweig\\
%% F.W.~B\"usser\\
%% T.~Carli\\
%% A.B.~Clegg\\
%% G.~Cozzika\\
%% S.~Dagoret\\
%% Del~Buono\\
%% P.~Dingus\\
%% H.~Duhm\\
%% J.~Ebert\\
%% S.~Eichenberger\\
%% R.J.~Ellison\\
%% Feltesse\\
%% W.~Flauger\\
%% A.~Fomenko\\
%% G.~Franke\\
%% J.~Garvey\\
%% M.~Gennis\\
%% L.~Goerlich\\
%% P.~Goritchev\\
%% H.~Greif\\
%% E.M.~Hanlon\\
%% R.~Haydar\\
%% R.C.W.~Henderso\\
%% P.~Hill\\
%% H.~Hufnagel\\
%% A.~Jacholkowska\\
%% Johannsen\\
%% S.~Kasarian\\
%% I.R.~Kenyon\\
%% C.~Kleinwort\\
%% T.~K\"ohler\\
%% S.D.~Kolya\\
%% P.~Kostka\\
%% U.~Kr\"uger\\
%% J.~Kurzh\"ofer\\
%% M.P.J.~Landon\\
%% A.~Lebedev\\
%% Ch.~Ley\\
%% F.~Linsel\\
%% H.~Lohmand\\
%% Martin\\
%% S.~Masson\\
%% K.~Meier\\
%% C.A.~Meyer\\
%% S.~Mikocki\\
%% J.V.~Morris\\
%% B.~Naroska\\
%% Nguyen\\
%% U.~Obrock\\
%% G.D.~Patel\\
%% Ch.~Pichler\\
%% S.~Prell\\
%% F.~Raupach\\
%% V.~Riech\\
%% P.~Robmann\\
%% N.~Sahlmann\\
%% P.~Schleper\\
%% Sch\"oning\\
%% B.~Schwab\\
%% A.~Semenov\\
%% G.~Siegmon\\
%% J.R.~Smith\\
%% M.~Steenbock\\
%% U.~Straumann\\
%% C.~Thiebaux\\
%% P.~Van~Esch\\
%% from Yerevan Ph\\
%% L.R.~West\\
%% G.-G.~Winter\\
%% T.P.~Yiou\\
%% M.~Zimmer\end{multicols}
%% %
%% \section*{Sponsoring Institutions}
%% %
%% Bernauer-Budiman Inc., Reading, Mass.\\
%% The Hofmann-International Company, San Louis Obispo, Cal.\\
%% Kramer Industries, Heidelberg, Germany
%% %
%% \tableofcontents
%% %
\mainmatter              % start of the contributions
%
\title{Checking Observational Purity}
%
\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
%% \author{Ivar Ekeland\inst{1}\orcidID{0000-1111-2222-3333} \and
%% Roger~Temam\inst{2}\orcidID{1111-2222-3333-4444} \and
%% Jeffrey~Dean\orcidID{2222-3333-4444-5555} \and
%% David~Grove\orcidID{3333-4444-5555-6666} \and
%% Craig~Chambers\orcidID{4444-5555-6666-7777} \and
%% Kim~B.~Bruce\orcidID{5555-6666-7777-8888} \and
%% Elsa~Bertino\orcidID{6666-7777-8888-9999}}
%% %
%% \authorrunning{Ivar Ekeland et al.} % abbreviated author list (for running head)
%% %
%% %%%% list of authors for the TOC (use if author list has to be modified)
%% \tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%% Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%% %
%% \institute{Princeton University, Princeton NJ 08544, USA,\\
%% \email{I.Ekeland@princeton.edu},\\ WWW home page:
%% \texttt{http://users/\homedir iekeland/web/welcome.html}
%% \and
%% Universit\'{e} de Paris-Sud,
%% Laboratoire d'Analyse Num\'{e}rique, B\^{a}timent 425,\\
%% F-91405 Orsay Cedex, France}

\maketitle              % typeset the title of the contribution

\begin{abstract}
%% The abstract should summarize the contents of the paper
%% using at least 70 and at most 150 words. It will be set in 9-point
%% font size and be inset 1.0 cm from the right and left margins.
%% There will be two blank lines before and after the Abstract. \dots

  %% Observational purity checks if a given procedure is a pure function
  %% of it's arguments modulo the side effects.
  %% (option 1)\\
  %% A procedure that is a pure function of its arguments modulo side
  %% effect to the global state is Observationally pure (OP). We present
  %% a pair of static analysis approaches that entail OPness. In-order to
  %% statically check OPness, we need an invariant on the global states
  %% at the boundaries of the procedure. Allowing the invariant to be
  %% defined in terms of the given procedure (assuming it is OP)
  %% simplifies invariant construction. This also allows us to
  %% automatically check OPness for recursive procedures. \dots\\

  %% (option 2)\\
  
  A specification language that includes procedure calls greatly
  improves the ease of expression. Java modelling language (JML)
  currently allows only pure procedures (side effect free) to be used
  in the specifications. This is overly restrictive, as the procedure
  might have benign side effects, which are not observable to other
  procedures (or itself). Observationally pure procedures may read or
  write to global variables, but their input-output behaviour is
  independent of the global state.
  
  We introduce a notion of a conditional invariant, that is defined if
  the given procedure is indeed observationally pure. We present two
  static analysis approaches that can check observational purity of a
  given procedure. These techniques do not require any annotations and
  are applicable to self-recursive procedures, which is beyond the
  scope of existing literature.
  
  %% We give a pair of static analysis techniques to check if a given
  %% (potentially recursive, with side effects) procedure is a function
  %% of it's arguments modulo the side effects. Inorder to define

  
  %% We give A procedure
  %% that is a pure function of the arguments modulo side effects on the
  %% global state, this properly is Observational purity \dots

  %% (
  %% In this direction, we propose a definition that
  %% generalizes functional purity by compromising on side effects on the
  %% global state.

  %% that allows the expression language to
  %% include procedures 
  
  %% A procedure that is a pure function of it's arguments is
  %% Observationally pure. 
\keywords{specification languages, observational purity, pure procedure,
  programming by contract, static analysis}
\end{abstract}

\section{Introduction}
Verifying functional properties of procedures is a hard task. 
Formalizing such properties of a procedure entails
deep understanding of the procedure's (expected) functionality.
%% Defining the correctness for a procedure is a time consuming task that
%% requires deep understanding of the expected functionality of a
%% procedure.
In this paper, we talk about a general property that is a necessary
condition for the correctness of many procedures. If the return value
from a procedure is dependent only on the formal arguments even if the
procedure reads/writes to global variables, the given
procedure is considered as \textit{Observationally pure(OP)}.
%% Thus, OP procedures return equivalent to a mathematical
%% function of the argument values; independent of the value of the
%% global variables.
%% Essentially, we ensure
If a procedure $\foo$ is observationally pure, then there exists a
mathematical function $\F$ such that $\F$ mimics the input-output
behaviour of $\foo$, and both $\foo$ and $\F$ have the same signature.
Thus, the input-output behaviour of procedure $\foo$ is independent of
the value of the global variables.  This has many applications. For
instance, non-optimal implementations of dynamic programming
algorithms that do not use memoization can be refactored to use
memoization automatically.
%% implementations of
%% dynamic programming problems without memoization mimic the
%% input-output behaviour of the implementations with
%% memoization
Checking whether a given procedure is OP is undecidable. In this
paper, we propose a pair of static analysis techniques to check
OPness that are proved to be sound i.e they give a valid answer on
termination.

All arithmetic and logical operators are mathematical-functions, and
functional composition is closed under the set of
functions (hereonwards, we will refer to mathematical-functions as
functions and by procedure we mean a procedure in an imperative
programming language).  In the absence of global variables, all
procedures are a function of their formal arguments. This paper
focuses on checking if a procedure that reads and writes global
variables is OP.

\begin{lstlisting}[language=c, caption= {Procedure `factorial' :
      returns factorial of `n' and memoizes result for argument value
      `3'.}, label=lst:factorialSimple]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    return 1;
  } else if(g == -1 && n == 3) {
    g = 3 * factorial( 2 );
    return g;
  } else if(g != -1 && n == 3) {
    return g;
  } else {
    return n * factorial( n - 1 );
  }
}
\end{lstlisting}

Procedure `factorial' in Listing~\ref{lst:factorialSimple} mimics the
function $\lambda n. n!$. Procedure factorial caches results using the
global variable `g', for parameter value `n = 3'. Initially, `g = -1',
where `-1' represents the un-initialized value. At line 6, global
variable `g' is set to 3! iff `g' had the value `-1' at line
5. Next, line 9 is reached iff global variable `g' is not `-1',
implying that procedure `factorial' has been called with `n = 3'
previously. At line 9, the procedure correctly returns the value
`3!'. Other than this caching behaviour for `n=3' this is similar to
the standard implementation for `factorial'.


%% Listing~\ref{lst:factorialSimple} gives an implimentation of the
%% function factorial ($\lambda n.n!$) such that it caches the result for
%% the parameter `n' = 3. The global variable `g' is used as a cache and
%% is set to `-1', representing the uninitilized value.

%% At line 6,
%% global variable `g' is set to 3! only if `g' had the value `-1' at
%% line 5. Next, line 9 is reached only if global variable `g' is not
%% `-1', implying the procedure `factorial' has been called with `n = 3'
%% previously. At line 9, the procedure correctly returns the value
%% `3!'. Other than this caching behaviour for `n=3' this is similar to
%% the standard implimentation for `factorial'.
OPness is a property of a procedure and the set of \textit{reachable
  global states} where \textit{reachable global states} represents
the set of global states that are encountered in a sequence of
execution of the given procedure and a \textit{global state} is an
assignment to the global variables.  Procedure `factorial' in
Listing~\ref{lst:factorialSimple} is OP if the global state is
restricted to the set $\{\{g = -1\}, \{g = 3!\}\}$, it mimics the function
$\lambda n.n!$. But for the global states $\{\{g = 1\}, \{g = 3!\}\}$,
procedure `factorial' is not a mathematical function. For argument
value `$n = 3$' it may return `1' or `3!'.  We assume that the set of
reachable global states can be represented in the underlying logic and we refer
to it as \textit{invariant}.  The global states reachable at any
boundary, of any procedure call in a sequence of procedure calls
must satisfy the invariant.

%% The global states reachable at all the
%% boundaries of the given procedure in all executions must satisfy the
%% invariant.
%% Also
%% for all procedure calls, the global state at the beginning of, as well
%% as at the end of the procedure call must satisfy the invariant.

To check if a given procedure is OP, we ensure that for all reachable
global states, for each argument value, there is a unique result. Now,
this can be modelled using standard pre and post conditions. The pre
condition holds at the beginning of the procedure and the post
condition holds at its end. Both the pre condition and the post
condition can be substituted by the invariant $\inv$ ( in-order to
verify the invariant). This however does not constrain the return value of the
procedure. But, the return value from a recursive call may flow
into a global variable. Thus, the return from the procedure must be
modelled in the post condition; to re-establish $\inv$.  For procedure
`factorial' in Listing~\ref{lst:factorialSimple} we can use the
invariant `$\inv : g = -1 \vee g = 6$' and the function `factorial'
can be modelled as `$ f := k \leq 1 \implies \fact[k] = 1 \wedge k >1
\implies \fact[k] = \fact[k-1]*k$'. Thus, the pre-condition is
`$\inv$' and the post-condition is `$\inv \wedge f \wedge \retVar =
fact[n]$' where $\retVar$ is the return variable. This post-condition
will not only check the validity of the invariant but also that the
given procedure is OP, as the return value is constrained to be
equivalent to `$fact[n]$'.

The above mentioned idea is sound, modulo usability. The issues are:
(a) theorem provers often fail to prove such assertions (as is the
case for the above mentioned example) (b) describing the procedure in
logic takes considerable effort.  Instead of formalizing the function
for the given procedure, why not equate the result from the procedure
to that of an uninterpreted function symbol? This function symbol can
also be used to represent the return value from the inner procedure
calls. Next, we ask the question whether an assignment for the
function symbol exists? If yes, then the procedure is OP, otherwise it
is not OP.  This is our existential approach.
%% Now, this kind of a query is also hard for theorem provers. Later, we
%% show another technique that borrows from this idea, and is able to
%% prove procedures such as `factorial' in
%% Listing~\ref{lst:factorialSimple} to be OP.

Abstracting using function symbols goes a long way. It helps in
representing the post-condition in a simpler manner and also it aids
in describing the invariant.
%% also in describing the invariant on the global states.
%% The result from a recursive procedure call may flow to a global
%% variable. In such a case, the return from the recursive procedure call
%% needs to be evaluated to establish the post-condition. We propose, use
%% the same function symbol (as mentioned above) to represent the result
%% from a recursive procedure call (the same function symbol that was
%% equated to the result of the procedure).
For procedure `factorial', we can use the invariant `$\inv_{\F}:=g = -1
\vee g = \F(2) * 3$'. The symbol `$\F(2)$' in the invariant represents
the return value from the procedure `factorial' for argument `$n = 2$',
assuming procedure `factorial' is a mathematical function. Note that
the invariant used here is valid if the given procedure is OP,
otherwise it is not well defined.

%% should I talk about why F(2) *3 instead of F(3) ?

OPness can also be checked by comparing a procedure to itself. We
represent two instances of a procedure in some underlying logic, and
then ask the question that do the two instances of the given procedure
mimic each other, for all argument values, and all states satisfying
the invariant? If yes, then we show that the given procedure is
OP. Otherwise, we construct a witness to the impurity of the given
procedure. We can construct a pair of traces, such that both begin in
a global state in the invariant, the same argument value but return
different results. We call this the `impurity witness approach'.
%% Then, ask the question that does a
%% pair of traces exist such that both start with the same parameter but
%% return different results. We call this the impurity witness
%% approach
This approach also makes use of  invariant with uninterpreted function
symbols like the previous approach.

%% This invariant over the global variables, can optimistically
%% assume that the given procedure is observationally pure, this is a
%% trick we use. This trick allows us a way to generate the invariant and
%% also be certain that the invariant has saturated.

%% In static analysis, recursion is handled by either repeated inlining
%% or using pre and post conditions. The pre and post conditions are
%% constructed in a what that if the precondition holds before the
%% procedure call then the post condition holds after the procedure call,
%% for all procedure call. Only in-case of a recursive procedure call the
%% precondition is expected to hold at the beginning of the procedure and
%% the post condition is expected to hold at the end of the procedure. 
%% Capturing the meaning of the program in this mechanism requires that
%% the return of the procedure is also modelled in the same logic as used
%% to represent the pre and post conditions. Also, this return value is
%% generally a part of the post condition. We instead propose to
%% model the return value from the procedure as an uninterpreted
%% function; some mathematical function which we don't care to define. 

%% The semantics of the invariant we use is that (a) it is defined iff
%% the given procedure is a mathematical function (b) It represents all
%% the reachable global states before and after each procedure call. We
%% use this invariant to represent the pre-condition and the
%% post-condition. 

%% the invariant, which will substituted or the pre and the
%% post condition can be generated automatically. We Will present an
%% approach for constructing the invariant in Section~\ref{sec:invGen}.
  
%% Observationally purity seems to be closely related to termination of
%% the given procedure. It is certainly feasible that the given procedure
%% terminates for a given global state but not for another.

Since observational purity is a property on the return values from a
procedure, this problem is closely related with the termination of the
given procedure. In Section~\ref{sec:background}, we define OPness in
a way such that non-termination does not cause non-OPness. OP is
violated if for a given invariant on the reachable global states, for
a given argument value there is a non-unique return value. And in-case
of non-termination there isn't a return value. Hence, a
non-terminating procedure is OP.


%% Programmers on rely many library procedures to be mathematical
%% function. For instance, procedures like `sine' and `cos'.
One direct application of this work is automatic memoization. Dynamic
programming algorithms (such as procedure `factorial' in
Listing~\ref{lst:factorialSimple}) use memoization to store
pre-computed solutions to the sub-problem so that the results can be
looked-up when needed, thus trading memory for compute time. Our
technique can check if it is safe to memoize the results produced by a
procedure. By safety, we refer to preserving the input-output
behaviour. We propose two static analysis approaches to check this
problem. One interesting thing about our approach is that the user
need not mention a (the) mathematical function that the procedure is
supposed to mimic. Also, using a function symbol allows generating the
invariant automatically.

%% Now in our recipe for checking observational purity (a) we bypass
%% representing the meaning of the given procedure using a function
%% symbol (b) invariant, we give an approach to generate it automatically.

\section{Background} \label{sec:background}

\subsection{Programming Language}
We make the following restrictions on the structure of the program to
simplify the analysis without loss of generality.

\begin{itemize}
\item The given procedure (`\foo') has a single argument i.e `\n'. And
  `\n' is never written inside `\foo'.
\item Procedure `\foo' has a single global variable, named `\g'.
\item Return statement is absent from our programming language. Instead,
  we have a special variable `\retVar', which is assigned the return
  value.
\item We analyze a single procedure in isolation and we assume that no
  other procedure writes to the global variables accessed by procedure
  `\foo'. An invariant on the global states can make use of multiple
  function symobls, a function symbol for each procedure in
  general. But for simplicity, we assume a single procedure world.
\item All variable are defined before use, except global variables.
\item All loops in procedure `\foo' are substituted with 
  recursive procedures.
\item Variable assigned the return value in a procedure call
  statement is always a local variable.
\end{itemize}
%% Note : all of the above mentioned restrictions can be omitted. They
%% are for convenience.

In Figure~\ref{fig:grammar}, we present the grammar for the
programming language which we have assumed for our static analysis
approaches.  Most of the statements are standard statements borrowed
from imperative languages. The rest of them are explained next. The
statement `havoc x' assigns any value from the domain of the variable
`x' to variable `x'.
%% to variable `x' from the declared domain of `x'
And the statement `assume x' allows the execution of the program to
proceed if the predicate `x' holds at the program point, otherwise it
halts the execution.

\begin{figure}[hb!]
  %% \includegraphics[trim={0 5cm  3cm 0}, width=6cm]{grammar.eps}
  \begin{grammar}
    <statement> ::= <ident> = <constant>
    \alt <ident> = <logical-expr>
    \alt <ident> = <arithmetic-expr>
    \alt <statement>; <statement>
    %% \alt if<logical-expr> then <statement> else <statement>
    %% \alt while<logical-expr> do <statement>
    \alt <ident> = foo(<params-list>)
    \alt assume(<logical-expr>)
    \alt <ident> = \foo(<ident>)
    \alt havoc(<ident>)
    %% \alt <ident>[<ident>] = <ident>
    %% \alt <ident> = <ident>[<ident>]

    %% <params-list> ::= <params-list> , <ident>
    %% \alt <ident>

    <arithmetic-expr> ::= <ident> "+" <ident>
    \alt <ident> "-" <ident>
    \alt <ident> "/" <ident>
    \alt <ident> "*" <ident>
    \alt <ident> "\%" <ident>
 
    <logical-expr> ::= <ident> "<" <ident>
    \alt <ident> ">" <ident>
    \alt <ident> "==" <ident>
    \alt <ident> $\leq$ <ident>
    \alt <ident> $\geq$ <ident>
    \alt <logical-expr> $\wedge$ <logical-expr>
    \alt <logical-expr> $\vee$ <logical-expr>
    \alt $\neg$<logical-expr>
    \alt true
    \alt false

    <ident> ::= <local-ident>
    \alt <global-ident>
    
    <procedure> ::= procedure \foo ($\n$) {<statement>;}
  \end{grammar}
  \caption{Grammar for our programming language}
  \label{fig:grammar}
\end{figure}

\subsection{Our intermediate representation}\label{sec:intermediate}
We transform the given procedure into the following representation
in-order to represent it in logic.
%% to
%% be able to represent it in logic.
For example procedure `factorial' in
Listing~\ref{lst:factorialTransformed}, is the transformed version of
procedure `factorial' in Listing~\ref{lst:factorialSimple}.

Our analysis expects the following :
\begin{enumerate}
\item Expressions do not have procedure call statements as
  sub-expressions. 
  %% If
  %% so, partition it into multiple statements.
\item Procedure calls are approximated using function symbols. The
  statement `x = \foo(y)' is replaced with `x = $\F$(y)'. Since
  procedure calls may modify global variables, we add the statement
  `havoc g' for each global variable `g' accessible from the
  procedure.
  
  %% A
  %% procedure call may modify global variables, thus we add the
  %% statement `havoc g' for all global variables `g' accessible from the
  %% procedure.
%% \item Continuation of above, recursive calls may modify global
%%   variables. Also, the variable assigned the return value from the
%%   procedure call gets modified. Procedure calls must be
%%   over-approximated using `havoc' statements. i.e `x = \foo(y)' is
%%   replaced with `havoc x' followed by `havoc g' where `g' is a
%%   global variable accessed by the given procedure.
%% \item 
%%   We add the statement `assume x = $\F$(y)' after the statement
%%   `havoc(x)'.
\item Next, the procedure must have extra variables to store the value
  of global variables at procedure boundaries.
  %% we add extra variables to store the value of the global
  %% variables at the procedure boundaries.
  Before the $\mathit{i^{th}}$
  procedure call, we add the statement `gbef$_i$ = g' and after it we
  add `gaft$_i$ = g'. Similarly, we add the statement `gout = g'
  after the assignment to the variable `\retVar'.
\item The procedure should be in SSA form. The procedure should be
  converted to SSA after the above mentioned points have been
  satisfied.
\end{enumerate}

\begin{lstlisting}[language=c, caption= {Procedure `factorial' from
      Listing~\ref{lst:factorialSimple} converted to the form our
      approach expects. We refer to this procedure as `transformed
      factorial'.}, label=lst:factorialTransformed]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    retVar = 1;
    gout = g;
  } else if(g == -1 && n == 19) {
    gbef1 = g;
    temp1 = F(18);  // temp1 = factorial(18)
    havoc(g1);
    gaft1 = g1;
    g2 = 19 * temp1;
    retVar = g2;
    gout = g2;
  } else if(g != -1 && n == 19) {
    retVar = g;
    gout = g;
  } else {
    gbef2 = g;
    temp2 = F( n - 1 );  //temp2 = factorial(n-1)
    havoc(g1);    
    gaft2 = g1;
    retVar = n * temp2;
    gout = g1;
  }
}
\end{lstlisting}

%% In procedure `transformed factorial'
%% Listing~\ref{lst:factorialTransformed}, in comparison to procedure
%% `factorial' in Listing~\ref{lst:factorialSimple}, the return statement
%% (line 4) is replaced by an assignment to variable `\retVar' (line
%% 4). After line 5 of `transformed factorial', an extra variable `gout'
%% is assigned the value of global variable `g' (value of `g' at end of
%% program).  Similarly, variable `gbef1' (line 7, `transformed
%% factorial') is added to capture the value of the global variable
%% before the procedure call (a program boundary), and variable `gaft1'
%% is inserted at line 11 to capture the value of `g' after the procedure
%% call. Also, havoc statements at line 8, 20 and 9, 21 over-approximate
%% the return from the procedure call statement and updates to the global
%% variable respectively. The procedure call statement is substituted
%% with function symbols in line 10 and 22, accounting the given
%% procedure as a function.

Now comparing procedure `transformed factorial' and procedure
`factorial' from Listings~\ref{lst:factorialTransformed} and
\ref{lst:factorialSimple} respectively. The return statement (line 4)
in procedure `factorial' is replaced by assignment to variable
`\retVar' (line 4). Also, we have an added statement (line 5) in
`transformed factorial', an assignment statement to `gout'; in-order to
store the value of variable `g' at the procedure boundary. Similarly,
variable `gbef1' (line 7) is added in `transformed factorial' to
capture the value of the global variable before the procedure call and
assignment to variable `gaft1' is inserted at line 11 to capture the
value of `g' after the procedure call. Also, havoc statements at line
9 and 20 over-approximate any side effects to the global
variables. And in lines 8 and 19, the procedure call statements are
substituted for function symbols.

\subsection{Path Condition}
For our analysis we represent the given procedure in logic, such that
it captures the value of the argument, the return value and the values
of the global variables at the boundaries. We track the values of the
global variables using extra variables as explained in
Section~\ref{sec:intermediate}.

\begin{figure}
  \begin{align*}
    \pathCondition :=
    &(n \leq 1 \wedge retVar = 1 \wedge gout = g) \vee \\
    &(n > 1 \wedge g = -1 = gbef \wedge n = 19 \wedge temp1 = \F(18) \\
    &\wedge gaft1 = g1 \wedge g2 = 19 * temp1
    \wedge retVar = g2) \vee\\
    &(n > 1 \wedge \neg( g = -1 \wedge n = 19) \wedge g \neq -1
    \wedge n = 19 \wedge retVar = g = gout) \vee\\
    &(n > 1 \wedge n \neq 19 \wedge gbef2 = g \wedge temp2 = \F( n
    - 1) \wedge gaft2 = g1\\
    &\wedge retVar = n * temp2 \wedge gout = g1)\\
  \end{align*}
  \caption{Formula representing procedure `factorial' in
    Listing~\ref{lst:factorialTransformed} (assuming that function
    $\F$ is equivalent to procedure `factorial').}
  \label{fig:pathCondition}
\end{figure}

In Figure~\ref{fig:pathCondition}, each disjunct represents a
straight-line execution of procedure `factorial' (from beginning,
until end) . For instance, $(n <= 1
\wedge retVar = 1 \wedge gout = g)$ represents the case where $n \leq
1$. Here onwards, we will only use this formula, $\pathCondition$ to
describe our analysis.



Representation of a program in logic is straight forward once it is
converted to our intermediate representation in
Section~\ref{sec:intermediate}. All the standard imperative statements
become conjuncts in the formula. `havoc' statements are omitted.
`assume x' are replaced with a conjunct `x' in the formula.

\section{Invariant}

To introduce the definition of an invariant we first define trace and
history.

\begin{definition}[trace]
  A trace $\trace$ is a complete execution of the procedure starting
  from a given global state and a tuple of formal arguments. A trace
  upon completion gives an end state and a return value.\\ 
 Traces may have sub-traces, which by definition are traces
  (recursive calls).
\end{definition}

\begin{definition}[history]
  A history $\history$ is a sequence of consecutive traces, with the
  first trace starting from a given global state, and each subsequent
  trace begins in the state in which the previous trace ends.
\end{definition}

\begin{definition}[invariant]
  An invariant $\inv$ represents the set of global states at the
  boundaries of a procedure. $\inv$ is a formula, with 
  global variables accessed by the given procedure and a uninterpreted
  function symbol $\F$ as the set of free variables.
  %% If a procedure begins in state that satisfies $\inv$, then it ends
  %% in a state that satisfies $\inv$.
  The uninterpreted function symbol $\F$ is a placeholder for the
  mathematical function equivalent to the given procedure.
  

  %% An invariant $\inv$ is a formula with an uniterpreted function
  %% symbol $\F$ and the global variables accessed by the given procedure
  %% as free variables.
  
  %% Similar to requires and ensures clauses, $\inv$ holds before a
  %% procedure call and it is assumed after the procedure call.
  
  %% %% It represents the set of global states that may
  %% %% arise before and after each procedure call of the given procedure in
  %% %% a set of histories. Thus, if a procedure begins in a global state
  %% %% that satisfies invariant $\inv$ then the state before the procedure
  %% %% call also satisfies $\inv$.
  %% %% Also, assuming the inner recursive call
  %% %% ends in a state statisfying $\inv$, the global state at the end of
  %% %% the procedure also satisfies $\inv$.
  %% %% it also ends in a global state that
  %% %% satisfies $\inv$.
  %% Some variables may be defined in terms of a
  %% function symbol $\F$, which in turn refers to the mathematical
  %% function that is equivalent to the given procedure.
  
\end{definition}

Similar to requires and ensures, an invariant $\inv$ is assumed at the
beginning of a procedure and ensured at the end. Also, ensured before
a procedure call and assumed after the procedure call. Invariant
$\inv$ abstracts the procedure calls as function symbols. Thus,
invariant is defined only if the given procedure mimics a function
otherwise it is undefined.
%% assumes that the given procedure is a mathematical function
%% and is undefined otherwise.

Let $\gstate$ be a global state, and $\F'$ be a function, and $\inv$
be a invariant. If we substitute $\gstate$ for $g$ and $\F'$ for $\F$
in $\inv$, if $\inv[\gstate/g, \F'/\F]$ is true then, we say
$(\gstate, \F') \satisfies \inv$. For instance let $\inv := g = -1
\vee g = \F(18) * 3$ then $(3!, \lambda n. n!) \satisfies \inv$.

%% A procedure is OP only for a given
%% set of reachable global states. So, if procedure $\foo$ is OP for
%% invariant $\inv$ it will also be OP for $\inv'$ where $\inv' \implies
%% \inv$ but $\inv'$ be not be inductive. But the procedure may not be OP
%% for $\inv''$ where $\inv'' \implies \inv$.

\section{Observational purity}
\begin{definition}[observational purity(invariant $\inv$)]
 A given set of procedures are observationally pure if in each history
 starting from a state in invariant $\inv$, all traces of each
 procedure with the same argument value return the same result.
\end{definition}

\begin{lstlisting}[caption={Procedure `remember' : always returns the
      argument from its first call}, label=lst:remember]
int g = 0;
int init = 0;
int remember( int n) {
  if(init = 0){
    init = 1;
    g = n;
  }
  return g;
}
\end{lstlisting}


In a history, if all traces return the same result for an
argument value, then we can find a function $\F$ that respects the
given procedure. But, the given procedure may mimic a different
function $\F'$ in another history. If the invariant is set of concrete
states then there is a unique function that is equivalent to the given
procedure. But, our invariant allows function symbols. This allows an
OP procedure to mimic different functions in different histories.
%% The invariant we use allows multiple functions to
%% be equivalent to the given procedure.
For instance, procedure `remember' in Listing~\ref{lst:remember}
mimics a constant function for $\inv := g=0 \wedge init=0 \vee g= \F()
\wedge init=1$. Whereas, for the invariant $\inv := g=0 \wedge init=0
\vee g=2 \wedge init=1$; the procedure mimics the function $\lambda
n.2$.

\section{Existential approach}\label{sec:existential}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckE
       & \mi{(\inv :
        invariant, \pathCondition : path \; condition)} \equiv \\
      &\inv \wedge \inv[\gaft_1/\g] \wedge \inv[\gaft_2/\g] \wedge
      \cdots \inv[\gaft_m/\g] \\
      &\wedge \pathCondition \implies ( \retVar = \F(\n)\\
            & \wedge \inv[\gout/\g] \wedge  \inv[\gbef_1/\g] \wedge
      \inv[\gbef_2/\g] \wedge \cdots inv[\gbef_m/\g]) \\
    \end{align*}
    \caption{Existential check : produces a formula whose
      satisfiability implies the given procedure is observationally
      pure} 
    \label{algo:someOPcheckCombined}
  \end{algorithm}  
\end{figure}


The existential approach in Figure~\ref{algo:someOPcheckCombined}
encodes a formula $\formula_e$. In formula $\formula_e$, the invariant
is assumed at the beginning of the procedure, and after each procedure
call ( $m$ procedure calls in total).  We abstract all the recursive
procedure calls in the original procedure using function symbol $\F$
in $\pathCondition$.  Next, the return value is constrained to be
equivalent to $\F(n)$, where `n' is the parameter value. Formula
$\formula_e$ has a single free variable, $\F$ and it is
constrained to respect the given procedure,
%% equivalent to
%% the return value,
%% from the procedure
for all values of the parameter
`n' and all values of the global variable `g'.
Thus, if $\formula_e$ is SAT, it implies that there exists a function
which mimics the given procedure.

The check encoded in Figure~\ref{algo:someOPcheckCombined} cannot be
expressed using standard requires and ensures statements (to the best
of our knowledge). In the intra-procedural analysis, the validity of
the ensures statements is verified. We ensure that if the procedure
has an `ensures x' statement, then the state $\neg$x is not reachable
at the program point.
%% The statements `ensures x' and
%% `requires y' are replaced by `assert x' and `assumes y'
%% respectively. Next, the assume and assert statements along with the
%% program are converted to a formula; checking if there the state
%% $\neg$x is reachable at the assert statement.
In our analysis, we check
a weaker condition. We check if $\retVar = \F(n)$ is reachable. But
this suffices for our analysis.

%% In standard assertin checking, we check if there is a path in the
%% program such that a state in $\neg$x is reachable for the statement
%% `assert x'. Whereas in the existential check, we just check if there
%% is a satisfying function for the respective formula. 
\section{Impurity witness approach}\label{sec:impurityWitness}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckA &\mi{(\inv : invariant,
        \pathCondition: path\; condition)} \equiv &\\
      &\inv[\g_\alpha/\g] \wedge \inv[\g_\beta/\g]  & (1)\\
      & \wedge \inv[\gaft_{\alpha1}/\g] \wedge
      \inv[\gaft_{\alpha2}/\g] \cdots \wedge \inv[\gaft_{\alpha m}/\g]
      & (2)\\
      & \wedge \inv[\gaft_{\beta1}/\g] \wedge \inv[\gaft_{\beta2}/\g]
      \cdots \wedge \inv[\gaft_{\beta m}/\g] & (3)\\
      &\wedge \n_\alpha = \n_\beta  & (4)\\
      &\wedge \pathCondition[\g_\alpha/\g, \n_\alpha/\n, \retVar_\alpha/\retVar,
        \gout_\alpha/\gout, & (5)\\
        &\gbef_{\alpha1}/\gbef_1 \cdots, \gaft_{\alpha 1}/\gaft_1, \cdots
        \gaft_{\alpha m}/\gaft_m]  & (6)\\
      &\wedge \pathCondition[\g_\beta/\g, \n_\beta/\n, \retVar_\beta/\retVar,
        \gout_\beta/\gout, & (7)\\
        &\gbef_{\beta1}/\gbef_1 \cdots, \gaft_{\beta 1}/\gaft_1, \cdots
        \gaft_{\beta m}/\gaft_m] & (8)\\
      &\wedge (\retVar_\alpha \neq \retVar_\beta \vee \neg\inv[\gbef_{\alpha1}/\g] \vee
       \cdots \neg\inv[\gbef_{\alpha m}/\g] & (9) \\
        &\vee \neg\inv[\gout_\alpha/\g])  & (10)\\
    \end{align*}
    \caption{Impurity witness : produces a formula whose unsatisfiability
    implies observational purity.}
    \label{algo:pairwiseOPcheckCombined}
  \end{algorithm}  
\end{figure}

The impurity witness approach in
Figure~\ref{algo:pairwiseOPcheckCombined} encodes a formula
$\formula_{iw}$. If $\formula_{iw}$ is UNSAT the given procedure is
OP. The idea encoded in $\formula_{iw}$ is that if a pair of traces of
the given procedure exists such that the traces start with the same
parameter value, and potentially different values for the global
variables return different results, then the procedure is not OP. In
this case, we have a witness to the non-OPness of the given
procedure. Otherwise, we prove that the given procedure is OP.

The check encoded in Figure~\ref{algo:pairwiseOPcheckCombined}, cannot
be expressed in standard requires and ensures (again, to the best of
our knowledge). As the approach compares the given procedure with
itself, standard requires and ensures do not suffice. But works such as
\cite{lahiri2013differential} can be extended to express this. 


\section{Comparing the two approaches}

\begin{lstlisting}[caption={Procedure `bar': illustrates that
      existential approach is more precise that the impurity witness
      approach.}, label=lst:comparison]
int bar(int n) { 
  return g; 
}
\end{lstlisting}

The existential approach in Section~\ref{sec:existential} is more
precise than the impurity witness approach in
Section~\ref{sec:impurityWitness}. Existential approach is an
optimistic whereas the impurity witness is a pessimistic approach. For
instance in procedure `bar' in Listing~\ref{lst:comparison}, is
observationally pure for the invariant $(g = \F(0) \vee g = \F(1))$
and it mimics the mathematical function $\forall n. \F(0) = \F(1) =
\F(n)$ (thus, it must be a a constant function). Now, the existential
approach marks this procedure as OP whereas the impurity witness
approach marks it as non-OP.

Al thought the existential approach is more precise, the impurity
witness approach performs better with SAT-SMT solvers. In case of the
existential approach the solver has to find a satisfying assignment
for the free variable $\F$. Whereas, in case of the impurity witness
approach, the inequivalence is contradicted (if procedure is OP) using
FOL with interpreted functions.

\section{Experimental Results}

\section{Conclusion}
\subsection{Related work}
JML does not allow any side-effects for Library procedures, thus
specifiers use pure replacements instead. Barnett defines
Observational purity~\cite{barnett200499} but their work cannot prove
self recursive procedures to be OP and also need user
annotations. They use a information flow based technique to prove OP
of procedures.

The idea of comparing a program to itself~\cite{lahiri2013differential},
\cite{partush2013abstract} is closely related to the impurity witness
approach. DAC~\cite{lahiri2013differential} uses this idea for
finding the assertions that failed in a version of a program with
respect to another version. Whereas, Partush and
Yahav~\cite{partush2013abstract} focus on finding the parameter values
for which the two versions of the procedure differ.

Naumann~\cite{naumann2007observational} calls a procedure OP if it is
output-equivalent to a procedure which is a side-effect free. And
side-effect-freeness does not entail OPness. This works present/use
a theory for simulations, closely related to ownership types. Thus
this work is closely related but they solve a different problem.

Cok~\cite{cok2008extensions} builds upon Barnett's
work~\cite{barnett2006allowing} and~\cite{barnett200499} suggests
partitioning the set of methods into ``pure'', ``secret'' and ``query''
methods, each scoped to a particular data group. The query methods are
OP. They give a set of rules to be followed by methods in each
group. Thus, structuring for modular reasoning about OPness.

Finifter~\cite{cok2008extensions} takes a different approach of restricting
the programming language in order to make OP checking simpler. In the
restricted language called Joe-E, OP methods have all objects reachable
from the parameters marked as immutable
\subsection{Future work}

%

%
% ---- Bibliography ----
%
%% \bibliographystyle{plainnat}
\bibliographystyle{splncs}
\bibliography{references}
%% \begin{thebibliography}{5}

%% \bibitem {clar:eke}
%% Clarke, F., a, I.:
%% Nonlinear oscillations and
%% boundary-value problems for Hamiltonian systems.
%% Arch. Rat. a. Anal. 78, 315--333 (1982)


%% \end{thebibliography}

\end{document}
