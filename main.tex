% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
%% himanshu
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{syntax}
\newcommand{\foo}{\textit{foo}}
\newcommand{\trace}{\pi}
\newcommand{\inv}{\mathit{inv}}
\newcommand{\history}{\Pi}
\newcommand{\pathCondition}{\mathit{T_{\foo}}}
\newcommand{\OPCheckE}{\mathit{OPCheck \mhyphen existential}}
\newcommand{\OPCheckA}{\mathit{OPCheck \mhyphen pairwise}}
\mathchardef \mhyphen="2D
\newcommand{\mi}[1]{\mathit{#1}}
\newcommand{\retVar}{\textit{retVar}}
\newcommand{\F}{\mathit{F}}
\newcommand{\n}{\textit{n}}
\newcommand{\gstate}{\gamma}
\newcommand{\g}{\textit{g}}
\newcommand{\gout}{\textit{gout}}
\newcommand{\gbef}{\textit{gbef}}
\newcommand{\gaft}{\textit{gaft}}
\newcommand{\satisfies}{\vdash}
\newcommand{\fact}{\mathit{fact}}


\lstdefinestyle{mystyle}{
  basicstyle=\footnotesize, 
  %% breakatwhitespace=false,         
  %% breaklines=true,                 
  captionpos=b,
  %% keepspaces=true,         
  numbers=left,
  numbersep=6pt,                  
  %% showspaces=false,                
  %% showstringspaces=false,
  %% showtabs=false,
  morekeywords={if, for, else,
  procedure,modifies, var, returns, int, call, assume},
  %% tabsize=2
}
\lstset{
  %% basicstyle=\itshape,
  style = mystyle,
  xleftmargin=3em,
  %% literate={\alt}{;}{1}
  %% basicstyle=\footnotesize,
  numberstyle=\tiny,
  breaklines=true,
  escapeinside={\%*}{*)}
}

%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
%% \chapter*{Preface}
%% %
%% This textbook is intended for use by students of physics, physical
%% chemistry, and theoretical chemistry. The reader is presumed to have a
%% basic knowledge of atomic and quantum physics at the level provided, for
%% example, by the first few chapters in our book {\it The Physics of Atoms
%% and Quanta}. The student of physics will find here material which should
%% be included in the basic education of every physicist. This book should
%% furthermore allow students to acquire an appreciation of the breadth and
%% variety within the field of molecular physics and its future as a
%% fascinating area of research.

%% For the student of chemistry, the concepts introduced in this book will
%% provide a theoretical framework for that entire field of study. With the
%% help of these concepts, it is at least in principle possible to reduce
%% the enormous body of empirical chemical knowledge to a few basic
%% principles: those of quantum mechanics. In addition, modern physical
%% methods whose fundamentals are introduced here are becoming increasingly
%% important in chemistry and now represent indispensable tools for the
%% chemist. As examples, we might mention the structural analysis of
%% complex organic compounds, spectroscopic investigation of very rapid
%% reaction processes or, as a practical application, the remote detection
%% of pollutants in the air.

%% \vspace{1cm}
%% \begin{flushright}\noindent
%% April 1995\hfill Walter Olthoff\\
%% Program Chair\\
%% ECOOP'95
%% \end{flushright}
%% %
%% \chapter*{Organization}
%% ECOOP'95 is organized by the department of Computer Science, Univeristy
%% of \AA rhus and AITO (association Internationa pour les Technologie
%% Object) in cooperation with ACM/SIGPLAN.
%% %
%% \section*{Executive Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \section*{Program Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \begin{multicols}{3}[\section*{Referees}]
%% V.~Andreev\\
%% B\"arwolff\\
%% E.~Barrelet\\
%% H.P.~Beck\\
%% G.~Bernardi\\
%% E.~Binder\\
%% P.C.~Bosetti\\
%% Braunschweig\\
%% F.W.~B\"usser\\
%% T.~Carli\\
%% A.B.~Clegg\\
%% G.~Cozzika\\
%% S.~Dagoret\\
%% Del~Buono\\
%% P.~Dingus\\
%% H.~Duhm\\
%% J.~Ebert\\
%% S.~Eichenberger\\
%% R.J.~Ellison\\
%% Feltesse\\
%% W.~Flauger\\
%% A.~Fomenko\\
%% G.~Franke\\
%% J.~Garvey\\
%% M.~Gennis\\
%% L.~Goerlich\\
%% P.~Goritchev\\
%% H.~Greif\\
%% E.M.~Hanlon\\
%% R.~Haydar\\
%% R.C.W.~Henderso\\
%% P.~Hill\\
%% H.~Hufnagel\\
%% A.~Jacholkowska\\
%% Johannsen\\
%% S.~Kasarian\\
%% I.R.~Kenyon\\
%% C.~Kleinwort\\
%% T.~K\"ohler\\
%% S.D.~Kolya\\
%% P.~Kostka\\
%% U.~Kr\"uger\\
%% J.~Kurzh\"ofer\\
%% M.P.J.~Landon\\
%% A.~Lebedev\\
%% Ch.~Ley\\
%% F.~Linsel\\
%% H.~Lohmand\\
%% Martin\\
%% S.~Masson\\
%% K.~Meier\\
%% C.A.~Meyer\\
%% S.~Mikocki\\
%% J.V.~Morris\\
%% B.~Naroska\\
%% Nguyen\\
%% U.~Obrock\\
%% G.D.~Patel\\
%% Ch.~Pichler\\
%% S.~Prell\\
%% F.~Raupach\\
%% V.~Riech\\
%% P.~Robmann\\
%% N.~Sahlmann\\
%% P.~Schleper\\
%% Sch\"oning\\
%% B.~Schwab\\
%% A.~Semenov\\
%% G.~Siegmon\\
%% J.R.~Smith\\
%% M.~Steenbock\\
%% U.~Straumann\\
%% C.~Thiebaux\\
%% P.~Van~Esch\\
%% from Yerevan Ph\\
%% L.R.~West\\
%% G.-G.~Winter\\
%% T.P.~Yiou\\
%% M.~Zimmer\end{multicols}
%% %
%% \section*{Sponsoring Institutions}
%% %
%% Bernauer-Budiman Inc., Reading, Mass.\\
%% The Hofmann-International Company, San Louis Obispo, Cal.\\
%% Kramer Industries, Heidelberg, Germany
%% %
%% \tableofcontents
%% %
\mainmatter              % start of the contributions
%
\title{Checking Observational Purity}
%
\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
%% \author{Ivar Ekeland\inst{1}\orcidID{0000-1111-2222-3333} \and
%% Roger~Temam\inst{2}\orcidID{1111-2222-3333-4444} \and
%% Jeffrey~Dean\orcidID{2222-3333-4444-5555} \and
%% David~Grove\orcidID{3333-4444-5555-6666} \and
%% Craig~Chambers\orcidID{4444-5555-6666-7777} \and
%% Kim~B.~Bruce\orcidID{5555-6666-7777-8888} \and
%% Elsa~Bertino\orcidID{6666-7777-8888-9999}}
%% %
%% \authorrunning{Ivar Ekeland et al.} % abbreviated author list (for running head)
%% %
%% %%%% list of authors for the TOC (use if author list has to be modified)
%% \tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%% Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%% %
%% \institute{Princeton University, Princeton NJ 08544, USA,\\
%% \email{I.Ekeland@princeton.edu},\\ WWW home page:
%% \texttt{http://users/\homedir iekeland/web/welcome.html}
%% \and
%% Universit\'{e} de Paris-Sud,
%% Laboratoire d'Analyse Num\'{e}rique, B\^{a}timent 425,\\
%% F-91405 Orsay Cedex, France}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The abstract should summarize the contents of the paper
using at least 70 and at most 150 words. It will be set in 9-point
font size and be inset 1.0 cm from the right and left margins.
There will be two blank lines before and after the Abstract. \dots
\keywords{static analysis, Program analysis }
\end{abstract}

\section{Introduction}
Verifying function properties of procedures is a hard task. 
Formalizing the function properties of a procedure entails
deep understanding of the expected functionality of
a procedure. 
%% Defining the correctness for a procedure is a time consuming task that
%% requires deep understanding of the expected functionality of a
%% procedure.
In this paper, we talk about a general property that is the necessary
condition for the correctness of many procedures. If the return value
from a procedure is dependent only on the formal arguments, the given
procedure is \textit{Observationally pure(OP)}.
%% Thus, OP procedures return equivalent to a mathematical
%% function of the argument values; independent of the value of the
%% global variables.
%% Essentially, we ensure
Ensuring the existence of a mathematical function that
mimics the given procedure and shares it's signature. Implying that
the input-output behaviour of the given procedure is independent of
any global state. This is a general property that has many
applications. 
For instance, implementations of dynamic programming problems without
the memoization would mimic the input output behaviour of the optimal
implementations. Checking whether a given procedure is OP, is
undecidable. In this paper, we propose a pair of static analysis
techniques to check OPness that are sound but incomplete.

Since all logical and arithmetic operators are mathematical functions,
their composition is also a mathematical function (function). Hence,
in the absence of global variables, all procedures are a function of
their formal arguments. This paper focuses on checking if a procedure
that access global variables is OP. 

Procedure `factorial' in Listing~\ref{lst:factorialSimple} is OP for a
certain set of global states. If the global state is restricted to the
set $\{g = -1, g = 3!\}$, procedure `factorial' mimics $\lambda n.n!$
which is a function. But for the global states $\{g =1, g = 3!\}$,
procedure `factorial' is not a mathematical function. For argument
value `$n = 3$' it may return 1 or 3!, thus for this set of global
states it is not OP.  We assume that this set of global states can be
represented in the underlying logic and we refer to it as
\textit{invariant}. Also for all procedure calls, the global state at
the beginning of, as well as at the end of the procedure call must
satisfy the invariant.

In order to prove that a given procedure is OP, we prove that for all
reachable global states, for each argument value there is a single
result. Now, this can be modelled using standard pre and post
conditions. The pre condition holds at the beginning of the procedure
and the post condition holds at its end. Both the pre condition and
the post condition can be substituted by the invariant. But this does
not constrain the return value of the procedure. And the return value from
an inner recursive call might flow into a global variable. Thus,
the return from the procedure must be modelled in the post condition.
For procedure `factorial' in Listing~\ref{lst:factorialSimple}
we can use the invariant `$\inv : g = -1 \vee g = 6$' and the function
`factorial' can be modelled as `$\fact[k] == 1 \wedge k >1 ==> \fact[k]
== \fact[k-1]*k$'. Thus, the pre-condition is `$\inv$' and the
post-condition is `$\inv \wedge \fact[k] == 1 \wedge k >1 ==> \fact[k]
== \fact[k-1]*k$'.

The above mentioned idea is valid. But it has certain issues (a)
theorem provers often fail to prove such assertions (as is the case
for the above mentioned example) (b) describing the procedure in logic
takes considerable effort. We propose, instead of trying to describe
the function for the given procedure, we equate the result from the
procedure to that of an uninterpreted function symbol. And then ask
the question whether an assignment for the function symbol exists? If
yes, then the procedure is OP. We call this the existential approach.
%% Now, this kind of a query is also hard for theorem provers.  Later, we
%% show another technique that borrows from this idea, and is able to
%% prove procedures such as `factorial' in
%% Listing~\ref{lst:factorialSimple} to be OP.

This idea of abstracting using a mathematical function symbol also
comes in handy for defining the invariant on the global states. The
result from a recursive procedure call may flow to a global
variable. In such a case, the return from the recursive procedure call
needs to be evaluated to establish the post-condition. We propose, use
the same function symbol (as mentioned above) to represent the result
from a recursive procedure call (the same function symbol that
was equated to the result of the procedure). For procedure `factorial'
we can use the invariant `$\inv_{\F} : g = -1 \vee g = \F(2) *
3$'. The symbol `$\F(2)$' in the invariant represents the return value
from the procedure `factorial' assuming it is a mathematical
function. The invariant used here is valid iff the given procedure is
OP, otherwise it is not well defined.

%% should I talk about why F(2) *3 instead of F(3)

Another technique is represent two instances of a procedure in some
underlying logic. Then, ask the question that does a pair of traces
exist such that both start with the same parameter but return
different results. We call this the impurity witness approach. This
approach also uses invariant that makes use of uninterpreted function
symbols. 

%% This invariant over the global variables, can optimistically
%% assume that the given procedure is observationally pure, this is a
%% trick we use. This trick allows us a way to generate the invariant and
%% also be certain that the invariant has saturated.

%% In static analysis, recursion is handled by either repeated inlining
%% or using pre and post conditions. The pre and post conditions are
%% constructed in a what that if the precondition holds before the
%% procedure call then the post condition holds after the procedure call,
%% for all procedure call. Only in-case of a recursive procedure call the
%% precondition is expected to hold at the beginning of the procedure and
%% the post condition is expected to hold at the end of the procedure. 
%% Capturing the meaning of the program in this mechanism requires that
%% the return of the procedure is also modelled in the same logic as used
%% to represent the pre and post conditions. Also, this return value is
%% generally a part of the post condition. We instead propose to
%% model the return value from the procedure as an uninterpreted
%% function; some mathematical function which we don't care to define. 

%% The semantics of the invariant we use is that (a) it is defined iff
%% the given procedure is a mathematical function (b) It represents all
%% the reachable global states before and after each procedure call. We
%% use this invariant to represent the pre-condition and the
%% post-condition. 

Now in our recipe for checking observational purity (a) representing the
meaning of the given procedure can be bypassed using a function symbol
(b) the invariant, which will substituted or the pre and the post
condition can be generated automatically. We Will present an approach
for constructing the invariant.
  
%% Observationally purity seems to be closely related to termination of
%% the given procedure. It is certainly feasible that the given procedure
%% terminates for a given global state but not for another.

Since observational purity is a property on the return values from a
procedure, this property is intertwined with termination. In
Section~\ref{sec:background}, we define OPness in a way such that
non-termination does not cause non-OPness. OP is violated only if for
a given invariant on the reachable global states, for a given argument
value there is a non-unique return value.

%% Thus, there must exist a
%% pair of traces such that both the traces begin a global state that is
%% satisfied by the invariant, and both traces begin with the same
%% argument value but return different results.


\begin{lstlisting}[language=c, caption= {Procedure `factorial' :
      returns factorial of `n' and memoizes result for argument value
      `3'.}, label=lst:factorialSimple]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    return 1;
  } else if(g == -1 && n == 3) {
    g = 3 * factorial( 2 );
    return g;
  } else if(g != -1 && n == 3) {
    return g;
  } else {
    return n * factorial( n - 1 );
  }
}
\end{lstlisting}

%% Programmers on rely many library procedures to be mathematical
%% function. For instance, procedures like `sine' and `cos'.

Dynamic programming algorithms (such as procedure `factorial' in
Listing~\ref{lst:factorialSimple}) use memoization to store
pre-computed solutions to the sub-problem so that it can look-up the
solution when needed, thus trading compute time for storage. Our
technique can check if it is safe to memoize the results produced by a
procedure. By safety we mean assurance that the procedure will produce
the same result it returned earlier. We propose two static analysis
approaches to check this problem. The property we check is whether the
given procedure's behavior is equivalent to some mathematical
function. One interesting thing about our approach is that the user
need not mention a (the) mathematical function that the procedure is
supposed to mimic.


\section{Background} \label{sec:background}
This section first gives the definition of Observational purity. Next,
we present some formalisms that we use define the approaches.

\subsection{Programming Language}
We make the following restrictions on the structure of the program for
the sake of simplicity of the analysis.

\begin{itemize}
\item The given procedure (`\foo') has a single argument i.e `\n'. And
  `\n' is never written inside `\foo'.
\item Procedure `\foo' has a single global variable name `\g'.
\item Procedure `\foo' has a special variable `\retVar' which is
  assigned the return value.
\item We are only analyzing procedure `\foo' and the other procedures
  in the program do not write to global variables that `\foo' refers
  to.
\item No variable is used before it is defined, except global
  variables.
\item All loops in procedure `\foo' have been replaced with separate
  recursive procedures.
\item The return value from the recursive procedure calls is assigned
  only to local variables.
\end{itemize}

Note : all of the above mentioned restrictions can be omitted.


In Figure~\ref{fig:grammar} we show the grammar for the programming
language for which we have designed the static analysis approaches.
Most of the statements are standard statements found in imperative
languages. Other than that we have the `havoc' and the `assume'
statement. The statement `havoc x' assigns any value to x from it's
domain. And the statement `assume x' allows the execution of the
program to proceed iff the predicate `x' holds at the given program
point.

\begin{figure}[hb!]
  %% \includegraphics[trim={0 5cm  3cm 0}, width=6cm]{grammar.eps}
  \begin{grammar}
    <statement> ::= <ident> = <constant>
    \alt <ident> = <logical-expr>
    \alt <ident> = <arithmetic-expr>
    \alt <statement>; <statement>
    %% \alt if<logical-expr> then <statement> else <statement>
    %% \alt while<logical-expr> do <statement>
    \alt <ident> = foo(<params-list>)
    \alt assume(<logical-expr>)
    \alt <ident> = \foo(<ident>)
    \alt havoc(<ident>)
    %% \alt <ident>[<ident>] = <ident>
    %% \alt <ident> = <ident>[<ident>]

    %% <params-list> ::= <params-list> , <ident>
    %% \alt <ident>

    <arithmetic-expr> ::= <ident> "+" <ident>
    \alt <ident> "-" <ident>
    \alt <ident> "/" <ident>
    \alt <ident> "*" <ident>
    \alt <ident> "\%" <ident>
 
    <logical-expr> ::= <ident> "<" <ident>
    \alt <ident> ">" <ident>
    \alt <ident> "==" <ident>
    \alt <ident> $\leq$ <ident>
    \alt <ident> $\geq$ <ident>
    \alt <logical-expr> $\wedge$ <logical-expr>
    \alt <logical-expr> $\vee$ <logical-expr>
    \alt $\neg$<logical-expr>
    \alt true
    \alt false

    <ident> ::= <local-ident>
    \alt <global-ident>
    
    <procedure> ::= procedure \foo ($\n$) {<statement>;}
  \end{grammar}
  \caption{Grammar for our programming language}
  \label{fig:grammar}
\end{figure}

\subsection{Our intermediate representation}\label{sec:intermediate}
We transform the given procedure into the following representation to be able
to represent it in logic. An instance of the transformed program wrt
procedure `factorial' in Listing~\ref{lst:factorialSimple} is in
Listing~\ref{lst:factorialTransformed}.

Our analysis we expects the following :
\begin{enumerate}
\item A procedure call statement is not a part of an expression. If
  it is, we break it down to multiple statements.
\item Continuation of above, recursive calls may affect global
  variables and the variable assigned the return value. Procedure
  calls must be over-approximated using `havoc' statements.
\item In the previous steps `x = \foo(y)' is replaced with
  `havoc(x)'. The next statement should be `assume x = F(y)'.
\item After all this, the program should be converted into SSA.
\end{enumerate}

\begin{lstlisting}[language=c, caption= {Procedure `factorial' from
      Listing~\ref{lst:factorialSimple} converted to the form our
      approach expects}, label=lst:factorialTransformed]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    retVar = 1;
    gout = g;
  } else if(g == -1 && n == 19) {
    gbef1 = g;
    havoc(temp1); 
    havoc(g1);
    assume(temp1 = F(18));  // newly added statement
    gaft1 = g1;
    g2 = 19 * temp1;
    retVar = g2;
    gout = g2;
  } else if(g != -1 && n == 19) {
    retVar = g;
    gout = g;
  } else {
    gbef2 = g;
    havoc(temp2);
    havoc(g1);
    assume(temp2 = F( n - 1 ));  //newly added statement
    gaft2 = g1;
    retVar = n * temp2;
    gout = g1;
  }
}
\end{lstlisting}

In Listing~\ref{lst:factorialTransformed}, in comparison to procedure
`factorial' in Listing~\ref{lst:factorialSimple}, the return statement
(line\# 4) is replaced by an assignment statement (line\# 4). And in
line\# 5, an extra variable `gout' is added that captures the value of
the global variable at the end of the program. Similarly, variable
`gbef1' (at line\# 7) is added to capture the value of the global
variable before the procedure call; and variable `gaft1' is inserted
at line\# 11 to capture the value of `g' after the procedure
call. Also, havoc statements at line\# 8, 20 and 9, 21 over-approximate
the return from the procedure call statement and updates to the global
variable. The procedure call statement is substituted with function
symbols in line\# 10 and 22, taking into account the given procedure
call as a function symbol.

\subsection{Path Condition}
  %% The path condition $\pathCondition$ for a given procedure $\foo$
  %% is
  %% a formula that relates the incoming values of global variables and
  %% arguments to the outgoing values of the global variables and the
  %% return value, while assuming the recursive procedure call (if there
  %% is one) to be to an OP procedure. The recursive procedure call is
  %% represented as function symbol instead of inlining it.


We need a representation of the given procedure in logic such that it
captures the values of the argument, the return value and the values
of the global variables at various program points. We track the values
of the global variables using extra variables as explained in
Section~\ref{sec:intermediate}.



\begin{figure}
  \begin{align*}
    &(n <= 1 \wedge retVar = 1 \wedge gout = g) \\
    &\vee (n > 1 \wedge g = -1 = gbef \wedge n = 19 \wedge temp1 = \F(18) \\
    &\wedge gaft1 = g1 \wedge g2 = 19 * temp1
    \wedge retVar = g2) \\
    &\vee (n > 1 \wedge \neg( g = -1 \wedge n = 19) \wedge g \neq -1
    \wedge n = 19 \wedge retVar = g = gout)\\
    &\vee (n > 1 \wedge n \neq 19 \wedge gbef2 = g \wedge temp2 = \F( n
    - 1) \wedge gaft2 = g1\\
    &\wedge retVar = n * temp2 \wedge gout = g1)\\
  \end{align*}
  \caption{Formulae representing paths of procedure `factorial' in
    Figure~\ref{fig:factorialTransformed} (assuming that
    function $\F$ is equivalent to procedure `factorial').}
  \label{fig:pathCondition}
\end{figure}


  %% The path condition $\pathCondition$ for procedure `\foo' is a
  %% formula that represents the procedure `\foo' in logic.
  %% $\pathCondition$ has the following set of free variables \{$\g,
  %% \gout,\n,\\ \retVar, \gbef_1, \cdots \gbef_m, \gaft_1, \cdots
  %% \gaft_m$\}. Variable $\g$ represents the value of the global
  %% variable `\g' at the beginning of procedure `\foo' whereas $\gout$
  %% represents value of `\g' at the end of `\foo'. Variable $\n$
  %% represents the value of the argument, $\retVar$ the return
  %% value. And $\gbef_i$ and $\gaft_i$ represent the value of `\g' before
  %% and after the $i^{th}$ procedure call statement and there are $m$
  %% procedure calls in `\foo'.


\section{Invariant}

To introduce the definition of an invariant we define trace and
history.

j\begin{definition}[trace]
  A trace $\trace$ is a complete execution of the procedure starting
  from a given global state and a tuple of formal arguments. A trace
  upon completion gives an end state and a return value. Traces may
  have sub-traces, which by definition are traces (recursive calls).
\end{definition}

\begin{definition}[history]
  A history $\history$ is a sequence of consecutive traces, with the
  first trace starting from a given global state, and each subsequent
  trace begins in the state in which the previous trace ends.
\end{definition}

\begin{definition}[invariant]
  An invariant is a formula with function symbol $\F$ and the global
  variables of the given procedure as free variables. The invariant
  represents the set of global states that may arise before and after
  each procedure call of the given procedure in a set of
  histories. Some variables here may be defined in terms of a function
  symbol $\F$, which in turn refers to the mathematical function that
  is equivalent to the given procedure.
  
  Let $\gstate$ be a global state, and $\F'$ be a function, and $\inv$
  be a invariant. If we substitute $\gstate$ for $g$ and $\F'$ for
  $\F$ in $\inv$, if $\inv[\gstate/g, \F'/\F]$ is true then, we say
  $(\gstate, \F') \satisfies \inv$. For instance let $\inv := g = -1
  \vee g = \F(18) * 19$ then $(19!, \lambda n. n!) \satisfies \inv$.
\end{definition}

Note : Representing recursive calls using function symbols allows us
to come-up with an automated invariant generation algorithm.

\section{Observational purity}
\begin{definition}[observational purity(invariant $\inv$)]
  A given set of procedures are observationally pure if in each
  history starting from a state in invariant $\inv$, all traces of
  each procedure with the same argument value return the same result.
\end{definition}

\section{Existential approach}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckE
       & \mi{(\inv :
        invariant, \pathCondition : path \; condition)} \equiv \\
      &\inv \wedge \pathCondition \wedge \retVar = \F(\n)\\
    \end{align*}
    \caption{Existential check : produces a formula whose
      satisfiability implies the given procedure is observationally
      pure} 
    \label{algo:someOPcheckCombined}
  \end{algorithm}  
\end{figure}

%% \begin{figure}[htp]
%%   \begin{algorithm}[H]
%%     \begin{align*}
%%       \OPCheckE & \mi{(\inv :
%%         invariant, \pathCondition : path \; condition)} \equiv \\
%%        (\forall & \g) (\forall \n) (\forall \retVar) (\forall \gout) &(1)\\
%%        (\forall & \gbef_1) (\forall \gbef_2) \cdots(\forall \gbef_m) &(2)\\
%%        (\forall & \gaft_1) (\forall \gaft_2) \cdots(\forall \gaft_m)
%%       \{& (3)\\
%%       & \inv \wedge \pathCondition \wedge & (4)\\
%%       & \inv[\gaft_1/\g] \wedge \inv[\gaft_2/\g] \cdots \wedge
%%       \inv[\gaft_m/\g] & (5)\\
%%       & \implies (\retVar = \F(\n) \wedge \inv[\gout/\g] \wedge & (6) \\
%%       & \inv[\gbef_1/\g] \wedge \inv[\gbef_2/\g] \cdots \wedge
%%       \inv[\gbef_m/\g]) & (7) \\
%%        \}&\\
%%     \end{align*}
%%     \caption{Existential check : produces a formula whose
%%       satisfiability implies the given procedure is observationally
%%       pure} 
%%     \label{algo:someOPcheckCombined}
%%   \end{algorithm}  
%% \end{figure}

\section{Impurity witness approach}
\section{is invariant inductive}

%% \begin{figure}[htp]
%%   \begin{algorithm}[H]
%%     \begin{align*}
%%       is-Inductive & \mi{(\inv :
%%         invariant, \pathCondition : path \; condition)} \equiv \\
%%       &\inv \wedge \pathCondition \implies \inv[\g'/\g]
%%     \end{align*}
%%     \caption{Is Inductive: is true iff the given invariant is inductive} 
%%     \label{algo:someOPcheckCombined}
%%   \end{algorithm}  
%% \end{figure}

\subsection{Comparing the two approaches}
\section{Comparison of Impurity witness approach with other approaches}
The goal of this section is to 

\section{Conclusions}
%

%
% ---- Bibliography ----
%
\begin{thebibliography}{5}
%
\bibitem {clar:eke}
Clarke, F., a, I.:
Nonlinear oscillations and
boundary-value problems for Hamiltonian systems.
Arch. Rat. a. Anal. 78, 315--333 (1982)


\end{thebibliography}

\end{document}
