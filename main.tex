% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
%% himanshu
\usepackage[title]{appendix}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{syntax}
\usepackage{amssymb}
\newcommand{\foo}{\textit{`foo'}}
\newcommand{\trace}{\pi}
\newcommand{\inv}{\mathit{inv}}
\newcommand{\history}{\Pi}
\newcommand{\pathCondition}{\mathit{T_{\foo}}}
\newcommand{\OPCheckE}{\mathit{OPCheck \mhyphen existential}}
\newcommand{\OPCheckA}{\mathit{OPCheck \mhyphen pairwise}}
\mathchardef \mhyphen="2D
\newcommand{\mi}[1]{\mathit{#1}}
\newcommand{\retVar}{\textit{retVar}}
\newcommand{\F}{\mathit{F}}
\newcommand{\n}{\textit{n}}
\newcommand{\gstate}{\gamma}
\newcommand{\g}{\textit{g}}
\newcommand{\gout}{\textit{gout}}
\newcommand{\gbef}{\textit{gbef}}
\newcommand{\gaft}{\textit{gaft}}
\newcommand{\satisfies}{\vdash}
\newcommand{\fact}{\mathit{fact}}
\newcommand{\formula}{\mu}
\newcommand{\integer}{\mathbb{N}}
\newcommand{\vci}[2]{\mathit{valid \mhyphen consistent \mhyphen
    invariant(#1, #2)}}
\newcommand{\atEntry}[1]{\mathit{at \mhyphen entry(#1)}}
\newcommand{\beforeCall}[1]{\mathit{before \mhyphen call(#1)}}
\newcommand{\return}[1]{\mathit{return(#1)}}
\newcommand{\atEnd}[1]{\mathit{at \mhyphen end(#1)}}
\newcommand{\tSegment}{\tau}
\newcommand{\param}[1]{\mathit{argument(#1)}}
\newcommand{\segDepth}[2]{\mathit{segment \mhyphen depth(#1, #2)}} %trace, segment
\newcommand{\subTrace}{\pi_{sub}}
\newcommand{\segment}[2]{\mathit{segment(#1, #2)}} %trace, N
\newcommand{\pairFormula}{\mathit{f_{pairwise}}}
\newcommand{\depth}[1]{\mathit{depth(#1)}}
\newcommand{\level}[1]{\mathit{level(#1)}}
\newcommand{\state}{\sigma}
\newcommand{\afterCall}[1]{\mathit{after \mhyphen call(#1)}} 

\lstdefinestyle{mystyle}{
  basicstyle=\footnotesize, 
  %% breakatwhitespace=false,         
  %% breaklines=true,                 
  captionpos=b,
  %% keepspaces=true,         
  numbers=left,
  numbersep=6pt,                  
  %% showspaces=false,                
  %% showstringspaces=false,
  %% showtabs=false,
  morekeywords={if, for, else,
  procedure,modifies, var, returns, int, call, assume},
  %% tabsize=2
}
\lstset{
  %% basicstyle=\itshape,
  style = mystyle,
  xleftmargin=3em,
  %% literate={\alt}{;}{1}
  %% basicstyle=\footnotesize,
  numberstyle=\tiny,
  breaklines=true,
  escapeinside={\%*}{*)}
}

%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
%% \chapter*{Preface}
%% %
%% This textbook is intended for use by students of physics, physical
%% chemistry, and theoretical chemistry. The reader is presumed to have a
%% basic knowledge of atomic and quantum physics at the level provided, for
%% example, by the first few chapters in our book {\it The Physics of Atoms
%% and Quanta}. The student of physics will find here material which should
%% be included in the basic education of every physicist. This book should
%% furthermore allow students to acquire an appreciation of the breadth and
%% variety within the field of molecular physics and its future as a
%% fascinating area of research.

%% For the student of chemistry, the concepts introduced in this book will
%% provide a theoretical framework for that entire field of study. With the
%% help of these concepts, it is at least in principle possible to reduce
%% the enormous body of empirical chemical knowledge to a few basic
%% principles: those of quantum mechanics. In addition, modern physical
%% methods whose fundamentals are introduced here are becoming increasingly
%% important in chemistry and now represent indispensable tools for the
%% chemist. As examples, we might mention the structural analysis of
%% complex organic compounds, spectroscopic investigation of very rapid
%% reaction processes or, as a practical application, the remote detection
%% of pollutants in the air.

%% \vspace{1cm}
%% \begin{flushright}\noindent
%% April 1995\hfill Walter Olthoff\\
%% Program Chair\\
%% ECOOP'95
%% \end{flushright}
%% %
%% \chapter*{Organization}
%% ECOOP'95 is organized by the department of Computer Science, Univeristy
%% of \AA rhus and AITO (association Internationa pour les Technologie
%% Object) in cooperation with ACM/SIGPLAN.
%% %
%% \section*{Executive Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \section*{Program Commitee}
%% \begin{tabular}{@{}p{5cm}@{}p{7.2cm}@{}}
%% Conference Chair:&Ole Lehrmann Madsen (\AA rhus University, DK)\\
%% Program Chair:   &Walter Olthoff (DFKI GmbH, Germany)\\
%% Organizing Chair:&J\o rgen Lindskov Knudsen (\AA rhus University, DK)\\
%% Tutorials:&Birger M\o ller-Pedersen\hfil\break
%% (Norwegian Computing Center, Norway)\\
%% Workshops:&Eric Jul (University of Kopenhagen, Denmark)\\
%% Panels:&Boris Magnusson (Lund University, Sweden)\\
%% Exhibition:&Elmer Sandvad (\AA rhus University, DK)\\
%% Demonstrations:&Kurt N\o rdmark (\AA rhus University, DK)
%% \end{tabular}
%% %
%% \begin{multicols}{3}[\section*{Referees}]
%% V.~Andreev\\
%% B\"arwolff\\
%% E.~Barrelet\\
%% H.P.~Beck\\
%% G.~Bernardi\\
%% E.~Binder\\
%% P.C.~Bosetti\\
%% Braunschweig\\
%% F.W.~B\"usser\\
%% T.~Carli\\
%% A.B.~Clegg\\
%% G.~Cozzika\\
%% S.~Dagoret\\
%% Del~Buono\\
%% P.~Dingus\\
%% H.~Duhm\\
%% J.~Ebert\\
%% S.~Eichenberger\\
%% R.J.~Ellison\\
%% Feltesse\\
%% W.~Flauger\\
%% A.~Fomenko\\
%% G.~Franke\\
%% J.~Garvey\\
%% M.~Gennis\\
%% L.~Goerlich\\
%% P.~Goritchev\\
%% H.~Greif\\
%% E.M.~Hanlon\\
%% R.~Haydar\\
%% R.C.W.~Henderso\\
%% P.~Hill\\
%% H.~Hufnagel\\
%% A.~Jacholkowska\\
%% Johannsen\\
%% S.~Kasarian\\
%% I.R.~Kenyon\\
%% C.~Kleinwort\\
%% T.~K\"ohler\\
%% S.D.~Kolya\\
%% P.~Kostka\\
%% U.~Kr\"uger\\
%% J.~Kurzh\"ofer\\
%% M.P.J.~Landon\\
%% A.~Lebedev\\
%% Ch.~Ley\\
%% F.~Linsel\\
%% H.~Lohmand\\
%% Martin\\
%% S.~Masson\\
%% K.~Meier\\
%% C.A.~Meyer\\
%% S.~Mikocki\\
%% J.V.~Morris\\
%% B.~Naroska\\
%% Nguyen\\
%% U.~Obrock\\
%% G.D.~Patel\\
%% Ch.~Pichler\\
%% S.~Prell\\
%% F.~Raupach\\
%% V.~Riech\\
%% P.~Robmann\\
%% N.~Sahlmann\\
%% P.~Schleper\\
%% Sch\"oning\\
%% B.~Schwab\\
%% A.~Semenov\\
%% G.~Siegmon\\
%% J.R.~Smith\\
%% M.~Steenbock\\
%% U.~Straumann\\
%% C.~Thiebaux\\
%% P.~Van~Esch\\
%% from Yerevan Ph\\
%% L.R.~West\\
%% G.-G.~Winter\\
%% T.P.~Yiou\\
%% M.~Zimmer\end{multicols}
%% %
%% \section*{Sponsoring Institutions}
%% %
%% Bernauer-Budiman Inc., Reading, Mass.\\
%% The Hofmann-International Company, San Louis Obispo, Cal.\\
%% Kramer Industries, Heidelberg, Germany
%% %
%% \tableofcontents
%% %
\mainmatter              % start of the contributions
%
\title{Checking Observational Purity of Procedures}
%
\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
%% \author{Himanshu~Arora\inst{1}\orcidID{0000-1111-2222-3333} \and
%% Raghavan~Komondoor\inst{1}\orcidID{1111-2222-3333-4444} \and
%% G.~Ramalingam\inst{2}\orcidID{2222-3333-4444-5555}
%% }
\author{Himanshu~Arora\inst{1} \and
Raghavan~Komondoor\inst{1} \and
G.~Ramalingam\inst{2}
}
%
\authorrunning{Himanshu et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%% \tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%% Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%
\institute{Indian Institute of Science, Bangalore\\
  \email{\{himanshua, raghavan\}@iisc.ac.in},
 %%  \\ WWW home page:
%% \texttt{http://users/\homedir iekeland/web/welcome.html}
\and
Microsoft Research India \\
\email{grama@microsoft.com}}

\maketitle              % typeset the title of the contribution

\begin{abstract}








%% The abstract should summarize the contents of the paper
%% using at least 70 and at most 150 words. It will be set in 9-point
%% font size and be inset 1.0 cm from the right and left margins.
%% There will be two blank lines before and after the Abstract. \dots

  %% Observational purity checks if a given procedure is a pure function
  %% of it's arguments modulo the side effects.
  %% (option 1)\\
  %% A procedure that is a pure function of its arguments modulo side
  %% effect to the global state is Observationally pure (OP). We present
  %% a pair of static analysis approaches that entail OPness. In-order to
  %% statically check OPness, we need an invariant on the global states
  %% at the boundaries of the procedure. Allowing the invariant to be
  %% defined in terms of the given procedure (assuming it is OP)
  %% simplifies invariant construction. This also allows us to
  %% automatically check OPness for recursive procedures. \dots\\

  %% (option 2)\\
  
  %% A specification language that includes procedure calls greatly
  %% improves the ease of expression. Java modelling language (JML)
  %% currently allows only pure procedures (side effect free) to be used
  %% in the specifications. This is overly restrictive, as the procedure
  %% might have benign side effects, which are not observable to other
  %% procedures (or itself). Observationally pure procedures may read or
  %% write to global variables, but their input-output behaviour is
  %% independent of the global state.

JML, a specification language for Java programs and programming
languages such as Spec\# and Eiffel allow procedure calls in contracts
of a procedure.  As always, the presence of the specification must not
influence the behaviour of the procedure.
%% The
%% behaviour of the implementation must not vary depending on the
%% presence of the specification
Thus, in order to safely use procedure calls in specifications, the
procedure behaviour must be restricted.
%% Strong purity allows no side effects
%% whereas weak purity allows no side effects on pre-existing
%% objects. Another direction is \textit{observational purity} :
%% generalization of referential transparency such that it allows only
%% benign side effects, which do not affect the input output behaviour of
%% the procedure.
We formally define Observational Purity which is a generalization of
referential transparency which allows only benign side effects. And
\textit{benign side effects} cannot be observed (do not affect the
input-output behaviour of the procedure).
%% Specifications in JML allow only strongly pure
%% procedures which is overly restrictive. A procedure may have benign
%% side effects which do not affect the input-output behaviour of the
%% procedure; thus, there is a need for observational purity.
 
%% We also formalize conditional invariant which is well defined only if
%% the procedure is observationally pure.
We present two static analysis approaches that can check if a
procedure is observationally pure. These techniques do not require any
user annotations for array-free programs and are applicable to
recursive procedures, which is beyond the scope of current literature.

\keywords{specification languages, observational purity, pure
    procedure, programming by contract, static analysis}
\end{abstract}

\section{Introduction}
Verifying functional properties of procedures is a hard task.
Formalizing such properties of a procedure requires deep understanding
of the procedure's (expected) functionality. Many procedures
(especially in mathematical libraries) implement some mathematical
function. This paper describes a couple of techniques to check if a
given procedure implements a mathematical function of the argument
values. If the return value from a procedure is dependent only on the
formal arguments, irrespective of whether the procedure reads/writes
global variables,
% even if the
% procedure reads/writes to global variables,
the given procedure is \textit{Observationally pure(OP)}.  If a
procedure $\foo$ is observationally pure, then there exists a
mathematical function $\F$ such that $\F$ mimics the input-output
behaviour of $\foo$ in all sequence of procedure calls to $\foo$ ,
where both $\foo$ and $\F$ share the same signature. Thus, the
input-output behaviour of observationally pure procedures is
independent of the global variables. This property is a generalization
of referential transparency.
%% For instance,
`%% non-optimal implementations of dynamic programming algorithms that do
%% not use memoization can be refactored to use memoization
%% automatically.
Checking whether a given procedure is OP is undecidable. In this
paper, we propose a pair of static analysis techniques to check OPness
that are proved to be sound i.e they give a valid answer if the
technique terminates.

All arithmetic and logical operators are mathematical-functions, and
functional composition is closed under the set of functions
(hereonwards, we will refer to mathematical-functions as functions and
by procedure we mean a procedure written in an imperative programming
language). Without access to global variables, all procedures are a
function of their formal arguments. This paper focuses on checking if
a procedure that reads and writes global variables is OP.

\subsection{Motivating Example}

\begin{lstlisting}[language=c, caption= {Procedure `factorial' :
      returns factorial of `n' and memoizes result for argument value
      `3'.}, label=lst:factorialSimple]
int g = -1;
int factorial( int n) {
  if(n <= 1) {
    return 1;
  } else if(g == -1 && n == 3) {
    g = 3 * factorial( 2 );
    return g;
  } else if(g != -1 && n == 3) {
    return g;
  } else {
    return n * factorial( n - 1 );
  }
}
\end{lstlisting}

Procedure factorial in Listing~\ref{lst:factorialSimple} mimics the
function $\lambda n. n!$. It caches results using the global variable
`g', for parameter value `n = 3'. The initial global state is `g =
-1', where `-1' represents the un-initialized state. At line 6, global
variable `g' is set to `3!' iff `g' has value `-1' at line 5. Next,
line 9 is reached iff global variable `g' is not `-1', implying that
procedure factorial has been called with parameter value `n = 3'
previously. At line 9, the procedure correctly returns the value
`3!'. Other than this caching behaviour for `n = 3' this procedure is
similar to the standard implementation for factorial.

OPness is a property of a procedure and the set of reachable global
states. Where \textit{reachable global states} represents the set of
all the global states that are encountered at the boundaries of the
procedure in a sequence of executions of the given procedure. A
\textit{global state} is the assignment to the set of global
variables. Procedure factorial in Listing~\ref{lst:factorialSimple}
is OP if the global state is restricted to the set $\{\{g = -1\}, \{g
= 3!\}\}$, the procedure mimics the function $\lambda n.n!$. But for
the global states $\{\{g = 1\}, \{g = 3!\}\}$, procedure factorial
is not a mathematical function. For argument value `$n = 3$' it may
return `1' or `3!'.  We assume that the set of reachable global states
can be represented in the underlying logic and we refer to it as
\textit{invariant}.  The global states reachable at any boundary, of
any procedure call, in a sequence of procedure calls must satisfy the
invariant.

To check if a given procedure is OP, we ensure that for all reachable
global states, for each argument value, there is a unique result. Now,
this can be modelled using standard pre and post conditions. The pre
condition holds at the beginning of the procedure and the post
condition holds at its end. Both the pre condition and the post
condition can be substituted by the invariant $\inv$ ( in-order to
verify the invariant). This however does not constrain the return
value of the given procedure. But, the return value from a recursive
call may flow into a global variable. Thus, the return from the
procedure must be modelled in the post condition, to
re-establish $\inv$.  For procedure factorial in
Listing~\ref{lst:factorialSimple} we can use the invariant `$\inv : g
= -1 \vee g = 6$' and the function factorial can be modelled as `$ f
:= k \leq 1 \implies \fact[k] = 1 \wedge k >1 \implies \fact[k] =
\fact[k-1]*k$'. Thus, the pre-condition is `$\inv$' and the
post-condition is `$\inv \wedge f \wedge \retVar = fact[n]$' where
$\retVar$ is the return variable. This post-condition will not only
check the validity of the invariant but also that the given procedure
is OP, as the return value is constrained to be equivalent to
`$fact[n]$'.

The above mentioned idea is sound, modulo ease of use. The issues are:
(a) theorem provers often fail to prove such assertions (as is the
case for the above mentioned example) (b) describing the procedure in
logic takes considerable effort.  Instead of formalizing the function
for the given procedure, why not equate the result from the procedure
to that of an uninterpreted function symbol? This function symbol can
also be used to represent the return value from the inner procedure
calls. Next, we ask the question whether an assignment for the
function symbol exists? If yes, then the procedure is OP, otherwise it
is not OP.  This is our existential approach.

Abstracting using function symbols goes a long way. It helps in
representing the post-condition in a simpler manner and also it aids
in describing the invariant. For procedure factorial, we can use
the invariant `$\inv_{\F}:=g = -1 \vee g = \F(2) * 3$'. The symbol
`$\F(2)$' in the invariant represents the return value from the
procedure factorial for argument `$n = 2$', assuming procedure
factorial is a mathematical function. Note that the invariant used
here is valid if the given procedure is OP, otherwise it is not well
defined.

%% should I talk about why F(2) *3 instead of F(3) ?

OPness can also be checked by comparing a procedure to itself. We
represent two instances of a procedure in some underlying logic, and
then ask the question that do the two instances of the given procedure
mimic each other, for all argument values, and all states satisfying
the invariant? If yes, then we show that the given procedure is OP. We
call this the impurity witness approach.  This approach also makes
use of invariant with uninterpreted function symbols like the previous
approach.

Since observational purity is a property on the return values from a
procedure, this problem is closely related to the halting problem
%%cite this
. In Section~\ref{sec:background}, we define OPness in a way such that
non-termination does not cause non-OPness. OP is violated if for a
given invariant on the reachable global states, for a given argument
value there is a non-unique return value. And in-case of
non-termination there isn't a return value. Hence, a procedure that
never terminates is vacuously OP and it mimics all functions.

One direct application of this work is automatic memoization. Dynamic
programming algorithms (such as factorial in
Listing~\ref{lst:factorialSimple}) use memoization to store
pre-computed solutions to the sub-problem so that the results can be
looked-up when needed, thus trading memory for compute time. Our
technique can check if it is safe to memoize the results produced by a
procedure. By safety, we refer to preserving the input-output
behaviour. We propose two static analysis approaches to check this
problem. One interesting thing about our approach is that the user
need not mention a (the) mathematical function that the procedure is
supposed to mimic. Also, using a function symbol allows generating the
invariant automatically.

Many researchers have looked at the problem of observational purity
and have proposed characterizations of benign side effects
\cite{naumann2007observational}, \cite{barnett2006allowing},
\cite{cok2008extensions},
\cite{finifter2008verifiable}. Barnett~\cite{barnett2006allowing}
gives an information flow based technique to check observational
purity that marks some fields as secret and ensures all side effects
are limited to secret fields. Whereas
Naumann~\cite{naumann2007observational} calls a procedure OP if it
mimics a procedure that is weakly pure, i.e has side effects only to
pre-exiting objects. Cok~\cite{cok2008extensions} takes a very
different approach to allowing procedure calls in the specification
iff it mimics a procedure that has side effects only to pre-existing
objects.

In section~\ref{sec:background} we give the pre-requisites for this
work. The semantics of the invariant we use are described in
Section~\ref{sec:invariant}. Next Section~\ref{sec:op} defines
observational purity. In Section~\ref{sec:approaches} we present a
couple of techniques to check opness. Section~\ref{sec:experiments}
discusses the experimental results and section~\ref{sec:related}
compares this work to the current literature.

\section{Background} \label{sec:background}

\subsection{Programming Language}
We make the following restrictions on the structure of the program to
simplify the analysis without loss of generality. ( too much detail in
this and the next section, suggest level of abstraction)

\begin{itemize}
\item The given procedure (\foo) has a single argument i.e `\n'. And
  `\n' is never modified in \foo.
\item Procedure \foo has a single global variable, named `\g'.
\item Return statement is absent from our programming language. Instead,
  we have a special variable `\retVar', which is assigned the return
  value.
\item We analyze a single procedure in isolation and we assume that no
  other procedure writes to the global variables accessed by procedure
  \foo. In-case of multiple procedures, the invariant has multiple
  function symbols, one for each procedure. 
\item All variables are defined before use, except global variables.
\item All loops in procedure \foo are substituted with 
  separate recursive procedures.
\item The variable assigned the return value in a procedure call
  statement is always a local variable.
\item There is at max one procedure call statement in every straight line
  execution of \foo from the beginning until it's end.
  \end{itemize}
%% Note : all of the above mentioned restrictions can be omitted. They
%% are for convenience.

In Figure~\ref{fig:grammar}, we present the grammar for the
programming language which we have assumed for our static analysis
approaches.  Most of the statements are standard statements borrowed
from imperative languages. The rest of them are explained next. The
statement `havoc x' assigns any value from the domain of the variable
`x' to variable `x'.
%% to variable `x' from the declared domain of `x'
%% And the statement `assume x' allows the execution of the program to
%% proceed if the predicate `x' holds at the program point, otherwise it
%% halts the execution.

\begin{figure}[hb!]
  %% \includegraphics[trim={0 5cm  3cm 0}, width=6cm]{grammar.eps}
  \begin{grammar}
    <statement> ::= <ident> = <constant>
    \alt <ident> = <logical-expr>
    \alt <ident> = <arithmetic-expr>
    \alt <statement>; <statement>
    \alt if<logical-expr> then <statement> else <statement>
    %% \alt while<logical-expr> do <statement>
    %% \alt <ident> = foo(<params-list>)
    %% \alt assume(<logical-expr>)
    \alt <ident> = \foo(<ident>)
    \alt havoc(<ident>)
    %% \alt <ident>[<ident>] = <ident>
    %% \alt <ident> = <ident>[<ident>]

    %% <params-list> ::= <params-list> , <ident>
    %% \alt <ident>

    <arithmetic-expr> ::= <ident> "+" <ident>
    \alt <ident> "-" <ident>
    \alt <ident> "/" <ident>
    \alt <ident> "*" <ident>
    \alt <ident> "\%" <ident>
 
    <logical-expr> ::= <ident> "<" <ident>
    \alt <ident> ">" <ident>
    \alt <ident> "==" <ident>
    \alt <ident> $\leq$ <ident>
    \alt <ident> $\geq$ <ident>
    \alt <logical-expr> $\wedge$ <logical-expr>
    \alt <logical-expr> $\vee$ <logical-expr>
    \alt $\neg$<logical-expr>
    \alt true
    \alt false

    <ident> ::= <local-ident>
    \alt <global-ident>
    
    <procedure> ::= procedure foo ($\n$) {<statement>;}
  \end{grammar}
  \caption{Grammar for our programming language}
  \label{fig:grammar}
\end{figure}

\subsection{Our intermediate representation}\label{sec:intermediate}
We transform the given procedure into the following representation
in-order to encode it in logic. For example procedure factorial
in Listing~\ref{lst:factorialTransformed}, is the transformed version
of procedure factorial in Listing~\ref{lst:factorialSimple}.

Our analysis expects the following :
\begin{enumerate}
\item Expressions do not have procedure call statements as
  sub-expressions.(omit? too much detail)
\item Procedure calls are approximated using function symbols. The
  statement `x = foo(y)' is replaced with `x = $\F$(y)'. Since
  procedure calls may modify global variables, we add the statement
  `havoc g' for each global variable `g' accessible from the
  procedure.
\item The input procedure has `m' procedure calls.
\item Next, the procedure must have extra variables to store the value
  of global variables at procedure boundaries. Before the
  $\mathit{i^{th}}$ procedure call, we add the statement `gbef$_i$ =
  g' and after it we add `gaft$_i$ = g'. Similarly, we add the
  statement `gout = g' after the assignment to the variable `\retVar'.
\item The procedure should be in static single assignment (SSA)
  form. The procedure should be converted to SSA after the above
  mentioned points have been satisfied.
\end{enumerate}

\begin{lstlisting}[language=c, caption= {Procedure factorial from
      Listing~\ref{lst:factorialSimple} converted to the form our
      approach expects. We refer to this procedure as `transformed
      factorial'.}, label=lst:factorialTransformed]
int g = -1;
int transformedFactorial( int n) { // redo
  if(n <= 1) {
    retVar = 1;
    gout = g;
  } else if(g == -1 && n == 19) {
    gbef1 = g;
    temp1 = F(18);  // temp1 = factorial(18)
    havoc(g1);
    gaft1 = g1;
    g2 = 19 * temp1;
    retVar = g2;
    gout = g2;
  } else if (g != -1 && n == 19) {
    retVar = g;
    gout = g;
  } else {
    gbef2 = g;
    temp2 = F( n - 1 );  //temp2 = factorial(n-1)
    havoc(g2);
    gaft2 = g3;
    retVar = n * temp2;
    gout = g3;
  }
}
\end{lstlisting}

%% In procedure `transformedFactorial'
%% Listing~\ref{lst:factorialTransformed}, in comparison to procedure
%% factorial in Listing~\ref{lst:factorialSimple}, the return statement
%% (line 4) is replaced by an assignment to variable `\retVar' (line
%% 4). After line 5 of `transformed factorial', an extra variable `gout'
%% is assigned the value of global variable `g' (value of `g' at end of
%% program).  Similarly, variable `gbef1' (line 7, `transformed
%% factorial') is added to capture the value of the global variable
%% before the procedure call (a program boundary), and variable `gaft1'
%% is inserted at line 11 to capture the value of `g' after the procedure
%% call. Also, havoc statements at line 8, 20 and 9, 21 over-approximate
%% the return from the procedure call statement and updates to the global
%% variable respectively. The procedure call statement is substituted
%% with function symbols in line 10 and 22, accounting the given
%% procedure as a function.

Now we compare `transformed factorial' and procedure factorial from
Listings~\ref{lst:factorialTransformed} and \ref{lst:factorialSimple}
respectively. The return statement (line 4) in procedure factorial
is replaced by assignment to variable `\retVar' (line 4). Also, we
have a added an assignment statement (line 5) in `transformed
factorial', that defines variable `gout' in-order to store the value
of variable `g' at the procedure boundary. Similarly, variable `gbef1'
(line 7) is added in `transformed factorial' to capture the value of
the global variable before the procedure call and assignment to
variable `gaft1' is inserted at line 10 to capture the value of `g'
after the procedure call. Also, havoc statements at lines 9 and 20
over-approximate any side effects to the global variables. And in
lines 8 and 19, the procedure call statements are substituted for
function symbols.

\subsection{Path Condition}
For our analysis we represent the given procedure in logic, such that
the representation captures the argument value at the beginning of the
procedure, the return value at the end of the procedure and the values
of the global variables at all the boundaries of the procedure. We
track the values of the global variables using extra variables as
explained in Section~\ref{sec:intermediate}. Thus, the set of free
variables in a path condition of a procedure are $X : \mi{\{n, gin,
  gout, g, \gbef_1 \cdots \gbef_m, \gaft_1 \cdots \gaft_m,}$ \\ ${\retVar, \F
  \}}$ all the remaining variables are universally quantified.

\begin{figure}
  \begin{align*}
    \pathCondition :=
    &(n \leq 1 \wedge retVar = 1 \wedge gout = g) \vee \\
    &(n > 1 \wedge g = -1 = gbef \wedge n = 19 \wedge temp1 = \F(18) \\
    \;&\wedge gaft1 = g1 \wedge g2 = 19 * temp1
    \wedge retVar = g2) \vee\\
    &(n > 1 \wedge \neg( g = -1 \wedge n = 19) \wedge g \neq -1
    \wedge n = 19 \wedge retVar = g = gout) \vee\\
    &(n > 1 \wedge n \neq 19 \wedge gbef2 = g \wedge temp2 = \F( n
    - 1) \wedge gaft2 = g1\\
    &\wedge retVar = n * temp2 \wedge gout = g1)\\
  \end{align*}
  \caption{Formula representing procedure `transformed factorial' in
    Listing~\ref{lst:factorialTransformed} (assuming that function
    $\F$ is equivalent to procedure factorial).}
  \label{fig:pathCondition}
\end{figure}

For example, the procedure `transformed factorial' in
Listing~\ref{lst:factorialTransformed} is expressed in logic as shown
in Figure~\ref{fig:pathCondition}. Each disjunct in
Figure~\ref{fig:pathCondition} represents a straight-line execution of
procedure factorial (from beginning, until end) . For instance, $(n <=
1 \wedge retVar = 1 \wedge gout = g)$ represents the case where $`n
\leq 1'$.

Representation of a program in logic is straight forward once it is
converted to our intermediate representation in
Section~\ref{sec:intermediate}. All the standard imperative statements
become conjuncts in the formula. `havoc' statements are omitted.
`assume x' are replaced with a conjunct `x' in the formula.

\section{Invariant}\label{sec:invariant}

To introduce the definition of an invariant we first define
\textit{trace} and \textit{history}.

\begin{definition}[trace]
  A trace $\trace$ is a complete execution of the procedure starting
  from a given global state and a tuple of formal arguments. A trace
  upon completion gives an end state and a return value.\\ Traces may
  have sub-traces, which by definition are traces (recursive calls).
\end{definition}

\begin{definition}[history]
  A history $\history$ is a sequence of consecutive traces, with the
  first trace starting from a given global state, and each subsequent
  trace begins in the state in which the previous trace ends.
\end{definition}

\begin{definition}[invariant]
  Invariant $\inv$ represents the set of global states at the
  boundaries of a procedure. $\inv$ is a formula, with global
  variables accessed by the given procedure and a uninterpreted
  function symbol $\F$ as the set of free variables. The uninterpreted
  function symbol $\F$ is a placeholder for the mathematical function
  equivalent to the given procedure. The initial global state
  satisfies the invariant.
\end{definition}

Invariant $\inv$ is assumed at the beginning of the procedure and
asserted at the end. Also, $\inv$ is asserted before the procedure
call and assumed after the procedure call. Above mentioned treatment
is similar to handling of pre-conditions and post-conditions for
recursive procedures. For the invariant, it is  assumed that the given
procedure is observationally pure. The invariant has the free variable
$\F$ which is also used to abstract over procedure calls and it is
defined only if the given procedure is observationally pure.

Let $\gstate$ be a global state, and $\F'$ be a function, and $\inv$
be a invariant. If we substitute $\gstate$ for $g$ and $\F'$ for $\F$
in $\inv$ and it is true, then we say that $(\gstate, \F')$ satisfies
$\inv$, which is denoted as $(\gstate, \F') \satisfies \inv$. For
instance let $\inv := g = -1 \vee g = \F(18) * 3$ then $(3!, \lambda
n. n!) \satisfies \inv$.

\section{Observational purity}\label{sec:op}
\begin{definition}[observational purity(invariant $\inv$)]
 A given set of procedures are observationally pure if in each history
 starting from a state in invariant $\inv$, all traces of each
 procedure with the same argument value return the same result.
\end{definition}

\begin{lstlisting}[caption={Procedure `remember' : always returns the
      argument from its first call}, label=lst:remember]
int g = 0;
int init = 0;
int remember( int n) {
  if(init == 0){
    init = 1;
    g = n;
  }
  return g;
}
\end{lstlisting}

In a history, if all traces return the same result for an argument
value, there exists a function $\F$ that respects the given
procedure. In a history, the given procedure mimics a unique function,
but the mimicked function varies across histories. If the invariant is
a set of concrete states then there exists a unique function that is
equivalent to the given procedure across histories. But, our invariant
allows function symbols. Use of the function symbol allows an OP
procedure to mimic different functions across histories. For instance,
procedure `remember' in Listing~\ref{lst:remember} mimics a constant
function for $\inv := g=0 \wedge init=0 \vee g= \F() \wedge
init=1$. Whereas, for the invariant $\inv := g=0 \wedge init=0 \vee
g=2 \wedge init=1$; the procedure mimics the function $\lambda n.2$.

\section{Approaches} \label{sec:approaches}
\subsection{Existential approach}\label{sec:existential}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckE
       & \mi{(\inv :
        invariant, \pathCondition : path \; condition)} \equiv \\
      &\forall \{X - \{\F\}\}.\\
      &\inv \wedge \inv[\gaft_1/\g] \wedge \inv[\gaft_2/\g] \wedge
      \cdots \inv[\gaft_m/\g] \\
      &\wedge \pathCondition \implies ( \retVar = \F(\n)\\
            & \wedge \inv[\gout/\g] \wedge  \inv[\gbef_1/\g] \wedge
      \inv[\gbef_2/\g] \wedge \cdots inv[\gbef_m/\g]) \\
    \end{align*}
    \caption{Existential check : produces a formula whose
      satisfiability implies the given procedure is observationally
      pure} 
    \label{algo:someOPcheckCombined}
  \end{algorithm}  
\end{figure}

The existential approach in Algorithm~\ref{algo:someOPcheckCombined}
encodes a formula $\formula_e$. In formula $\formula_e$, the invariant
is assumed at the beginning of the procedure, and after each procedure
call ( $m$ procedure calls in total).  We abstract all the recursive
procedure calls in the original procedure using function symbol $\F$
in $\pathCondition$.  Next, the return value is constrained to be
equivalent to $\F(n)$, where `n' is the parameter value. Formula
$\formula_e$ has a single free variable $\F$, and it is constrained to
respect the given procedure, for all values of the parameter `n' and
all values of the global variable `g'. Thus, if $\formula_e$ is SAT,
it implies that there exists a function which mimics the given
procedure. 

The check encoded in Figure~\ref{algo:someOPcheckCombined} cannot be
expressed using standard requires and ensures statements (to the best
of our knowledge). In the standard pre-post verification, the
unreachability of the compliment of the post-condition is ensured. In
contrast, our analysis just requires that the post condition is
reachable. We check if $\retVar = \F(n)$ is satisfiable, but this
suffices for our analysis.

\subsection{Impurity witness approach}\label{sec:impurityWitness}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckA &\mi{(\inv : invariant,
        \pathCondition: path\; condition)} \equiv &\\
      &\inv[\g_\alpha/\g] \wedge \inv[\g_\beta/\g]  & (1)\\
      & \wedge \inv[\gaft_{\alpha1}/\g] \wedge
      \inv[\gaft_{\alpha2}/\g] \cdots \wedge \inv[\gaft_{\alpha m}/\g]
      & (2)\\
      & \wedge \inv[\gaft_{\beta1}/\g] \wedge \inv[\gaft_{\beta2}/\g]
      \cdots \wedge \inv[\gaft_{\beta m}/\g] & (3)\\
      &\wedge \n_\alpha = \n_\beta  & (4)\\
      &\wedge \pathCondition[\g_\alpha/\g, \n_\alpha/\n, \retVar_\alpha/\retVar,
        \gout_\alpha/\gout, & (5)\\
        &\gbef_{\alpha1}/\gbef_1 \cdots, \gaft_{\alpha 1}/\gaft_1, \cdots
        \gaft_{\alpha m}/\gaft_m]  & (6)\\
      &\wedge \pathCondition[\g_\beta/\g, \n_\beta/\n, \retVar_\beta/\retVar,
        \gout_\beta/\gout, & (7)\\
        &\gbef_{\beta1}/\gbef_1 \cdots, \gaft_{\beta 1}/\gaft_1, \cdots
        \gaft_{\beta m}/\gaft_m] & (8)\\
      &\wedge (\retVar_\alpha \neq \retVar_\beta \vee \neg\inv[\gbef_{\alpha1}/\g] \vee
       \cdots \neg\inv[\gbef_{\alpha m}/\g] & (9) \\
        &\vee \neg\inv[\gout_\alpha/\g])  & (10)\\
    \end{align*}
    \caption{Impurity witness : produces a formula whose unsatisfiability
    implies observational purity.}
    \label{algo:pairwiseOPcheckCombined}
  \end{algorithm}  
\end{figure}

The impurity witness approach in
Algorithm~\ref{algo:pairwiseOPcheckCombined} encodes formula
$\formula_{iw}$. If $\formula_{iw}$ is UNSAT the given procedure is
OP. The idea encoded in $\formula_{iw}$ is that if a pair of traces of
the given procedure exists such that the traces start with the same
parameter value, and potentially different values for the global
variables return different results, then the procedure is not OP. In
this case, we have a witness to the non-OPness of the given
procedure. Otherwise, we prove that the given procedure is OP (this
proof will be mentioned in the final version of this paper).

The check encoded in Figure~\ref{algo:pairwiseOPcheckCombined}, cannot
be expressed in standard requires and ensures (again, to the best of
our knowledge). As the approach compares the given procedure with
itself, standard requires and ensures do not suffice. But works such as
\cite{lahiri2013differential} can be used to express this property. 

\subsection{Comparing the two approaches}

\begin{lstlisting}[caption={Procedure `bar': illustrates that
      existential approach is more precise that the impurity witness
      approach.}, label=lst:comparison]
int bar(int n) { 
  return g; 
}
\end{lstlisting}

The existential approach in Section~\ref{sec:existential} is more
precise than the impurity witness approach in
Section~\ref{sec:impurityWitness}. The existential approach requires
one mathematical function, such that it mimics the given procedure and
the invariant holds for this function to mark a procedure OP. On the
other hand, the impurity witness marks a procedure OP if for all
functions, the two instances of the path condition agree on the return
value. For instance procedure `bar' in Listing~\ref{lst:comparison} is
observationally pure for the invariant $(g = \F(0) \vee g = \F(1))$
and it mimics the mathematical function $\forall n. \F(0) = \F(1) =
\F(n)$ (thus, it must be a constant function). Now, the existential
approach marks this procedure as OP whereas the impurity witness
approach marks it as non-OP. The existential approach marks this
example OP, considering a function $\lambda n. 2$. Whereas there are
many functions $\F'$ such that $\F'(0) \neq \F'(1)$, now the procedure
`bar' is not OP for the invariant $(g = \F(0) \vee g =
\F(1))[\F'/\F]$.

Although the existential approach is more precise, the impurity
witness approach performs better with SAT-SMT solvers. In case of the
existential approach the solver has to find a satisfying assignment
for the free variable $\F$. Whereas, in case of the impurity witness
approach, the inequivalence is contradicted (if procedure is OP).

\section{Experimental Results}\label{sec:experiments}

(to be included)
%% \section{Conclusion}
\section{Related work}\label{sec:related}
JML~\cite{leavens2008jml} does not allow any
side-effects for Library procedures, thus specifiers use pure
replacements instead. Barnett defines Observational
purity~\cite{barnett200499} but their work cannot prove self recursive
procedures to be OP and also need user annotations. In order to relate
the two heaps, uninit cache and cached; they mark the fields which
serve as secret fields. later, when the cache is used to return the
value, they annotate the program relating secret to open fields
inorder to establish equivalence among the two heaps.

The idea of comparing a program to
itself~\cite{lahiri2013differential} \cite{partush2013abstract} is
closely related to the impurity witness
approach. DAC~\cite{lahiri2013differential} uses this idea for finding
the assertions that failed in a version of a program with respect to
another version. Whereas, Partush and Yahav~\cite{partush2013abstract}
focus on finding the parameter values for which the two versions of
the procedure differ.

Naumann~\cite{naumann2007observational} calls a procedure OP if it is
output-equivalent to a procedure which is a side-effect free. And
side-effect-freeness does not entail OPness as the procedure's return
value may be dependent on some global variable. This works present/use
a theory for simulations, closely related to ownership types. Thus
this work is closely related but they solve a different problem.

Cok~\cite{cok2008extensions} builds upon Barnett's
work~\cite{barnett2006allowing} and~\cite{barnett200499} suggests
partitioning the set of methods into ``pure'', ``secret'' and
``query'' methods, each scoped to a particular data group. The query
methods are OP. They give a set of rules to be followed by methods in
each group. Thus, structuring for modular reasoning about OPness.

Finifter~\cite{cok2008extensions} takes a different approach of
restricting the programming language in order to make OP checking
simpler. In the restricted language called Joe-E, OP methods have all
objects reachable from the parameters marked as immutable.

Salcianu~\cite{sualcianu2005purity} gives a static analysis that
checks if a method modifies the pre-existing state. All the operators
used in specifications do not have side effects. If a procedure does
not modify the pre-existing state it is called pure and
~\cite{barnett200499} suggests that such procedures can be used in
specifications. Our work in comparison generalizes further by allowing
procedures that modify pre-existing state but behave as mathematical
functions in specifications. We would like to point out that in their
work they manually marked library methods that did caching but were
semantically preserving as pure.

\nocite{barnett2004spec}
\nocite{lahiri2013differential}
\nocite{de2008z3}
\nocite{alpern1988detecting}
\nocite{sondergaard1990referential}
\nocite{flanagan2001avoiding}
\nocite{sualcianu2005purity}
\nocite{cytron1991efficiently}
\nocite{leino2008boogie}


%% \appendix
\begin{subappendices}
\renewcommand{\thesection}{\Alph{section}}



\end{subappendices}

%

%
% ---- Bibliography ----
%
%% \bibliographystyle{plainnat}
\bibliographystyle{splncs}
\bibliography{references}
%% \begin{thebibliography}{5}

%% \bibitem {clar:eke}
%% Clarke, F., a, I.:
%% Nonlinear oscillations and
%% boundary-value problems for Hamiltonian systems.
%% Arch. Rat. a. Anal. 78, 315--333 (1982)


%% \end{thebibliography}

\end{document}
