\newcommand{\elt}{\ensuremath{\in} }
\newcommand{\domain}[1]{#1}

\section{Language Syntax}
\label{sec:background}

In this paper, we assume that the input to the purity checker is a library consisting
of one or more procedures, with shared state consisting of one or more variables
that are private to the library. We refer to these variables as ``global'' variables to
indicate that they retain their values across multiple invocations of the library
procedures, but they cannot be accessed or modified by procedures outside
the library (that is, the clients of the library).

\begin{figure}[t!]
{\tt
\begin{tabular}{rll}
L \elt & \domain{Lib} & ::= $\overline{\code{g := c}}$ $\overline{\code{P}}$ \\
P \elt & \domain{Proc} & ::= p (x) \{ S; return y \} \\
S \elt & \domain{Stmt} & ::=  x := e | x := p(y) | S ; S | if (e) then S else S \\
e \elt & \domain{Expr} & ::= c | x | e op e | unop e \\
op \elt & \domain{Ops} & ::= + | - | / | * | \% | > | < | == | $\wedge$ | $\vee$ \\
unop \elt & \domain{UnOps} & ::= $\neg$ \\
\multicolumn{3}{c}{
x, y \elt  \domain{LocalId} $\cup$ \domain{GlobalId},
g \elt \domain{GlobalId},
% $\gvars \cup \lvars$ \\ 
c \elt $\vals$,
p \elt \domain{ProcId}
}
\end{tabular}
}
\caption{Programming language syntax and meta-variables}
 \label{fig:grammar}
\end{figure}

In Fig.~\ref{fig:grammar}, we present the syntax of a simple
programming language that we address in this paper.
%Most of the statements are standard statements borrowed
%from imperative languages. The rest of them are explained next.
A \code{return} statement is permitted only as the last statement of
the procedure.
%The language does not contain a \code{return} statement.
%At the end of execution of the procedure body, the procedure returns
%the final value of a special variable (indicated in the procedure declaration).
The language does not contain any looping construct.
Loops can be modelled as recursive procedures.
The formal parameters of a procedure are readonly and cannot be
modified within the procedure.
We omit types from the language.
Note that expressions are pure in this language, and a procedure call
is not allowed in an expression. Each procedure call is modelled as a
separate statement.
%The
%statement `\code{havoc x}' assigns any value from the domain of the variable
%`\code{x}' to variable `\code{x}'.
%% to variable `x' from the declared domain of `x'
%% And the statement `assume x' allows the execution of the program to
%% proceed if the predicate `x' holds at the program point, otherwise it
%% halts the execution.

For simplicity in notation, we assume, without loss of generality,
that the library consists of a single procedure, with a single formal
parameter. We will abuse terminology and use the terms procedure and library interchangeably.
In the sequel, we will use the symbol $\proc$ (as a metavariable) to represent the procedure/library,
while we use $\procname$ (as a metavariable) to represent the \emph{name} of the procedure.
If the procedure of the form ``\code{p (n) \{ S; return r \}}'', we refer to \code{r} as the \emph{return}
variable and we refer to ``\code{S; return r}'' as the \emph{procedure body} and denote it $\text{body}(\proc)$.
The library also includes a sequence of initializing declarations of globals of the form ``\code{g := c}'', indicating
that \code{g} is initialized to the value \code{c} when execution begins.
%, and a single global variable.
