\section{Language Syntax}
\label{sec:background}

In this paper, we assume that the input to the purity checker is a library consisting
of one or more procedures, with shared state consisting of one or more variables
that are private to the library. We refer to these variables as ``global'' variables to
indicate that they retain their values across multiple invocations of the library
procedures, but they cannot be accessed or modified by procedures outside
the library (that is, the clients of the library).

\begin{figure}[t!]
  %% \includegraphics[trim={0 5cm  3cm 0}, width=6cm]{grammar.eps}
  \begin{grammar}
    <statement> ::= <ident> = <logical-expr>
    \alt <ident> = <arithmetic-expr>
    \alt <statement>; <statement>
    \alt if<logical-expr> then <statement> else <statement>
    %% \alt while<logical-expr> do <statement>
    %% \alt <ident> = foo(<params-list>)
    %% \alt assume(<logical-expr>)
    \alt <ident> = <ident> (<ident>)
    %% \alt havoc(<ident>)
    %% \alt <ident>[<ident>] = <ident>
    %% \alt <ident> = <ident>[<ident>]

    %% <params-list> ::= <params-list> , <ident>
    %% \alt <ident>

    <arithmetic-expr> ::= <ident> <arithmetic-op> <ident> | <ident> | <constant>

     <arithmetic-op> ::= "+"  |  "-"  |  "/"  |  "*" |  "\%"
 
    <logical-expr> ::= <ident> <relational-op> <ident>
    \alt <logical-expr> $\wedge$ <logical-expr>
    \alt <logical-expr> $\vee$ <logical-expr>
    \alt $\neg$<logical-expr>
    \alt true
    \alt false

     <relational-op> ::= "<" | ">"| "==" | "!=" | $\leq$ | $\geq$

    <ident> ::= <local-ident> | <global-ident> | <proc-ident>
 
    <global> ::= global <ident>   

    <procedure> ::= <ident> (<ident>) "{" <statement> ; return <ident> "}"

    <globals> ::= <global> <globals> | $\epsilon$

    <procedures> ::= <procedure> <procedures> | $\epsilon$

    <library> ::= <globals> <procedures>
  \end{grammar}
  \caption{Programming language syntax}
  \label{fig:grammar}
\end{figure}

In Fig.~\ref{fig:grammar}, we present the syntax of a simple
programming language that we address in this paper.
%Most of the statements are standard statements borrowed
%from imperative languages. The rest of them are explained next.
A \code{return} statement is permitted only as the last statement of
the procedure.
%The language does not contain a \code{return} statement.
%At the end of execution of the procedure body, the procedure returns
%the final value of a special variable (indicated in the procedure declaration).
The language does not contain any looping construct.
Loops can be modelled as recursive procedures.
The formal parameters of a procedure are readonly and cannot be
modified within the procedure.
The
statement `\code{havoc x}' assigns any value from the domain of the variable
`\code{x}' to variable `\code{x}'.
%% to variable `x' from the declared domain of `x'
%% And the statement `assume x' allows the execution of the program to
%% proceed if the predicate `x' holds at the program point, otherwise it
%% halts the execution.

For simplicity in notation, we will assume, without loss of generality,
that the library consists of a single procedure, with a single formal
parameter. We will use the terms procedure and library interchangeably.
In the sequel, we will use the symbol $\proc$ (as a metavariable) to represent the procedure,
while we use $\procname$ (as a metavariable) to represent the \emph{name} of the procedure.
Thus, $\proc$ is of the form ``\code{p (n) \{ S; return r \}}''. We refer to \code{r} as the \emph{return}
variable.
%, and a single global variable.