\section{Language Syntax} \label{sec:background}

\subsection{Programming Language}

In this paper, we assume that the input to the purity checker is a library consisting
of one or more procedures, with shared state consisting of one or more variables
that are private to the library. We refer to these variables as ``global'' variables to
indicate that they retain their values across multiple invocations of the library
procedures, but they cannot be accessed or modified by procedures outside
the library (that is, the clients of the library).

\begin{figure}[t!]
  %% \includegraphics[trim={0 5cm  3cm 0}, width=6cm]{grammar.eps}
  \begin{grammar}
    <statement> ::= <ident> = <logical-expr>
    \alt <ident> = <arithmetic-expr>
    \alt <statement>; <statement>
    \alt if<logical-expr> then <statement> else <statement>
    %% \alt while<logical-expr> do <statement>
    %% \alt <ident> = foo(<params-list>)
    %% \alt assume(<logical-expr>)
    \alt <ident> = <ident> (<ident>)
    \alt havoc(<ident>)
    %% \alt <ident>[<ident>] = <ident>
    %% \alt <ident> = <ident>[<ident>]

    %% <params-list> ::= <params-list> , <ident>
    %% \alt <ident>

    <arithmetic-expr> ::= <ident> <arithmetic-op> <ident> | <ident> | <constant>

     <arithmetic-op> ::= "+"  |  "-"  |  "/"  |  "*" |  "\%"
 
    <logical-expr> ::= <ident> <relational-op> <ident>
    \alt <logical-expr> $\wedge$ <logical-expr>
    \alt <logical-expr> $\vee$ <logical-expr>
    \alt $\neg$<logical-expr>
    \alt true
    \alt false

     <relational-op> ::= "<" | ">"| "==" | "!=" | $\leq$ | $\geq$

    <ident> ::= <local-ident> | <global-ident>
 
    <global> ::= global <ident>   

    <procedure> ::= procedure <ident> (<ident>) returns <ident> {<statement>;}

    <globals> ::= <global> <globals> | $\epsilon$

    <procedures> ::= <procedure> <procedures> | $\epsilon$

    <library> ::= <globals> <procedures>
  \end{grammar}
  \caption{Programming language syntax}
  \label{fig:grammar}
\end{figure}

In Fig.~\ref{fig:grammar}, we present the syntax of a simple
programming language that we address in this paper.
 Most of the statements are standard statements borrowed
from imperative languages. The rest of them are explained next.
The language does not contain a \code{return} statement.
At the end of execution of the procedure body, the procedure returns
the final value of a special variable (indicated in the procedure declaration).
The language does not contain any looping construct.
Loops can be modelled as recursive procedures.
The formal parameters of a procedure are readonly and cannot be
modified within the procedure.
The
statement `\code{havoc x}' assigns any value from the domain of the variable
`\code{x}' to variable `\code{x}'.
%% to variable `x' from the declared domain of `x'
%% And the statement `assume x' allows the execution of the program to
%% proceed if the predicate `x' holds at the program point, otherwise it
%% halts the execution.

For simplicity in notation, we will assume, without loss of generality,
that the library consists of a single procedure, with a single formal
parameter, and a single global variable.

\begin{itemize}
%\item We analyze a single procedure in isolation and we assume that no
%  other procedure writes to the global variables accessed by procedure
%  \foo. In-case of multiple procedures, the invariant has multiple
%  function symbols, one for each procedure. 
\item All variables are defined before use, except global variables.
\item The variable assigned the return value in a procedure call
  statement is always a local variable.
\item There is at max one procedure call statement in every straight line
  execution of \foo from the beginning until it's
  end.
  \end{itemize}
%% Note : all of the above mentioned restrictions can be omitted. They
%% are for convenience.

\subsection{Invariant}\label{sec:invariant}

\begin{definition}[invariant]
  Invariant $\inv$ represents the set of
  global states at the boundaries of a procedure. $\inv$ is a formula,
  with global variables accessed by the given procedure and a
  uninterpreted function symbol $\F$ as the set of free variables. The
  uninterpreted function symbol $\F$ is a placeholder for the
  mathematical function equivalent to the given procedure. The initial
  global state satisfies the invariant.
\end{definition}

The invariant is produced by syntactically analyzing the
program. Invariant is expressed in a logic with un-interpreted
functions. The uninterpreted function is used to abstract out the
recursive procedure calls. It is assumed that the uninterpreted
function symbol represents the same mathematical function as the given
procedure. For example for procedure factorial in
listing~\ref{lst:factorialSimple} we use the invariant $\mathit{g = -1
  \vee g = \F(2) * 3}$, where $\F(2)$ is assumed to be equal to $x$,
$x = \mi{factorial(2)}$.