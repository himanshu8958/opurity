\section{Language Syntax} \label{sec:background}

\subsection{Programming Language}
We make the following restrictions on the structure of the program to
simplify the analysis without loss of generality. ( too much detail in
this and the next section, suggest level of abstraction)

\begin{itemize}
\item The given procedure (\foo) has a single argument i.e `\n'. And
  `\n' is never modified in \foo.
\item Procedure \foo has a single global variable, named `\g'.
\item Return statement is absent from our programming language. Instead,
  we have a special variable `\retVar', which is assigned the return
  value.
\item We analyze a single procedure in isolation and we assume that no
  other procedure writes to the global variables accessed by procedure
  \foo. In-case of multiple procedures, the invariant has multiple
  function symbols, one for each procedure. 
\item All variables are defined before use, except global variables.
\item All loops in procedure \foo are substituted with 
  separate recursive procedures.
\item The variable assigned the return value in a procedure call
  statement is always a local variable.
\item There is at max one procedure call statement in every straight line
  execution of \foo from the beginning until it's
  end.
  \end{itemize}
%% Note : all of the above mentioned restrictions can be omitted. They
%% are for convenience.

In Figure~\ref{fig:grammar}, we present the grammar for the
programming language which we have assumed for our static analysis
approaches.  Most of the statements are standard statements borrowed
from imperative languages. The rest of them are explained next. The
statement `havoc x' assigns any value from the domain of the variable
`x' to variable `x'.
%% to variable `x' from the declared domain of `x'
%% And the statement `assume x' allows the execution of the program to
%% proceed if the predicate `x' holds at the program point, otherwise it
%% halts the execution.

\begin{figure}[hb!]
  %% \includegraphics[trim={0 5cm  3cm 0}, width=6cm]{grammar.eps}
  \begin{grammar}
    <statement> ::= <ident> = <constant>
    \alt <ident> = <logical-expr>
    \alt <ident> = <arithmetic-expr>
    \alt <statement>; <statement>
    \alt if<logical-expr> then <statement> else <statement>
    %% \alt while<logical-expr> do <statement>
    %% \alt <ident> = foo(<params-list>)
    %% \alt assume(<logical-expr>)
    \alt <ident> = \foo(<ident>)
    \alt havoc(<ident>)
    %% \alt <ident>[<ident>] = <ident>
    %% \alt <ident> = <ident>[<ident>]

    %% <params-list> ::= <params-list> , <ident>
    %% \alt <ident>

    <arithmetic-expr> ::= <ident> <arithmetic-op> <ident>

     <arithmetic-op> ::= "+"  |  "-"  |  "/"  |  "*" |  "\%"
 
    <logical-expr> ::= <ident> <relational-op> <ident>
    \alt <logical-expr> $\wedge$ <logical-expr>
    \alt <logical-expr> $\vee$ <logical-expr>
    \alt $\neg$<logical-expr>
    \alt true
    \alt false

     <relational-op> ::= "<" | ">"| "==" | "!=" | $\leq$ | $\geq$

    <ident> ::= <local-ident>
    \alt <global-ident>
    
    <procedure> ::= procedure foo ($\n$) {<statement>;}
  \end{grammar}
  \caption{Grammar for our programming language}
  \label{fig:grammar}
\end{figure}

\subsection{Our intermediate representation}\label{sec:intermediate}
We transform the given procedure into the following representation
in-order to encode it in logic. For example procedure factorial
in Listing~\ref{lst:factorialTransformed}, is the transformed version
of procedure factorial in Listing~\ref{lst:factorialSimple}.

Our analysis expects the following :
\begin{enumerate}
\item Expressions do not have procedure call statements as
  sub-expressions.(omit? too much detail)
\item Procedure calls are approximated using function symbols. The
  statement `x = foo(y)' is replaced with `x = $\F$(y)'. Since
  procedure calls may modify global variables, we add the statement
  `havoc g' for each global variable `g' accessible from the
  procedure.
\item The input procedure has `m' procedure calls.
\item Next, the procedure must have extra variables to store the value
  of global variables at procedure boundaries. Before the
  $\mathit{i^{th}}$ procedure call, we add the statement `gbef$_i$ =
  g' and after it we add `gaft$_i$ = g'. Similarly, we add the
  statement `gout = g' after the assignment to the variable `\retVar'.
\item The procedure should be in static single assignment (SSA)
  form. The procedure should be converted to SSA after the above
  mentioned points have been satisfied.
\end{enumerate}

\begin{lstlisting}[language=c, caption= {Procedure factorial from
      Listing~\ref{lst:factorialSimple} converted to the form our
      approach expects. We refer to this procedure as `transformed
      factorial'.}, label=lst:factorialTransformed]
int g = -1;
int transformedFactorial( int n) { // redo
  if(n <= 1) {
    retVar = 1;
    gout = g;
  } else if(g == -1 && n == 19) {
    gbef1 = g;
    temp1 = F(18);  // temp1 = factorial(18)
    havoc(g1);
    gaft1 = g1;
    g2 = 19 * temp1;
    retVar = g2;
    gout = g2;
  } else if (g != -1 && n == 19) {
    retVar = g;
    gout = g;
  } else {
    gbef2 = g;
    temp2 = F( n - 1 );  //temp2 = factorial(n-1)
    havoc(g2);
    gaft2 = g3;
    retVar = n * temp2;
    gout = g3;
  }
}
\end{lstlisting}

%% In procedure `transformedFactorial'
%% Listing~\ref{lst:factorialTransformed}, in comparison to procedure
%% factorial in Listing~\ref{lst:factorialSimple}, the return statement
%% (line 4) is replaced by an assignment to variable `\retVar' (line
%% 4). After line 5 of `transformed factorial', an extra variable `gout'
%% is assigned the value of global variable `g' (value of `g' at end of
%% program).  Similarly, variable `gbef1' (line 7, `transformed
%% factorial') is added to capture the value of the global variable
%% before the procedure call (a program boundary), and variable `gaft1'
%% is inserted at line 11 to capture the value of `g' after the procedure
%% call. Also, havoc statements at line 8, 20 and 9, 21 over-approximate
%% the return from the procedure call statement and updates to the global
%% variable respectively. The procedure call statement is substituted
%% with function symbols in line 10 and 22, accounting the given
%% procedure as a function.

Now we compare `transformed factorial' and procedure factorial from
Listings~\ref{lst:factorialTransformed} and \ref{lst:factorialSimple}
respectively. The return statement (line 4) in procedure factorial
is replaced by assignment to variable `\retVar' (line 4). Also, we
have a added an assignment statement (line 5) in `transformed
factorial', that defines variable `gout' in-order to store the value
of variable `g' at the procedure boundary. Similarly, variable `gbef1'
(line 7) is added in `transformed factorial' to capture the value of
the global variable before the procedure call and assignment to
variable `gaft1' is inserted at line 10 to capture the value of `g'
after the procedure call. Also, havoc statements at lines 9 and 20
over-approximate any side effects to the global variables. And in
lines 8 and 19, the procedure call statements are substituted for
function symbols.

\subsection{Invariant}\label{sec:invariant}

\begin{definition}[invariant]
  Invariant $\inv$ represents the set of
  global states at the boundaries of a procedure. $\inv$ is a formula,
  with global variables accessed by the given procedure and a
  uninterpreted function symbol $\F$ as the set of free variables. The
  uninterpreted function symbol $\F$ is a placeholder for the
  mathematical function equivalent to the given procedure. The initial
  global state satisfies the invariant.
\end{definition}

The invariant is produced by syntactically analyzing the
program. Invariant is expressed in a logic with un-interpreted
functions. The uninterpreted function is used to abstract out the
recursive procedure calls. It is assumed that the uninterpreted
function symbol represents the same mathematical function as the given
procedure. For example for procedure factorial in
listing~\ref{lst:factorialSimple} we use the invariant $\mathit{g = -1
  \vee g = \F(2) * 3}$, where $\F(2)$ is assumed to be equal to $x$,
$x = \mi{factorial(2)}$.