\newcommand{\elt}{\ensuremath{\in} }
\newcommand{\domain}[1]{#1}

\section{Language Syntax}
\label{sec:background}

In this paper, we assume that the input to the purity checker is a library consisting
of one or more procedures, with shared state consisting of one or more variables
that are private to the library. We refer to these variables as ``global'' variables to
indicate that they retain their values across multiple invocations of the library
procedures, but they cannot be accessed or modified by procedures outside
the library (that is, the clients of the library).

\begin{figure}[t!]
{\tt
\begin{tabular}{rll}
L \elt & \domain{Lib} & ::= $\overline{\code{g := c}}$ $\overline{\code{P}}$ \\
P \elt & \domain{Proc} & ::= p (x) \{ S; return y \} \\
S \elt & \domain{Stmt} & ::=  x := e | x := p(y) | S ; S | if (e) then S else S \\
e \elt & \domain{Expr} & ::= c | x | e op e | unop e \\
op \elt & \domain{Ops} & ::= + | - | / | * | \% | > | < | == | $\wedge$ | $\vee$ \\
unop \elt & \domain{UnOps} & ::= $\neg$ \\
\multicolumn{3}{c}{
x, y \elt  \domain{LocalId} $\cup$ \domain{GlobalId},
g \elt \domain{GlobalId},
% $\gvars \cup \lvars$ \\ 
c \elt $\vals$,
p \elt \domain{ProcId}
}
\end{tabular}
}
\caption{Programming language syntax and meta-variables}
 \label{fig:grammar}
\end{figure}

In Fig.~\ref{fig:grammar}, we present the syntax of a simple
programming language that we address in this paper.
Given the foundational focus of this work, we keep the programming
language very simple, but the ideas we present can be generalized.
%Most of the statements are standard statements borrowed
%from imperative languages. The rest of them are explained next.
A \code{return} statement is required in each procedure,
and is permitted only as the last
statement of the procedure.
%The language does not contain a \code{return} statement.
%At the end of execution of the procedure body, the procedure returns
%the final value of a special variable (indicated in the procedure declaration).
The language does not contain any looping construct.
Loops can be modelled as recursive procedures.
The formal parameters of a procedure are readonly and cannot be
modified within the procedure.
We omit types from the language. We permit only variables of primitive types.
In particular, the language does not allow pointers or dynamic memory allocation.
Note that expressions are pure (that is, they have no side effects) in this language, and a procedure call
is not allowed in an expression. Each procedure call is modelled as a
separate statement.
%The
%statement `\code{havoc x}' assigns any value from the domain of the variable
%`\code{x}' to variable `\code{x}'.
%% to variable `x' from the declared domain of `x'
%% And the statement `assume x' allows the execution of the program to
%% proceed if the predicate `x' holds at the program point, otherwise it
%% halts the execution.

For simplicity of presentation, without loss of conceptual generality, we assume
that the library consists of a single (possibly recursive) procedure, with a single formal
parameter.
% We will abuse terminology and use the terms procedure and library interchangeably.
In the sequel, we will use the symbol $\proc$ (as a metavariable) to
represent this library procedure, $\procname$ (as a metavariable) to
represent the \emph{name} of this procedure, and will assume that the name
of the formal parameter is \code{n}. 
If the procedure is of the form ``$\procname$ \code{ (n) \{ S; return r \}}'', we refer to \code{r} as the \emph{return}
variable, and  refer to ``\code{S; return r}'' as the \emph{procedure body}
and denote it as $\text{body}(\proc)$.
The library also contains, outside of the procedure's code,
a sequence of initializing declarations of
the global variables used in the procedure, of the form ``\code{g1 := c1};
$\ldots$; \code{gN := cN}''. These initializations are assumed to be
performed  once during any execution of the client application,
just before the first call to the
procedure $\proc$ is placed by the client application.
%, and a single global variable.

 Finally, a note about terminology: throughout this paper we
 use the word `procedure' to refer to the library procedure $\proc$, and
 use the word
`function' to refer to a mathematical function.
