\section{Converting the program into logical formulae} \label{sec:approaches}

\subsection{Path condition generation}\label{sec:vcgen}
For our analysis we represent the given procedure in logic, such that
the representation captures the argument value at the beginning of the
procedure, the return value at the end of the procedure and the values
of the global variables at all the boundaries of the procedure. We
track the values of the global variables using extra variables as
explained in Section~\ref{sec:intermediate}. Thus, the set of free
variables in a path condition of a procedure are $X : \mi{\{n, gin,
  gout, g, \gbef_1 \cdots \gbef_m, \gaft_1 \cdots \gaft_m,}$ \\ ${\retVar, \F
  \}}$ all the remaining variables are universally quantified.

\begin{figure}
  \begin{align*}
    \pathCondition :=
    &(n \leq 1 \wedge retVar = 1 \wedge gout = g) \vee \\
    &(n > 1 \wedge g = -1 = gbef \wedge n = 19 \wedge temp1 = \F(18) \\
    \;&\wedge gaft1 = g1 \wedge g2 = 19 * temp1
    \wedge retVar = g2) \vee\\
    &(n > 1 \wedge \neg( g = -1 \wedge n = 19) \wedge g \neq -1
    \wedge n = 19 \wedge retVar = g = gout) \vee\\
    &(n > 1 \wedge n \neq 19 \wedge gbef2 = g \wedge temp2 = \F( n
    - 1) \wedge gaft2 = g1\\
    &\wedge retVar = n * temp2 \wedge gout = g1)\\
  \end{align*}
  \caption{Formula representing procedure `transformed factorial' in
    Listing~\ref{lst:factorialTransformed} (assuming that function
    $\F$ is equivalent to procedure factorial).}
  \label{fig:pathCondition}
\end{figure}

For example, the procedure `transformed factorial' in
Listing~\ref{lst:factorialTransformed} is expressed in logic as shown
in Figure~\ref{fig:pathCondition}. Each disjunct in
Figure~\ref{fig:pathCondition} represents a straight-line execution of
procedure factorial (from beginning, until end) . For instance, $(n <=
1 \wedge retVar = 1 \wedge gout = g)$ represents the case where $`n
\leq 1'$.

Representation of a program in logic is straight forward once it is
converted to our intermediate representation in
Section~\ref{sec:intermediate}. All the standard imperative statements
become conjuncts in the formula. `havoc' statements are omitted.
`assume x' are replaced with a conjunct `x' in the formula.

\subsection{Existential approach}\label{sec:existential}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckE
       & \mi{(\inv :
        invariant, \pathCondition : path \; condition)} \equiv \\
      &\forall \{X - \{\F\}\}.\\
      &\inv \wedge \inv[\gaft_1/\g] \wedge \inv[\gaft_2/\g] \wedge
      \cdots \inv[\gaft_m/\g] \\
      &\wedge \pathCondition \implies ( \retVar = \F(\n)\\
            & \wedge \inv[\gout/\g] \wedge  \inv[\gbef_1/\g] \wedge
      \inv[\gbef_2/\g] \wedge \cdots inv[\gbef_m/\g]) \\
    \end{align*}
    \caption{Existential check : produces a formula whose
      satisfiability implies the given procedure is observationally
      pure} 
    \label{algo:someOPcheckCombined}
  \end{algorithm}  
\end{figure}

The existential approach in Algorithm~\ref{algo:someOPcheckCombined}
encodes a formula $\formula_e$. In formula $\formula_e$, the invariant
is assumed at the beginning of the procedure, and after each procedure
call ( $m$ procedure calls in total).  We abstract all the recursive
procedure calls in the original procedure using function symbol $\F$
in $\pathCondition$.  Next, the return value is constrained to be
equivalent to $\F(n)$, where `n' is the parameter value. Formula
$\formula_e$ has a single free variable $\F$, and it is constrained to
respect the given procedure, for all values of the parameter `n' and
all values of the global variable `g'. Thus, if $\formula_e$ is SAT,
it implies that there exists a function which mimics the given
procedure. 

The check encoded in Figure~\ref{algo:someOPcheckCombined} cannot be
expressed using standard requires and ensures statements (to the best
of our knowledge). In the standard pre-post verification, the
unreachability of the compliment of the post-condition is ensured. In
contrast, our analysis just requires that the post condition is
reachable. We check if $\retVar = \F(n)$ is satisfiable, but this
suffices for our analysis.

\subsection{Impurity witness approach}\label{sec:impurityWitness}

\begin{figure}[htp]
  \begin{algorithm}[H]
    \begin{align*}
      \OPCheckA &\mi{(\inv : invariant,
        \pathCondition: path\; condition)} \equiv &\\
      &\inv[\g_\alpha/\g] \wedge \inv[\g_\beta/\g]  & (1)\\
      & \wedge \inv[\gaft_{\alpha1}/\g] \wedge
      \inv[\gaft_{\alpha2}/\g] \cdots \wedge \inv[\gaft_{\alpha m}/\g]
      & (2)\\
      & \wedge \inv[\gaft_{\beta1}/\g] \wedge \inv[\gaft_{\beta2}/\g]
      \cdots \wedge \inv[\gaft_{\beta m}/\g] & (3)\\
      &\wedge \n_\alpha = \n_\beta  & (4)\\
      &\wedge \pathCondition[\g_\alpha/\g, \n_\alpha/\n, \retVar_\alpha/\retVar,
        \gout_\alpha/\gout, & (5)\\
        &\gbef_{\alpha1}/\gbef_1 \cdots, \gaft_{\alpha 1}/\gaft_1, \cdots
        \gaft_{\alpha m}/\gaft_m]  & (6)\\
      &\wedge \pathCondition[\g_\beta/\g, \n_\beta/\n, \retVar_\beta/\retVar,
        \gout_\beta/\gout, & (7)\\
        &\gbef_{\beta1}/\gbef_1 \cdots, \gaft_{\beta 1}/\gaft_1, \cdots
        \gaft_{\beta m}/\gaft_m] & (8)\\
      &\wedge (\retVar_\alpha \neq \retVar_\beta \vee \neg\inv[\gbef_{\alpha1}/\g] \vee
       \cdots \neg\inv[\gbef_{\alpha m}/\g] & (9) \\
        &\vee \neg\inv[\gout_\alpha/\g])  & (10)\\
    \end{align*}
    \caption{Impurity witness : produces a formula whose unsatisfiability
    implies observational purity.}
    \label{algo:pairwiseOPcheckCombined}
  \end{algorithm}  
\end{figure}

The impurity witness approach in
Algorithm~\ref{algo:pairwiseOPcheckCombined} encodes formula
$\formula_{iw}$. If $\formula_{iw}$ is UNSAT the given procedure is
OP. The idea encoded in $\formula_{iw}$ is that if a pair of traces of
the given procedure exists such that the traces start with the same
parameter value, and potentially different values for the global
variables return different results, then the procedure is not OP. In
this case, we have a witness to the non-OPness of the given
procedure. Otherwise, we prove that the given procedure is OP (this
proof will be mentioned in the final version of this paper).

The check encoded in Figure~\ref{algo:pairwiseOPcheckCombined}, cannot
be expressed in standard requires and ensures (again, to the best of
our knowledge). As the approach compares the given procedure with
itself, standard requires and ensures do not suffice. But works such as
\cite{lahiri2013differential} can be used to express this property. 

\subsection{Comparing the two approaches}

\begin{lstlisting}[caption={Procedure `bar': illustrates that
      existential approach is more precise that the impurity witness
      approach.}, label=lst:comparison]
int bar(int n) { 
  return g; 
}
\end{lstlisting}

The existential approach in Section~\ref{sec:existential} is more
precise than the impurity witness approach in
Section~\ref{sec:impurityWitness}. The existential approach requires
one mathematical function, such that it mimics the given procedure and
the invariant holds for this function to mark a procedure OP. On the
other hand, the impurity witness marks a procedure OP if for all
functions, the two instances of the path condition agree on the return
value. For instance procedure `bar' in Listing~\ref{lst:comparison} is
observationally pure for the invariant $(g = \F(0) \vee g = \F(1))$
and it mimics the mathematical function $\forall n. \F(0) = \F(1) =
\F(n)$ (thus, it must be a constant function). Now, the existential
approach marks this procedure as OP whereas the impurity witness
approach marks it as non-OP. The existential approach marks this
example OP, considering a function $\lambda n. 2$. Whereas there are
many functions $\F'$ such that $\F'(0) \neq \F'(1)$, now the procedure
`bar' is not OP for the invariant $(g = \F(0) \vee g =
\F(1))[\F'/\F]$.

Although the existential approach is more precise, the impurity
witness approach performs better with SAT-SMT solvers. In case of the
existential approach the solver has to find a satisfying assignment
for the free variable $\F$. Whereas, in case of the impurity witness
approach, the inequivalence is contradicted (if procedure is OP).