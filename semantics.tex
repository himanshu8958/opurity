
\newcommand{\vals}{\mathcal{V}}
\newcommand{\gvars}{G}
\newcommand{\lvars}{L}
\newcommand{\gmap}{\rho_g}
\newcommand{\gmaps}{\Sigma_G}
\newcommand{\lmap}{\rho_\ell}
\newcommand{\lmaps}{\Sigma_L}
\newcommand{\cstates}{\Sigma_C}
\newcommand{\cont}{c}
\newcommand{\lstack}{\gamma}
\newcommand{\initstate}{\sigma_{\text{init}}}

\newcommand{\initial}[1]{\textit{initial}(#1)}
\newcommand{\final}[1]{\textit{final}(#1)}
\newcommand{\inputval}[1]{\textit{input}(#1)}
\newcommand{\outputval}[1]{\textit{output}(#1)}

\newcommand{\extmap}{\sigma_e}


\newcommand{\iosem}[1]{\rightsquigarrow_{#1}}
\newcommand{\iosemP}{\iosem{\proc}}
\newcommand{\sssem}[1]{\rightarrow_{#1}}
\newcommand{\sssemP}{\sssem{\proc}}

\newcommand{\basicevalsto}[3]{ ({#1},{#2}) \Downarrow {#3}}
\newcommand{\evalsto}[4]{ ({#1} \uplus {#2},{#3}) \Downarrow {#4}}

\newcommand{\labrule}[3]{\inferrule*[Lab={[#1]}]{#2}{#3}}

\section{A Semantic Definition of Purity}

In this section, we formalize the input-output semantics of a procedure $\proc$ as a relation $\iosem{\proc}$,
where $n \iosem{\proc} r$ indicates that an invocation of $\proc$ with input $n$ may return a result of $r$.
The procedure is then defined to be observationally pure if the relation $\iosem{\proc}$ is a (partial) function:
that is, if  $n \iosem{\proc} r_1$ and $n \iosem{\proc} r_2$, then $r_1 = r_2$.

The object of our analysis is a single procedure or, more generally, a collection of procedures (a library),
and not a whole program. The result of our analysis is valid for any program that uses the procedure/library.
The only assumptions we make are: (a) The shared state used by the library (the global variables) are private
to the library and cannot be modified by the rest of the program, and (b) The client invokes the library
procedures sequentially: no concurrent or overlapping invocations of the library procedures by a concurrent
client are permitted.

The following semantic formalism is motivated by the above observations. It can be seen as the semantics
of the so-called ``most general sequential client'' of procedure $\proc$, which is the program:
\code{while (*) { x = \proc(random()); }}.
The executions (of $\proc$) produced by this program include all executions (of $\proc$)  produced by all
sequential clients.

Let $\gvars$ denote the set of global variables. Let $\lvars$ denote the set of local variables.
Let $\vals$ denote the set of numeric values (that the variables can take).
An element $\gmap \in \gmaps = \gvars \hookrightarrow \vals$ maps global variables to their values.
An element $\lmap \in \lmaps = \lvars \hookrightarrow \vals$ maps local variables to their values.
We define a \emph{local continuation} to be a statement sequence ending with a \code{return} statement.
We use a local continuation to represent the part of the procedure body that still remains to be
executed. Let $\cstates$ represent the set of local continuations.
% We use an element $\cont \in \cstates$ to represent
% what remains to be executed in the procedure (and can, hence, be thought of as a program-point
% representing what is to be executed next).
The set of runtime states is defined to be $(\cstates \times \lmaps)^* \times \gmaps$, where
the first component represents a runtime stack, and the second component the values of global
variables. The runtime stack is a sequence, each element of which is a pair $(\stmt,\lmap)$ consisting of the
remaining procedure fragment $\stmt$ to be executed and the values of local variables $\lmap$.
We write $(\stmt,\lmap)\gamma$ to indicate a stack where the topmost entry is $(\stmt,\lmap)$
and $\gamma$ represents the remaining part of the stack.

We say that a state $((\stmt,\lmap)\gamma,\gmap)$ is an \emph{entry-state} if its location is at
the procedure entry point (\ie, if $\stmt$ is the entire body of the procedure),
and we say that it is an \emph{exit-state} if its location is at the procedure exit point
(\ie, if $\stmt$ consists of just a \code{return} statement).

A procedure $\proc$ determines a single-step execution relation $\sssem{\proc}$,
where $\sigma_1 \sssem{\proc} \sigma_2$ indicates
that execution proceeds from state $\sigma_1$ to state $\sigma_2$ in a single step.
Fig.~\ref{fig:semantics} defines this semantics.
The semantics of evaluation of a side-effect-free expression is captured
by a relation $\basicevalsto{\rho}{\expr}{v}$, indicating that the expression
$\expr$ evaluates to value $v$ in an environment $\rho$ (which contains bindings
of values to all identifiers occurring in $\expr$, both global and local).

Note that most rules captures the usual semantics of the language constructs.
The last two rules, however, capture the semantics of the most-general sequential
client explained previously: when the call stack is empty, a new invocation of
the procedure may be initiated (with an arbitrary parameter value).

%We encode invocations of the procedure using the same relation $\sssem{\proc}$: 
%$\sigma \sssem{\proc} \sigma'$  holds if $\sigma$ is an exit-state, $\sigma'$ is an entry-state,
%and $\sigma$ and $\sigma'$ agree on the values of all global variables (but the value of the formal
%parameter $n$ may be arbitrary in $\sigma'$ to indicate an invocation of the procedure with that
%parameter value).

\begin{figure}
\begin{mathpar}
\labrule{assgn}{
\code{x} \in \lvars \\
\evalsto{\lmap}{\gmap}{\code{e}}{v}
}{
((\code{x := e; S}, \lmap) \lstack, \gmap)
\sssemP 
((\code{S}, \lmap[\code{x} \mapsto v]) \lstack, \gmap)
}

\labrule{assgn}{
\code{x} \in \gvars \\
\evalsto{\lmap}{\gmap}{\code{e}}{v}
}{
((\code{x := e; S}, \lmap) \lstack, \gmap)
\sssemP 
((\code{S}, \lmap) \lstack, \gmap[\code{x} \mapsto v])
}

\labrule{seq}{}{
(((\stmtSA ; \stmtSB) ; \stmtSC , \lmap) \lstack, \gmap) 
\sssemP
((\stmtSA ; (\stmtSB ; \stmtSC) , \lmap) \lstack, \gmap) 
}

\labrule{if-true}{
\evalsto{\lmap}{\gmap}{\expr}{\code{true}}
}{
( (\code{(if (\expr) then \stmtSA else \stmtSB); \stmtSC}, \lmap) \lstack, \gmap)
\sssemP
( (\code{\stmtSA; \stmtSC}, \lmap) \lstack, \gmap)
}

\labrule{if-false}{
\evalsto{\lmap}{\gmap}{\expr}{\code{false}}
}{
( (\code{(if (\expr) then \stmtSA else \stmtSB); \stmtSC}, \lmap) \lstack, \gmap)
\sssemP
( (\code{\stmtSB; \stmtSC}, \lmap) \lstack, \gmap)
}

\labrule{call}{
\evalsto{\lmap}{\gmap}{\code{e}}{v} \\
\proc = \code{p(n) \stmtSA}
}{
((\code{y = p(e); \stmtSB}, \lmap) \lstack, \gmap)
\sssemP
((\stmtSA, [n \mapsto v]) (\code{y = p(e); \stmtSB}, \lmap) \lstack, \gmap)
}

\labrule{return}{
\evalsto{\lmap}{\gmap}{r}{v}
}{
((\code{return r}, \lmap) (\code{y = p(e); \stmt}, \lmap') \lstack, \gmap)
\sssemP
(\stmt, \lmap'[ \code{y} \mapsto v]) \lstack, \gmap)
}

\labrule{top-level-call}{
\proc = \code{p(n) \stmtSA} \\
v \in \vals
}{
([], \gmap)
\sssemP
([(\stmtSA, [n \mapsto v])], \gmap)
}

\labrule{top-level-return}{
}{
[(\code{return r}, \lmap)], \gmap)
\sssemP
([], \gmap)
}

\end{mathpar}
\caption{A small-step operational semantics for our language.}
\label{fig:semantics}
\end{figure}

Note that all the following definitions are parametric over a given procedure $\proc$.
(Thus, what we refer to as an execution below is shorthand for ``execution of $\proc$''.

We define an \emph{execution} (of $\proc$) to be a sequence of states $\sigma_0 \sigma_1 \cdots \sigma_n$ such that
$\sigma_i \sssem{\proc} \sigma_{i+1}$ for all $0 \leq i < n$.
%(In this paper we consider only \emph{sequential} executions of the procedure. Thus, no concurrent invocations
%of the procedure by a concurrent client of the library is allowed.)
Let $\initstate$ denote the \emph{initial state} of the library.
We say that an execution $\sigma_0 \sigma_1 \cdots \sigma_n$ is a \emph{feasible} execution if $\sigma_0 = \initstate$.
We say that a state $\sigma$ is \emph{ reachable} if there exists an execution $\pi = \initstate \sigma_1 \cdots \sigma$.

We define a \emph{history} (of $\proc$) to be an execution $\pi = \sigma_0 \sigma_1 \cdots \sigma_n$ such that
(a) $\sigma_0$ is the initial state of the library,
(b) $\sigma_n$ is an exit-state, and
(c) $\pi$ has an equal number of entry-states and exit-states.
Note that a history represents a complete  execution produced by a
sequence of invocations of the procedure.

We say that an execution is a \emph{trace} (of $\proc$) if it represents the complete execution
of the procedure produced by a single invocation of the procedure.
Note, however, that a trace may contain nested sub-traces,
which are themselves traces, due to recursive calls.

Given a trace $\pi = \sigma_0 \cdots \sigma_n$, we define
$\initial{\pi}$ to be $\sigma_0$,
$\final{\pi}$ to be $\sigma_n$,
$\inputval{\pi}$ to be value of the input parameter in $\initial{\pi}$,
and $\outputval{\pi}$ to be the value of the return variable in $\final{\pi}$.

We define the relation $\iosemP$ to be $\{ (\inputval{\pi},\outputval{\pi}) \; | \; \pi \text{ is a trace of } \proc \}$.
% we say $n \iosemP r$ if there exists a reachable exit state where the value of formal
% parameter is $n$ and return value is $r$.

\begin{definition}[Observational Purity]
A procedure $\proc$ is said to be \emph{observationally pure} if the relation $\iosem{\proc}$ is a (partial) function:
that is, if for all $n$, $r_1$, $r_2$, if  $n \iosem{\proc} r_1$ and $n \iosem{\proc} r_2$, then $r_1 = r_2$.
\end{definition}

\subsection*{Logical Formula And Invariants}

Our methodology makes use of \emph{invariants}, which are represented using \emph{logical formulae}.
A  logical formula $\varphi$ is just a boolean-valued expression (in our language) over the set of global variables.
We write $\gmap \models \varphi$ as shorthand for $\basicevalsto{\gmap}{\varphi}{\code{true}}$ :
\ie, to denote that $\varphi$ evaluates to true in a state where the globals have values as in $\gmap$.

However, as we saw with our running example, it is useful to allow the use of the name of a procedure in
an invariant: \eg, an invariant such as ``$(g == -1) \vee (g == \text{factorial}(3))$''.
We extend our expression language by permitting the use of procedure identifiers as
function symbols (as above). Note that this extension is permitted only for use in logical
formula.

We extend our semantics $\models$ to handle such extended invariants as below.
Let $\extmap$ denote an extended map that assigns global variables a (numeric) value and assigns the
procedure names a mathematical function as a value. We can then extend the expression evaluation semantics
in a straightforward fashion to evaluate extended boolean expressions of the above form. 
We will write $\extmap \models \varphi_e$ to denote that the extended boolean expression $\varphi_e$
evaluates to true under $\extmap$.

Given a global state $\gmap$, a procedure name $\proc$, and a mathematical function $f$, we will write
$\gmap[\proc \mapsto f]$ to indicate the extended map that assigns $\proc$ the value $f$ and every
global $x$ the value $\gmap[x]$.
We will write $(\gmap,f) \models \varphi$ to denote that $\gmap[\proc \mapsto f] \models \varphi$.
Recall that a state $\sigma =(\lstack,\gmap)$ consists of a stack $\lstack$ and global-state $\gmap$.
We write $(\sigma,f) \models \varphi$ to denote that $(\gmap,f) \models \varphi$.
For any execution $\pi$, we write $(\pi,f) \models \varphi$ if for every entry-state and exit-state
$\sigma$ in $\pi$ $(\sigma,f) \models \varphi$.

%We say that a $\gmap \in \gmaps$ is a \emph{reachable global entry-state} of $\proc$ if
%there is a reachable entry-state of the form $(\lstack,\gmap)$.

\begin{definition}[Invariant]
Given a procedure $\proc$ and a mathematical function $f$, we say that $(\proc,f)$ satisfy
an invariant $\inv$ if for every feasible execution $\pi$ of $\proc$, $(\pi,f) \models \varphi$.
%for every reachable global entry-state $\gmap$ of $\proc$,
%$\inv$ holds in $\gmap[\proc \mapsto f]$: that is, if $\gmap[\proc \mapsto f] \models \inv$.
We say that procedure $\proc$ satisfies an invariant $\inv$ if there exists a (mathematical)
function $f$ such that $(\proc,f)$ satisfies $\inv$.
\end{definition}

\begin{definition}[Purity+Invariant]
A procedure $\proc$ is said to be observationally pure with a consistent invariant $\inv$ if
there exists a function $f$ such that for every trace $\pi$ of $\proc$,
$\outputval{\pi} = f(\inputval{\pi})$ and $(\proc,f)$ satisfies $\inv$.
\end{definition}