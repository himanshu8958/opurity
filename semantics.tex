
\newcommand{\vals}{\mathcal{V}}
\newcommand{\gvars}{G}
\newcommand{\lvars}{L}
\newcommand{\gmap}{\sigma_g}
\newcommand{\gmaps}{\Sigma_G}
\newcommand{\lstate}{\sigma_\ell}
\newcommand{\lstates}{\Sigma_L}
\newcommand{\cstates}{S}
\newcommand{\cont}{s}
\newcommand{\lstack}{\gamma}
\newcommand{\initstate}{\sigma_{\text{init}}}


\newcommand{\iosem}[1]{\rightsquigarrow_{#1}}
\newcommand{\iosemP}{\iosem{\proc}}
\newcommand{\sssem}[1]{\rightarrow_{#1}}
\newcommand{\sssemP}{\sssem{\proc}}

\section{A Semantic Definition of Purity}

In this section, we formalize the input-output semantics of a procedure $\proc$ as a relation $\iosem{\proc}$,
where $n \iosem{\proc} r$ indicates that an invocation of $\proc$ with input $n$ may return a result of $r$.
The procedure is then defined to be observationally pure if the relation $\iosem{\proc}$ is a (partial) function:
that is, if  $n \iosem{\proc} r_1$ and $n \iosem{\proc} r_2$, then $r_1 = r_2$.

The object of our analysis is a single procedure or, more generally, a collection of procedures (a library),
and not a whole program. The result of our analysis is valid for any program that uses the procedure/library.
The only assumptions we make are: (a) The shared state used by the library (the global variables) are private
to the library and cannot be modified by the rest of the program, and (b) The client invokes the library
procedures sequentially: no concurrent or overlapping invocations of the library procedures by a concurrent
client are permitted.

The following semantic formalism is motivated by the above observations. It can be seen as the semantics
of the so-called ``most general sequential client'' of procedure $\proc$, which is the program:
\code{while (*) { x = \proc(random()); }}.
The executions (of $\proc$) produced by this program include all executions (of $\proc$)  produced by all
sequential clients.

Let $\gvars$ denote the set of global variables. Let $\lvars$ denote the set of local variables.
Let $\vals$ denote the set of numeric values (that the variables can take).
An element $\gmap \in \gmaps = \gvars \hookrightarrow \vals$ maps global variables to their values.
An element $\lstate \in \lstates = \lvars \hookrightarrow \vals$ maps local variables to their values.
Let $\cstates$ represent the set of statements. We use an element $\cont \in \cstates$ to represent
what remains to be executed in the procedure (and can, hence, be thought of as a program-point
representing what is to be executed next).
The set of runtime states is defined to be $(\cstates \times \lstates)^* \times \gmaps$, where
the first component represents a runtime stack, and the second component the values of global
variables. The runtime stack is a sequence, each element of which is a pair consisting of the
remaining procedure fragment to be executed and the values of local variables.

We say that a state $\sigma$ is an \emph{entry-state} if its location is at the procedure entry point,
and we say that it is an \emph{exit-state} if its location is at the procedure exit point.
A procedure $\proc$ determines a single-step execution relation $\sssem{\proc}$, where $\sigma_1 \sssem{\proc} \sigma_2$ indicates
that execution proceeds from state $\sigma_1$ to state $\sigma_2$ in a single step.
We encode invocations of the procedure using the same relation $\sssem{\proc}$: 
$\sigma \sssem{\proc} \sigma'$  holds if $\sigma$ is an exit-state, $\sigma'$ is an entry-state,
and $\sigma$ and $\sigma'$ agree on the values of all global variables (but the value of the formal
parameter $n$ may be arbitrary in $\sigma'$ to indicate an invocation of the procedure with that
parameter value).

Note that all the following definitions are parametric over a given procedure $\proc$.
(Thus, what we refer to as an execution below is shorthand for ``execution of $\proc$''.

We define an \emph{execution} to be a sequence of states $\sigma_0 \sigma_1 \cdots \sigma_n$ such that
$\sigma_i \sssem{\proc} \sigma_{i+1}$ for all $0 \leq i < n$.
%(In this paper we consider only \emph{sequential} executions of the procedure. Thus, no concurrent invocations
%of the procedure by a concurrent client of the library is allowed.)
Let $\initstate$ denote the \emph{initial state} of the library.
We say that a state $\sigma$ is \emph{ reachable} if there exists an execution $\pi = \initstate \sigma_1 \cdots \sigma$.

We define a \emph{history} to be an execution $\pi = \sigma_0 \sigma_1 \cdots \sigma_n$ such that
(a) $\sigma_0$ is the initial state of the library,
(b) $\sigma_n$ is an exit-state, and
(c) $\pi$ has an equal number of entry-states and exit-states.
Note that a history represents a complete  execution produced by a
sequence of invocations of the procedure.

We say that an execution is a \emph{trace} if it represents the complete execution
of the procedure produced by a single invocation of the procedure.
Note, however, that a trace may contain nested sub-traces,
which are themselves traces, due to recursive calls.

We define the relation $\iosemP$ as follows:
we say $n \iosemP r$ if there exists a reachable exit state where the value of formal
parameter is $n$ and return value is $r$.

\begin{definition}[Observational Purity]
A procedure $\proc$ is said to be \emph{observationally pure} if the relation $\iosem{\proc}$ is a (partial) function:
that is, if for all $n$, $r_1$, $r_2$, if  $n \iosem{\proc} r_1$ and $n \iosem{\proc} r_2$, then $r_1 = r_2$.
\end{definition}

We say that a $\gmap \in \gmaps$ is a \emph{reachable global entry-state} of $\proc$ if
there is a reachable entry-state of the form $(\lstack,\gmap)$.

\begin{definition}[Invariant]
We say that procedure $\proc$ satisfies an invariant $\inv$ if there exists a (mathematical)
function $f$ such that for every reachable global entry-state $\gmap$ of $\proc$,
$\inv$ holds in $\gmap[\proc \mapsto f]$: that is, if $\gmap[\proc \mapsto f] \models \inv$.
\end{definition}