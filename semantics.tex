\section{A Semantic Definition of Purity}
\label{sec:semantics}

In this section, we formalize the input-output semantics of a procedure $\proc$ as a relation $\iosem{\proc}$,
where $n \iosem{\proc} r$ indicates that an invocation of $\proc$ with input $n$ may return a result of $r$.
The procedure is then defined to be observationally pure if the relation $\iosem{\proc}$ is a (partial) function:
that is, if  $n \iosem{\proc} r_1$ and $n \iosem{\proc} r_2$, then $r_1 = r_2$.

The object of our analysis is a single procedure or, more generally, a collection of procedures (a library),
and not a whole program. The result of our analysis is valid for any program that uses the procedure/library.
The only assumptions we make are: (a) The shared state used by the library (the global variables) are private
to the library and cannot be modified by the rest of the program, and (b) The client invokes the library
procedures sequentially: no concurrent or overlapping invocations of the library procedures by a concurrent
client are permitted.

The following semantic formalism is motivated by the above observations. It can be seen as the semantics
of the so-called ``most general sequential client'' of procedure $\proc$, which is the program:
\code{while (*) { x = $\procname$ (random()); }}.
The executions (of $\proc$) produced by this program include all possible executions (of $\proc$)  produced by all
sequential clients.

Let $\gvars$ denote the set of global variables. Let $\lvars$ denote the set of local variables.
Let $\vals$ denote the set of numeric values (that the variables can take).
An element $\gmap \in \gmaps = \gvars \hookrightarrow \vals$ maps global variables to their values.
An element $\lmap \in \lmaps = \lvars \hookrightarrow \vals$ maps local variables to their values.
We define a \emph{local continuation} to be a statement sequence ending with a \code{return} statement.
We use a local continuation to represent the part of the procedure body that still remains to be
executed. Let $\cstates$ represent the set of local continuations.
% We use an element $\cont \in \cstates$ to represent
% what remains to be executed in the procedure (and can, hence, be thought of as a program-point
% representing what is to be executed next).
The set of runtime states is defined to be $(\cstates \times \lmaps)^* \times \gmaps$, where
the first component represents a runtime stack, and the second component the values of global
variables. The runtime stack is a sequence, each element of which is a pair $(\stmt,\lmap)$ consisting of the
remaining procedure fragment $\stmt$ to be executed and the values of local variables $\lmap$.
We write $(\stmt,\lmap)\gamma$ to indicate a stack where the topmost entry is $(\stmt,\lmap)$
and $\gamma$ represents the remaining part of the stack.

We say that a state $((\stmt,\lmap)\gamma,\gmap)$ is an \emph{entry-state} if its location is at
the procedure entry point (\ie, if $\stmt$ is the entire body of the procedure),
and we say that it is an \emph{exit-state} if its location is at the procedure exit point
(\ie, if $\stmt$ consists of just a \code{return} statement).

A procedure $\proc$ determines a single-step execution relation $\sssem{\proc}$,
where $\sigma_1 \sssem{\proc} \sigma_2$ indicates
that execution proceeds from state $\sigma_1$ to state $\sigma_2$ in a single step.
Fig.~\ref{fig:semantics} defines this semantics.
The semantics of evaluation of a side-effect-free expression is captured
by a relation $\basicevalsto{\rho}{\expr}{v}$, indicating that the expression
$\expr$ evaluates to value $v$ in an environment $\rho$ (which contains bindings
of values to all identifiers occurring in $\expr$, both global and local).
We omit the definition of this relation, which is straightforward.
We use the notation $\rho_1 \uplus \rho_2$ to denote the union of two disjoint maps
$\rho_1$ and $\rho_2$.


Note that most rules captures the usual semantics of the language constructs.
The last two rules, however, capture the semantics of the most-general sequential
client explained previously: when the call stack is empty, a new invocation of
the procedure may be initiated (with an arbitrary parameter value).

%We encode invocations of the procedure using the same relation $\sssem{\proc}$: 
%$\sigma \sssem{\proc} \sigma'$  holds if $\sigma$ is an exit-state, $\sigma'$ is an entry-state,
%and $\sigma$ and $\sigma'$ agree on the values of all global variables (but the value of the formal
%parameter $n$ may be arbitrary in $\sigma'$ to indicate an invocation of the procedure with that
%parameter value).

\begin{figure}
\begin{small}
\begin{mathpar}
\labrule{assgn}{
\code{x} \in \lvars \\
\evalsto{\lmap}{\gmap}{\code{e}}{v}
}{
((\code{x := e; S}, \lmap) \lstack, \gmap)
\sssemP 
((\code{S}, \lmap[\code{x} \mapsto v]) \lstack, \gmap)
}

\labrule{assgn}{
\code{x} \in \gvars \\
\evalsto{\lmap}{\gmap}{\code{e}}{v}
}{
((\code{x := e; S}, \lmap) \lstack, \gmap)
\sssemP 
((\code{S}, \lmap) \lstack, \gmap[\code{x} \mapsto v])
}

\labrule{seq}{}{
(((\stmtSA ; \stmtSB) ; \stmtSC , \lmap) \lstack, \gmap) 
\sssemP
((\stmtSA ; (\stmtSB ; \stmtSC) , \lmap) \lstack, \gmap) 
}

\labrule{if-true}{
\evalsto{\lmap}{\gmap}{\expr}{\code{true}}
}{
( (\code{(if (\expr) then \stmtSA else \stmtSB); \stmtSC}, \lmap) \lstack, \gmap)
\sssemP
( (\code{\stmtSA; \stmtSC}, \lmap) \lstack, \gmap)
}

\labrule{if-false}{
\evalsto{\lmap}{\gmap}{\expr}{\code{false}}
}{
( (\code{(if (\expr) then \stmtSA{} else \stmtSB); \stmtSC}, \lmap) \lstack, \gmap)
\sssemP
( (\code{\stmtSB; \stmtSC}, \lmap) \lstack, \gmap)
}

\labrule{call}{
\evalsto{\lmap}{\gmap}{\code{e}}{v} \\
\proc = \code{$\procname$(n) \stmtSA}
}{
((\code{y := $\procname$(e); \stmtSB}, \lmap) \lstack, \gmap)
\sssemP
((\stmtSA, [n \mapsto v]) (\code{y := $\procname$(e); \stmtSB}, \lmap) \lstack, \gmap)
}

\labrule{return}{
\evalsto{\lmap}{\gmap}{\code{r}}{v}
}{
((\code{return r}, \lmap) (\code{y := $\procname$(e); \stmt}, \lmap') \lstack, \gmap)
\sssemP
(\stmt, \lmap'[ \code{y} \mapsto v]) \lstack, \gmap)
}

\labrule{top-level-call}{
\code{B} = \text{body}(\proc) \\
v \in \vals
}{
([], \gmap)
\sssemP
([(\code{B}, [n \mapsto v])], \gmap)
}

\labrule{top-level-return}{
}{
[(\code{return r}, \lmap)], \gmap)
\sssemP
([], \gmap)
}

\end{mathpar}
\end{small}
\caption{
A small-step operational semantics for our language, represented as a relation $\sigma_1 \sssemP \sigma_2$.
Note that a state $\sigma_i$ is a configuration of the form
$((\stmt, \lmap) \lstack, \gmap)$ where
$\stmt$ captures the statements to be executed in the current procedure, 
$\lmap$ assigns values to local variables in the current procedure,
$\lstack$ is the call-stack (excluding the current procedure),
and $\gmap$ assigns values to global variables.
}
\label{fig:semantics}
\end{figure}

Note that all the following definitions are parametric over a given procedure $\proc$.
E.g., we will use the word ``execution'' as shorthand for ``execution of $\proc$''.

We define an \emph{execution} (of $\proc$) to be a sequence of states $\sigma_0 \sigma_1 \cdots \sigma_n$ such that
$\sigma_i \sssem{\proc} \sigma_{i+1}$ for all $0 \leq i < n$.
%(In this paper we consider only \emph{sequential} executions of the procedure. Thus, no concurrent invocations
%of the procedure by a concurrent client of the library is allowed.)
Let $\initstate$ denote the \emph{initial state} of the library.
We say that an execution $\sigma_0 \sigma_1 \cdots \sigma_n$ is a \emph{feasible} execution if $\sigma_0 = \initstate$.
We say that a state $\sigma$ is \emph{ reachable} if there exists an execution $\pi = \initstate \sigma_1 \cdots \sigma$.

We define a \emph{history} (of $\proc$) to be an execution $\pi = \sigma_0 \sigma_1 \cdots \sigma_n$ such that
(a) $\sigma_0$ is the initial state of the library,
(b) $\sigma_n$ is an exit-state, and
(c) $\pi$ has an equal number of entry-states and exit-states.
Note that a history represents a complete  execution produced by a
sequence of invocations of the procedure.

We say that an execution is a \emph{trace} (of $\proc$) if it represents the complete execution
of the procedure produced by a single invocation of the procedure.
Note, however, that a trace may contain nested sub-traces,
which are themselves traces, due to recursive calls.

Given a trace $\pi = \sigma_0 \cdots \sigma_n$, we define
$\initial{\pi}$ to be $\sigma_0$,
$\final{\pi}$ to be $\sigma_n$,
$\inputval{\pi}$ to be value of the input parameter in $\initial{\pi}$,
and $\outputval{\pi}$ to be the value of the return variable in $\final{\pi}$.

We define the relation $\iosemP$ to be $\{ (\inputval{\pi},\outputval{\pi}) \; | \; \pi \text{ is a trace of } \proc \}$.
% we say $n \iosemP r$ if there exists a reachable exit state where the value of formal
% parameter is $n$ and return value is $r$.

\begin{definition}[Observational Purity]
\label{def:purity}
A procedure $\proc$ is said to be \emph{observationally pure} if the relation $\iosem{\proc}$ is a (partial) function:
that is, if for all $n$, $r_1$, $r_2$, if  $n \iosem{\proc} r_1$ and $n \iosem{\proc} r_2$, then $r_1 = r_2$.
\end{definition}

\subsection*{Logical Formula And Invariants}

Our methodology makes use of \emph{invariants}, which are represented using \emph{logical formulae}.
The set of logical formulae is defined as usual. We permit the same operators as allowed in our language.
We allow universal and existential quantification, and typically assume that the free variables are either
global or local variables.
% A  logical formula $\varphi$ is just a boolean-valued expression (in our language) over the set of global variables.
We write $\rho \models \varphi$
% as shorthand for $\basicevalsto{\gmap}{\varphi}{\code{true}}$ : \ie,
to denote that $\varphi$ evaluates to true when its free variables are assigned a value as in $\rho$.

However, as we saw with our running example in the introduction, it is
useful to allow the use of the name of a procedure in an invariant: \eg, an
invariant such as `(g = -1) $\vee$ (g = lastN *
\emph{factCache}(lastN-1))'.   We
extend our expression language by permitting the use of procedure
identifiers as function symbols (as above). Note that this extension is
permitted only for use in logical formula.

We extend our semantics $\rho \models \varphi$ to handle such extended invariants in the obvious way,
with $\rho$ mapping each procedure name to a mathematical function (and other names to their numeric values).
%Let $\extmap$ denote an extended map that assigns global variables a (numeric) value and assigns the
%procedure names a mathematical function as a value. We can then extend the expression evaluation semantics
%in a straightforward fashion to evaluate extended boolean expressions of the above form. 
%We will write $\extmap \models \varphi_e$ to denote that the extended boolean expression $\varphi_e$
%evaluates to true under $\extmap$.

Given a map $\rho$, a procedure name $\procname$, and a mathematical function $f$, we will write
$\rho[\procname \mapsto f]$ to indicate the extended map that assigns $\procname$ the value $f$ and every
other $x$ the value $\rho[x]$.
We will write $(\rho,f) \models \varphi$ to denote that $\rho[\procname \mapsto f] \models \varphi$.

Recall that a state $\sigma =(\lstack,\gmap)$ consists of a stack $\lstack$ and global-state $\gmap$.
Define $\text{env}(\sigma)$ to be the union of $\gmap$ and the current local state $\lmap$
if $\lstack$ is non-empty, and define $\text{env}(\sigma)$ to be just $\gmap$ otherwise.
We write $(\sigma,f) \models \varphi$ to denote that $(\text{env}(\sigma),f) \models \varphi$.
For any execution $\pi$, we write $(\pi,f) \models \varphi$ if for every entry-state and exit-state
$\sigma$ in $\pi$ $(\sigma,f) \models \varphi$.

%We say that a $\gmap \in \gmaps$ is a \emph{reachable global entry-state} of $\proc$ if
%there is a reachable entry-state of the form $(\lstack,\gmap)$.

\begin{definition}[Invariant]
\label{def:inv}
Given a procedure $\proc$ and a mathematical function $f$, we say that $(\proc,f)$ satisfy
an invariant $\inv$ if for every feasible execution $\pi$ of $\proc$, $(\pi,f) \models \varphi$.
%for every reachable global entry-state $\gmap$ of $\proc$,
%$\inv$ holds in $\gmap[\proc \mapsto f]$: that is, if $\gmap[\proc \mapsto f] \models \inv$.
We say that procedure $\proc$ satisfies an invariant $\inv$ if there exists a (mathematical)
function $f$ such that $(\proc,f)$ satisfies $\inv$.
\end{definition}

We now combine Definition~\ref{def:purity} and Definition~\ref{def:inv} into one as below.
Note that this combined requirement is stronger than a simple conjunction of the previous
two requirements. A procedure that satisfies Definitions~\ref{def:purity} and \ref{def:inv}
separately may not satisfy the following definition.
\begin{definition}[Purity+Invariant]
\label{def:pureinv}
A procedure $\proc$ is said to satisfy $\pureinv$ if
there exists a function $f$ such that for every trace $\pi$ in a feasible execution of $\proc$,
$\outputval{\pi} = f(\inputval{\pi})$ and $(\proc,f)$ satisfies $\inv$.
\end{definition}
