\section{Introduction}
\label{sec:intro}

A procedure in an imperative programming language is said to be
\emph{observationally pure} (OP) if for each specific argument value it has
a specific return value, across all possible sequences of calls to the
procedure, irrespective of what other code runs between these calls.  In
other words, the input-output behavior of an OP procedure mimics a mathematical
function.

% Observational purity is a useful property, as OP procedures can be memoized, and
% statements that call OP procedures can be subject to code motion, code
% optimization, etc.

A deterministic procedure that does not read any
pre-existing state other than its arguments is trivially OP.
However, it is common for procedures to update and read global variables,
typically for performance optimization,
while still being OP.
% still mimicking mathematical functions in terms of their input-output behavior.
% At the same time, they also use looping or recursion.
In this paper, we focus on the problem of checking observational purity of
procedures that read and write global variables, especially in the presence of recursion,
which makes the problem harder.

\para{Motivating Example}
We use procedure `factCache' in Listing~\ref{lst:factorialSimple}  as our running example. It
returns \code{n}! for a given argument \code{n}, and caches the return value of the
most recent call. It uses two \emph{private global} variables, \code{g} and \code{lastN}, to
implement the caching. \code{g} is initialized to -1. After
the first call to the procedure onwards, \code{g} stores the return value
of the most recent call, and \code{lastN} stores the argument of
the most recent call. Clearly this procedure is OP, and mimics the
input-output behavior of a factorial procedure that does not cache
any results. 

\begin{lstlisting}[float,language=c,basicstyle=\scriptsize,caption= {Procedure factCache:
      returns n!, and memoizes most recent result.},
    label=lst:factorialSimple]
  
int g := -1;
int lastN := 0;
int factCache( int n) {
  if(n <= 1) {
    result := 1;
  } else if (g != -1 && n == lastN) {
    result := g;
  } else {
    g = n * factCache( n - 1 );
    lastN = n;
    result := g;
  }
  return result;
}
\end{lstlisting}

\para{Proposed Approach}
% \label{ssec:intro:approach}
%
%% 1. We are looking for a Hoare logic style approach, for increased
%%    precision. Herein, how to process the recursive calls? One solution is
%%    to make the user guess the mathematical function implemented by the
%%    procedure as well as the invariant on the global variables. Now, the
%%    recursive call can be replaced by these specifications, and the whole
%%    procedure can be checked whether it always returns n!.
%
%% 2. The approach above would itself be novel. However, one issue is that
%%    theorem provers face difficulty in proving equivalence of complex
%%    formulas. Also, humans face difficulty in inferring meanings of
%%    procedures. We therefore propose a more syntactic approach that is
%%    easier on the theorem prover and on the human. 
%
% Floyd-Hoare logic has been commonly used in previous approaches that try to
% tackle verification tasks with good precision.
Our approach is based on Floyd-Hoare logic, which typically
requires a specification of the procedure to be provided. One candidate
specification would be a full functional specification of the
procedure. If the user specifies that \code{factCache} realizes \code{n}!, then the
verifier could replace Line~10 in the code with `\code{g = n * (n-1)!}'. This, on
paper, is sufficient to assert that Line 12 always assigns \code{n}! to
\code{result}. However, to establish that Line~8 also does the same, an invariant
would need to be provided that describes the possible values of \code{g} before
any invocation to the procedure. In our example, a suitable invariant would
be `(\code{g} = -1) $\vee$ (\code{g} = \code{lastN}!)'. The verifier would also need to verify
that at the procedure's exit the invariant is re-established. Lines 10-12,
with the recursive call replaced by (\code{n}-1)!, suffices on paper to
re-establish the invariant.

The candidate approach described above, while plausible, suffers from
two weaknesses. First, a mathematical specification of the function
being computed may be complex and non-trivial to write. (Note, for example,
that \code{factCache} is defined for negative integers while factorial is not.
Thus, the previous candidate specification is actually incorrect for this edge
case.)
Second, the underlying theorem prover
would need to prove complex arithmetic properties, e.g., that \code{n} * (\code{n}-1)! is
equal to \code{n}!. Complex proofs such as this may be beyond the scope of many
existing theorem provers.

Our key insight is to sidestep the challenges mentioned by introducing a
function symbol, say \emph{factCache}, and replacing the recursive call for the purposes
of verification with this function symbol. Intuitively, \emph{factCache} represents the
mathematical function that the given procedure mimics \emph{if} the procedure is
OP.  In our example, Line~10 would become `g = n * \emph{factCache}(n-1)'. This step
needs no human involvement. The approach needs an invariant; however, in a
novel manner, we allow the invariant also to refer to \emph{factCache}. In our example,
a suitable invariant would be `(\code{g} = -1) $\vee$ (\code{g} = \code{lastN} *
\emph{factCache}(\code{lastN}-1))'. This sort of invariant is relatively easy to construct;
e.g., a human could arrive at it just by looking at Line~2 and with a local
reasoning on Lines~10 and~11. Given this invariant, (a) a theorem prover
could infer that the condition in Line~7 implies that Line~8 necessarily
copies the value of `\code{n} * \emph{factCache}(\code{n}-1)' into `\code{result}'. Due to the transformation to Line~10 mentioned above,
(b) the theorem prover can infer that Line~12 also does the same. Note that since these two expressions are syntactically
identical, a theorem prover can easily establish that they are equal in
value.  Finally, since Line~6 is reached under a different condition than
Lines~8 and~12, the verifier has finished establishing that the procedure
always returns the same expression in \code{n} for any given value of \code{n}.

Similarly, using the modified Line~10 mentioned above and from Line~11, the
prover can re-establish that \code{g} is equal to `\code{lastN} * \emph{factCache}(\code{lastN} - 1)' when
control reaches Line~12. Hence, the necessary step of proving the given
invariant to be a valid invariant is also complete. 

Note, the effectiveness of the approach depends on the nature of the given
invariant. For instance, if the given invariant was `(\code{g} = -1) $\vee$ (\code{g} =
lastN!)', which is also technically correct, then the theorem prover may
not be able to establish that in Lines~8 and~12 the variable `\code{g}' always
stores the same expression in \code{n}. However, it is our claim that in fact it is the
invariant `(\code{g} = -1) $\vee$ (\code{g} = \code{lastN} * \emph{factCache}(\code{lastN}-1))' that is
easier to infer by a human or by a potential tool, as justified by us two
paragraphs above.

\para{Salient Aspects Of Our Approach}

This paper makes two significant contributions. First, it tackles the
circularity problem that arises due to the use of a presumed-to-be OP
procedure in assertions and invariants and the use of these invariants in
proving the procedure to be OP. This requires us to prove the soundness of
an approach that \emph{simultaneously} verifies observational purity as well the validity of
invariants (as they cannot be decoupled).

Secondly, we show that a direct approach to this verification problem (which we
call the existential approach) reduces it to a problem of verifying that a logical formula
is a tautology. The structure of the generated formula, however, makes the resulting
theorem prover instances hard. We show how a conservative approximation can be
used to convert this hard problem into an easier problem of checking satisfiability
of a quantifier-free formula, which is something within the scope of state-of-the-art theorem
provers.

%% should I talk about why F(2) *3 instead of F(3) ?

The most closely related previous approaches are by Barnett et
al.~\cite{barnett200499,barnett2006allowing}, and by
Naumann~\cite{naumann2007observational}.  These approaches check observational
purity of procedures that maintain mutable global state. However, none of
these approaches use a function symbol in place of recursive calls or
within invariants. Therefore, it is not clear that these approaches can
verify recursive procedures. 
Barnett et al., in fact, state ``there is a circularity - it would take a delicate argument, and additional conditions,
to avoid unsoundness in this case''.
To the best of our knowledge ours is the first paper to show that it is
feasible to check observational purity of procedures that maintain mutable
global state for optimization purposes and that make use of recursion.


Being able to verify that a procedure is OP has many potential
applications. The most obvious one is that OP procedures can be
memoized. That is, input-output pairs can be recorded in a table, and calls
to the procedure can be elided whenever an argument is seen more than
once. This would not change the semantics of the overall program that calls
the procedure, because the procedure always returns the same value for the
same argument (and mutates only private global variables). Another
application is that if a loop contains a call to an OP procedure, then the
loop can be parallelized (provided the procedure is modified to access and
update its private global variables in a single atomic operation).

%In this paper, we do make a number of assumptions. The global variables
%that the procedure reads or updates are assumed to be private to it, in the
%sense that other code cannot access these variables at all.  For simplicity
%of presentation, we assume that loops are not present, and have been
%converted to recursion. However, we do not restrict the procedure to use
%only tail recursion. We do not as yet address pointers and memory
%allocation. 

The rest of this paper is structured as
follows. Section~\ref{sec:background} introduces the core programming
language that we address. Section~\ref{sec:semantics} provides formal
semantics for our language, as well as definitions of invariants and
observational purity. Section~\ref{sec:vcgen} describes our approach
formally. Section~\ref{sec:invariant} discusses an approach for generating
an invariant automatically in certain cases. Section~\ref{sec:experiments}  describes evaluation of our approach on a few realistic examples.
Section~\ref{sec:related} describes related work.
More details about the proofs and the examples can be found in~\cite{CheckingOP:arxiv}.

