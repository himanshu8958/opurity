\section{Related work}\label{sec:related}
Java modelling Language(JML)~\cite{leavens2008jml} is a specification
language for Java Programs which uses Hoare style pre and post
conditions. Various specification languages such as JML and spec\#
allow provably pure procedure to be used in specification.
This overly restrictive constraint of using only provable pure
procedure was first overcome by Barnett~\cite{barnett200499}, and we
also solve the same problem as them. However, we allow the
specification of a procedure to reference the same procedure.They also
note in the paper~\cite{barnett200499} that ``If we allow some P_g to
involve \textit{f}, then there is a circularity - it would take a
delicate argument, and additional conditions, to avoid unsoundness in
this case''. In this work, other than allowing specifications of a
procedure to self-reference we have also reduced the need for
annotations. Moreover, the annotations that are needed, we claim they
can be generated automatically for a large number of programs.


DAC~\cite{lahiri2013differential} and Yahav et
al.~\cite{partush2013abstract} compare a program to an older version
of itself. This is althought a different problem than ours but the
idea of comparing a program to itself is central to the impurity
witness approach.

Naumann~\cite{naumann2007observational} also relaxes on what
procedures can be used in specifications. In this paper, a procedure
is labelled Observationally pure if it is output equivalent to a
side-effect free procedure, which is different from our problem
statement. Naumann's definition of OP does not constrain a procedure
to respect a mathematical function. This work uses a theory for
simulations of procedure to check the property.

Cok~\cite{cok2008extensions} builds upon Barnett's
work~\cite{barnett2006allowing} and~\cite{barnett200499} suggests
partitioning the set of procedures into ``pure'', ``secret'' and
``query'' methods, each scoped to a particular data group to manage Op
checking. And the procedure in the ``query'' data group are OP.  But,
this body of
work~\cite{cok2008extensions}~\cite{barnett2006allowing}~\cite{barnett200499}
cannot prove a recursive procedure to be OP. Also, they need a lot of
annotations.

Finifter~\cite{cok2008extensions} takes a different approach of
restricting the programming language in order to make OP checking
simpler. In the restricted language called Joe-E, OP methods have all
objects reachable from the parameters marked as immutable.

Salcianu~\cite{sualcianu2005purity} gives a static analysis that
checks if a method modifies the pre-existing state. All the operators
used in specifications do not have side effects. If a procedure does
not modify the pre-existing state it is called pure and
~\cite{barnett200499} suggests that such procedures can be used in
specifications. Our work in comparison generalizes further by allowing
procedures that modify pre-existing state but behave as mathematical
functions in specifications. We would like to point out that in their
work they manually marked library methods that did caching but were
semantically preserving as pure.

\nocite{barnett2004spec}
\nocite{lahiri2013differential}
\nocite{de2008z3}
\nocite{alpern1988detecting}
\nocite{sondergaard1990referential}
\nocite{flanagan2001avoiding}
\nocite{sualcianu2005purity}
\nocite{cytron1991efficiently}
\nocite{leino2008boogie}