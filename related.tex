\section{Related work}\label{sec:related}

The previous work that is most closely related to our work is by Barnett et
al.~\cite{barnett200499,barnett2006allowing}. Their approach is based on
the same notion of observational purity as our approach. However, their
approach is based on a more complex notion of invariant than our approach,
which relates pairs of global states. Their approach has a similar
structure as ours, in that they check the inductivity of the invariant, and
also check that for the same parameter value the procedure returns the same
value as long as the starting global states are related as per the
invariant. However, their approach is not defined for recursive procedures;
they in fact state that  ``there is a circularity - it would
take a delicate argument, and additional conditions, to avoid unsoundness
in this case''. Our approach allows the invariant to refer to a function
symbol that represents the meaning of the procedure being checked; this
allows the invariant to be simply stated in many cases, and also also
allows recursive procedures to be checked. 

Cok et al.~\cite{cok2008extensions}  generalize the work of Barnett
et al.'s work, and suggest classifying procedures into categories ``pure'',
``secret'', and ``query''. The ``query'' procdures are observationally
pure. Again, recursive procedures are not addressed.

Naumann~\cite{naumann2007observational} proposes a notion of observational
purity that is also the same as ours. Their paper gives a methodology but
not really an automated approach for checking the observational purity of a
given procedure. Their methodology is not similar to ours; rather, it is
based finding a \emph{weakly pure} procedure that simulates the given
procedure as far as externally visible state changes and the return value
are concerned. They have no notion of an invariant that uses a
function symbol that represents the procedure, and they don't explicitly
address the checking of recursive procedures.

There exists a significant body of work on identifying differences between
two similar procedures. For instance, differential assertion
checking~\cite{lahiri2013differential} checks if two procedures can ever
start from the same state but end in different states such that exactly one
of the ending states fails a given assertion. Their approach is based on
logical reasoning, and accommodates recursive procedures. Our impurity
witness approach has some similarity with their approach, because it is
based on comparing the given procedure with itself. However, our comparison
is stricter, because in our setting, starting with a common argument value
but from different global states that are both within the invariant should
not cause a difference in the return value. Furthermore, technically our
approach is different because we use an invariant that refers to a function
symbol that represents the procedure being checked, which is not a feature
of their invariants. Partush et al.~\cite{partush2013abstract} solve a
similar problem as differential assertion checking, but using abstract
interpretation instead of logical reasoning.

There is a substantial body of work on checking if a procedure is
\emph{pure}. The standard definition of purity is that the procedure not
modify any objects that existed before the procedure was invoked, and not
modify any  global variables. Salcianu et
al.~\cite{sualcianu2005purity} describe a static analysis to check purity.
Finifter et al.~\cite{finifter2008verifiable} propose an approach to
enforce purity using language restrictions. Various tools exist, such as
JML~\cite{leavens2008jml} and Spec\#~\cite{specSharp}, that use logical
techniques based on annotations to prove procedures as pure.  Purity is a
more restrictive notion than observational purity; procedures such
as our `factorial' example are observationally pure, but not pure because
they use as well as update state that persists between calls to the
procedure. 


\nocite{barnett2004spec}
\nocite{lahiri2013differential}
\nocite{de2008z3}
\nocite{alpern1988detecting}
\nocite{sondergaard1990referential}
\nocite{flanagan2001avoiding}
\nocite{sualcianu2005purity}
\nocite{cytron1991efficiently}
\nocite{leino2008boogie}
