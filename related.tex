\section{Related work}\label{sec:related}
Java modelling Language(JML)~\cite{leavens2008jml} is a specification
lanugage for Java Programs which uses Hoare style pre and post
conditions. Various specification languages such as JML and spec\#
allow provably pure procedure to be used in specification.
This overly restrictive constraint of using only provable pure
procedure was first overcome by Barnett~\cite{barnett200499}, and we
also sovle the same problem as them. However, we allow the
specification of a procedure to reference the same procedure.They also
note in the paper~\cite{barnett200499} that ``If we allow some P_g to
involve \textit{f}, then there is a circularity - it would take a
delicate argument, and additional conditions, to avoid unsoundness in
this case''. In this work, other than allowing specifications of a
procedure to self-reference we have also reduced the need for
annotations. Moreover, the annotations that are needed, we claim they
can be generated automatically for a large number of programs.

The idea of comparing a program to
itself~\cite{lahiri2013differential}~\cite{partush2013abstract} is
closely related to the impurity witness
approach. DAC~\cite{lahiri2013differential} uses this idea for finding
the assertions that failed in a version of a program with respect to
another version. Whereas, Partush and Yahav~\cite{partush2013abstract}
focus on finding the parameter values for which the two versions of
the procedure differ.

Naumann~\cite{naumann2007observational} calls a procedure OP if it is
output-equivalent to a procedure which is a side-effect free. And
side-effect-freeness does not entail OPness as the procedure's return
value may be dependent on some global variable. This work
presents/uses a theory for simulations, closely related to ownership
types. Thus this work is closely related but they solve a different
problem.

Cok~\cite{cok2008extensions} builds upon Barnett's
work~\cite{barnett2006allowing} and~\cite{barnett200499} suggests
partitioning the set of methods into ``pure'', ``secret'' and
``query'' methods, each scoped to a particular data group. The query
methods are OP. They give a set of rules to be followed by methods in
each group. Thus, structuring for modular reasoning about OPness.

Finifter~\cite{cok2008extensions} takes a different approach of
restricting the programming language in order to make OP checking
simpler. In the restricted language called Joe-E, OP methods have all
objects reachable from the parameters marked as immutable.

Salcianu~\cite{sualcianu2005purity} gives a static analysis that
checks if a method modifies the pre-existing state. All the operators
used in specifications do not have side effects. If a procedure does
not modify the pre-existing state it is called pure and
~\cite{barnett200499} suggests that such procedures can be used in
specifications. Our work in comparison generalizes further by allowing
procedures that modify pre-existing state but behave as mathematical
functions in specifications. We would like to point out that in their
work they manually marked library methods that did caching but were
semantically preserving as pure.

\nocite{barnett2004spec}
\nocite{lahiri2013differential}
\nocite{de2008z3}
\nocite{alpern1988detecting}
\nocite{sondergaard1990referential}
\nocite{flanagan2001avoiding}
\nocite{sualcianu2005purity}
\nocite{cytron1991efficiently}
\nocite{leino2008boogie}