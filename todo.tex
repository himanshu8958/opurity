\section*{TO DO}

\begin{enumerate}

\item Ideally, the flow should be
\begin{enumerate}
\item Language syntax (sections 2.1 and 2.2); (the syntax of invariants could be
introduced at the same time, as it is almost a subset of the language syntax, or later)

\item Semantics (section 3: trace, history part, extended to define a set of histories
as the semantics of a procedure); no need for invariants here.

\item Purity definition (based on the semantics defined above)

\item Converting the program (or library or procedure) into a logical formulae:
\begin{enumerate}
\item The common verification-condition (path-condition) generation (section 2.3
and parts of section 2.2)
\item the existential approach
\item the impurity witness approach
\end{enumerate}

\end{enumerate}


\item There is room for improving the presentation of Algorithm 1 and 2:
\begin{enumerate}

\item Notation improvement:
\begin{enumerate}
\item We can translate the entire program (rather than a single path)
into the formula $T_{foo}$, which seems the right thing to do. So,
verification-condition may be a better name than path-condition.
Or, some name other than these two?
\item rename $T_{foo}$ to something better ... I will use $\varphi_{vc}$
below.
\end{enumerate}

\item The formulae produced by algorithms 1 and 2 include two parts:
one to check that the conjectured-invariant is an invariant, and the
other to check for purity. Separating these out may make it easier for
a reader to understand the complex formula.

\item In particular, the bulk of the conditions encode the standard
precondition/postcondition treatment (at procedure-entry, call-site,
and procedure-exit). It may be better to push these conditions into
the common $\varphi_{vc} = T_{foo}$ part. This can be done if generation of
$T_{foo}$ itself is parametrized by the invariant, which seems the right thing to do.

\item Specifically, let us make $\varphi_{vc}$ include the "assert precondition"
and "assume postcondition" for every call-site within the procedure, as well
as the "assume precondition" at procedure-entry, but not the "assert
postcondition" at procedure-exit. This looks a bit odd, but the "assert
postcondition" is the only part that we handle differently in the two algorithms.

\item What's the correctness property we have for the generated verification
condition $\varphi_{vc}$, that is sufficient to establish correctness of both approaches?
Essentially, every execution $\pi$ identifies bindings for the free variables in $\varphi_{vc}$ (except for $F$);
let $\varphi_\pi$ denote the formula obtained from $\varphi_{vc}$ with these bindings.
Then, we want the following to hold true: $\varphi_\pi$ is true provided all the
nested (recursive) executions preconditions/postconditions are satisfied.

Let $i$ and $o$ be the free-variables in $\varphi$
representing the (initial value of the) input parameter and the
(final value of the) returned output. I think it is something like:
\emph{
If there is any execution that
satisfies the assumed invariant for input value $i_1$ that produces
an output value of $o_1$, then $\varphi[i_1/i,o_1/o]$ should be
satisfiable.
}


\end{enumerate}

\end{enumerate}