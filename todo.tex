\section*{TO DO}

\begin{enumerate}

\item (Rama) I am leaving the following discussion in place until we sort this out.
My current thinking on my questions below is better reflected in the formalism
section added into the paper. In particular, I think that we adopt standard
approaches to compute both a verification-condition and a post-condition,
each of which has a different purpose and correctness requirement.

\item The formulae produced by algorithms 1 and 2 include two parts:
one to check that the conjectured-invariant is an invariant, and the
other to check for purity. Separating these out may make it easier for
a reader to understand the complex formula.

$>$ But in case of the existential approach the power reduces. The
inductivity check may fail on some invariants when not combined with
the existential approach. For instance in the factorial example, inv
check fails for invariant g = -1 OR g = 19! If we separate the two
parts, for the existential approach we just say that if the invariant
is correct then the procedure is OP. Whereas in the combined approach
we have stronger guarantee. 

$>$ (Rama) I don't understand your concern. My above suggestion
is about changing the presentation to make it understandable, not changing
the algorithm/technique itself.

\item What's the correctness property we have for the generated verification
condition $\varphi_{vc}$, that is sufficient to establish correctness of both approaches?
Essentially, every execution $\pi$ identifies bindings for the free variables in $\varphi_{vc}$ (except for $F$);
let $\varphi_\pi$ denote the formula obtained from $\varphi_{vc}$ with these bindings.
Then, we want the following to hold true: $\varphi_\pi$ is true provided all the
nested (recursive) executions preconditions/postconditions are satisfied.

The correctness of the existential approach is based on the following property

\begin{definition}[valid and consistent invariant( Function,
    Formula)]
  \label{def:validConsistentInvariant}
  $\\\vci{\F}{\inv}$ is a boolean property that is true if for all
  traces and prefix-trace-segments $x$ of procedure `\foo' such that
  $(\atEntry{x}, \F) \satisfies \inv$ the following holds

  \begin{enumerate}
  \item if $x$ is a trace.
    \begin{enumerate}
    \item If $x$ has a recursive call
      \begin{itemize}
      \item then $(\beforeCall{x}, \F) \satisfies \inv$ and
      \item let $x$ have the procedure call statement, say $y =
        \foo(z)$. Then we change the value of $y$ to $y'$ and the
        value of the global variable $\g$ to $g'$ after the procedure
        call statement such that $y' = \F(z)$ and $(g', \F)
        \satisfies \inv$.
      \end{itemize}
      Then $\return{x} = \F(\n)$, where $\n$ is the argument to
      trace $x$ and $(\atEnd{x}, \F) \satisfies \inv$.
    \item if $x$ does not have a recursive call
      then $(\atEnd{x}, \F) \satisfies \inv$ and $\return{x} =
      \F(\n)$, where $\n$ is the argument to trace $x$.
    \end{enumerate}
  \item if $x$ is a prefix trace segment.\\
    Then $(\atEnd{x}, \F) \satisfies \inv$.
  \end{enumerate}
\end{definition}

$>$ (Rama) I have difficulty following the above for several reasons. It is
a monolithic statement that combines everything into one, and that makes it
hard to understand. It is mixing up what we intend to prove in our application;
it is better if we can express this in terms of common, well-known, ideas
(independent of the intended usage/application here). For example,
the notion of ``post-condition'' is well-understood: for example,
\emph{post(stmt, pre)} as a representation of the post-condition after
the execution of \emph{stmt} starting from a state satisfying \emph{pre}
is clear (modulo details like whether we are talking about the strongest
post-condition or any correct post-condition). The other relevant notion
is that of "verification-condition'', by which I mean combining the
assumptions (e.g., assume precondition is true at entry) and
assertions (e.g., assert that precondition holds true at recursive
callsite) into a logical formula. 

But the proof of correctness of the impurity witness approach is based
on proving the implication that if the formula from impurity witness
is UNSAT then the formula produced by the existential approach is
SAT. I'll elaborate on this.

\end{enumerate}
